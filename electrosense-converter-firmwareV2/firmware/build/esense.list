
build/esense.elf:     file format elf32-littlearm


Disassembly of section .text:

08002160 <Reset_Handler>:
 8002160:	b672      	cpsid	i
 8002162:	4826      	ldr	r0, [pc, #152]	; (80021fc <endfiniloop+0x6>)
 8002164:	f380 8809 	msr	PSP, r0
 8002168:	4825      	ldr	r0, [pc, #148]	; (8002200 <endfiniloop+0xa>)
 800216a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800216e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8002172:	6008      	str	r0, [r1, #0]
 8002174:	2002      	movs	r0, #2
 8002176:	f380 8814 	msr	CONTROL, r0
 800217a:	f3bf 8f6f 	isb	sy
 800217e:	f009 f829 	bl	800b1d4 <__core_init>
 8002182:	f009 f857 	bl	800b234 <__early_init>
 8002186:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800218a:	491e      	ldr	r1, [pc, #120]	; (8002204 <endfiniloop+0xe>)
 800218c:	4a1e      	ldr	r2, [pc, #120]	; (8002208 <endfiniloop+0x12>)

0800218e <msloop>:
 800218e:	4291      	cmp	r1, r2
 8002190:	bf3c      	itt	cc
 8002192:	f841 0b04 	strcc.w	r0, [r1], #4
 8002196:	e7fa      	bcc.n	800218e <msloop>
 8002198:	491c      	ldr	r1, [pc, #112]	; (800220c <endfiniloop+0x16>)
 800219a:	4a18      	ldr	r2, [pc, #96]	; (80021fc <endfiniloop+0x6>)

0800219c <psloop>:
 800219c:	4291      	cmp	r1, r2
 800219e:	bf3c      	itt	cc
 80021a0:	f841 0b04 	strcc.w	r0, [r1], #4
 80021a4:	e7fa      	bcc.n	800219c <psloop>
 80021a6:	491a      	ldr	r1, [pc, #104]	; (8002210 <endfiniloop+0x1a>)
 80021a8:	4a1a      	ldr	r2, [pc, #104]	; (8002214 <endfiniloop+0x1e>)
 80021aa:	4b1b      	ldr	r3, [pc, #108]	; (8002218 <endfiniloop+0x22>)

080021ac <dloop>:
 80021ac:	429a      	cmp	r2, r3
 80021ae:	bf3e      	ittt	cc
 80021b0:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80021b4:	f842 0b04 	strcc.w	r0, [r2], #4
 80021b8:	e7f8      	bcc.n	80021ac <dloop>
 80021ba:	2000      	movs	r0, #0
 80021bc:	4917      	ldr	r1, [pc, #92]	; (800221c <endfiniloop+0x26>)
 80021be:	4a18      	ldr	r2, [pc, #96]	; (8002220 <endfiniloop+0x2a>)

080021c0 <bloop>:
 80021c0:	4291      	cmp	r1, r2
 80021c2:	bf3c      	itt	cc
 80021c4:	f841 0b04 	strcc.w	r0, [r1], #4
 80021c8:	e7fa      	bcc.n	80021c0 <bloop>
 80021ca:	f009 f807 	bl	800b1dc <__init_ram_areas>
 80021ce:	f009 f802 	bl	800b1d6 <__late_init>
 80021d2:	4c14      	ldr	r4, [pc, #80]	; (8002224 <endfiniloop+0x2e>)
 80021d4:	4d14      	ldr	r5, [pc, #80]	; (8002228 <endfiniloop+0x32>)

080021d6 <initloop>:
 80021d6:	42ac      	cmp	r4, r5
 80021d8:	da03      	bge.n	80021e2 <endinitloop>
 80021da:	f854 1b04 	ldr.w	r1, [r4], #4
 80021de:	4788      	blx	r1
 80021e0:	e7f9      	b.n	80021d6 <initloop>

080021e2 <endinitloop>:
 80021e2:	f009 f867 	bl	800b2b4 <main>
 80021e6:	4c11      	ldr	r4, [pc, #68]	; (800222c <endfiniloop+0x36>)
 80021e8:	4d11      	ldr	r5, [pc, #68]	; (8002230 <endfiniloop+0x3a>)

080021ea <finiloop>:
 80021ea:	42ac      	cmp	r4, r5
 80021ec:	da03      	bge.n	80021f6 <endfiniloop>
 80021ee:	f854 1b04 	ldr.w	r1, [r4], #4
 80021f2:	4788      	blx	r1
 80021f4:	e7f9      	b.n	80021ea <finiloop>

080021f6 <endfiniloop>:
 80021f6:	f008 bfef 	b.w	800b1d8 <__default_exit>
 80021fa:	0000      	.short	0x0000
 80021fc:	20000800 	.word	0x20000800
 8002200:	08002000 	.word	0x08002000
 8002204:	20000000 	.word	0x20000000
 8002208:	20000400 	.word	0x20000400
 800220c:	20000400 	.word	0x20000400
 8002210:	0800cd84 	.word	0x0800cd84
 8002214:	20000800 	.word	0x20000800
 8002218:	20000928 	.word	0x20000928
 800221c:	20000928 	.word	0x20000928
 8002220:	20001650 	.word	0x20001650
 8002224:	08002160 	.word	0x08002160
 8002228:	08002160 	.word	0x08002160
 800222c:	08002160 	.word	0x08002160
 8002230:	08002160 	.word	0x08002160

08002234 <_binary_data_license_bin_start>:
 8002234:	2a2a2a2a 	.word	0x2a2a2a2a
 8002238:	2a2a2a2a 	.word	0x2a2a2a2a
 800223c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002240:	2a2a2a2a 	.word	0x2a2a2a2a
 8002244:	2a2a2a2a 	.word	0x2a2a2a2a
 8002248:	2a2a2a2a 	.word	0x2a2a2a2a
 800224c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002250:	2a2a2a2a 	.word	0x2a2a2a2a
 8002254:	2a2a2a2a 	.word	0x2a2a2a2a
 8002258:	2a2a2a2a 	.word	0x2a2a2a2a
 800225c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002260:	2a2a2a2a 	.word	0x2a2a2a2a
 8002264:	2a2a2a2a 	.word	0x2a2a2a2a
 8002268:	2a2a2a2a 	.word	0x2a2a2a2a
 800226c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002270:	2a2a2a2a 	.word	0x2a2a2a2a
 8002274:	2a2a2a2a 	.word	0x2a2a2a2a
 8002278:	2a2a2a2a 	.word	0x2a2a2a2a
 800227c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002280:	2a2a2a2a 	.word	0x2a2a2a2a
 8002284:	0a0d2a2a 	.word	0x0a0d2a2a
 8002288:	65657246 	.word	0x65657246
 800228c:	534f5452 	.word	0x534f5452
 8002290:	72654b20 	.word	0x72654b20
 8002294:	206c656e 	.word	0x206c656e
 8002298:	2e303156 	.word	0x2e303156
 800229c:	0d302e30 	.word	0x0d302e30
 80022a0:	706f430a 	.word	0x706f430a
 80022a4:	67697279 	.word	0x67697279
 80022a8:	28207468 	.word	0x28207468
 80022ac:	32202943 	.word	0x32202943
 80022b0:	20373130 	.word	0x20373130
 80022b4:	7a616d41 	.word	0x7a616d41
 80022b8:	632e6e6f 	.word	0x632e6e6f
 80022bc:	202c6d6f 	.word	0x202c6d6f
 80022c0:	2e636e49 	.word	0x2e636e49
 80022c4:	20726f20 	.word	0x20726f20
 80022c8:	20737469 	.word	0x20737469
 80022cc:	69666661 	.word	0x69666661
 80022d0:	7461696c 	.word	0x7461696c
 80022d4:	202e7365 	.word	0x202e7365
 80022d8:	6c6c4120 	.word	0x6c6c4120
 80022dc:	67695220 	.word	0x67695220
 80022e0:	20737468 	.word	0x20737468
 80022e4:	65736552 	.word	0x65736552
 80022e8:	64657672 	.word	0x64657672
 80022ec:	0d0a0d2e 	.word	0x0d0a0d2e
 80022f0:	7265500a 	.word	0x7265500a
 80022f4:	7373696d 	.word	0x7373696d
 80022f8:	206e6f69 	.word	0x206e6f69
 80022fc:	68207369 	.word	0x68207369
 8002300:	62657265 	.word	0x62657265
 8002304:	72672079 	.word	0x72672079
 8002308:	65746e61 	.word	0x65746e61
 800230c:	66202c64 	.word	0x66202c64
 8002310:	20656572 	.word	0x20656572
 8002314:	6320666f 	.word	0x6320666f
 8002318:	67726168 	.word	0x67726168
 800231c:	74202c65 	.word	0x74202c65
 8002320:	6e61206f 	.word	0x6e61206f
 8002324:	65702079 	.word	0x65702079
 8002328:	6e6f7372 	.word	0x6e6f7372
 800232c:	74626f20 	.word	0x74626f20
 8002330:	696e6961 	.word	0x696e6961
 8002334:	6120676e 	.word	0x6120676e
 8002338:	706f6320 	.word	0x706f6320
 800233c:	666f2079 	.word	0x666f2079
 8002340:	68740a0d 	.word	0x68740a0d
 8002344:	73207369 	.word	0x73207369
 8002348:	7774666f 	.word	0x7774666f
 800234c:	20657261 	.word	0x20657261
 8002350:	20646e61 	.word	0x20646e61
 8002354:	6f737361 	.word	0x6f737361
 8002358:	74616963 	.word	0x74616963
 800235c:	64206465 	.word	0x64206465
 8002360:	6d75636f 	.word	0x6d75636f
 8002364:	61746e65 	.word	0x61746e65
 8002368:	6e6f6974 	.word	0x6e6f6974
 800236c:	6c696620 	.word	0x6c696620
 8002370:	28207365 	.word	0x28207365
 8002374:	20656874 	.word	0x20656874
 8002378:	666f5322 	.word	0x666f5322
 800237c:	72617774 	.word	0x72617774
 8002380:	2c292265 	.word	0x2c292265
 8002384:	206f7420 	.word	0x206f7420
 8002388:	6c616564 	.word	0x6c616564
 800238c:	0d6e6920 	.word	0x0d6e6920
 8002390:	6568740a 	.word	0x6568740a
 8002394:	666f5320 	.word	0x666f5320
 8002398:	72617774 	.word	0x72617774
 800239c:	69772065 	.word	0x69772065
 80023a0:	756f6874 	.word	0x756f6874
 80023a4:	65722074 	.word	0x65722074
 80023a8:	69727473 	.word	0x69727473
 80023ac:	6f697463 	.word	0x6f697463
 80023b0:	69202c6e 	.word	0x69202c6e
 80023b4:	756c636e 	.word	0x756c636e
 80023b8:	676e6964 	.word	0x676e6964
 80023bc:	74697720 	.word	0x74697720
 80023c0:	74756f68 	.word	0x74756f68
 80023c4:	6d696c20 	.word	0x6d696c20
 80023c8:	74617469 	.word	0x74617469
 80023cc:	206e6f69 	.word	0x206e6f69
 80023d0:	20656874 	.word	0x20656874
 80023d4:	68676972 	.word	0x68676972
 80023d8:	74207374 	.word	0x74207374
 80023dc:	750a0d6f 	.word	0x750a0d6f
 80023e0:	202c6573 	.word	0x202c6573
 80023e4:	79706f63 	.word	0x79706f63
 80023e8:	6f6d202c 	.word	0x6f6d202c
 80023ec:	79666964 	.word	0x79666964
 80023f0:	656d202c 	.word	0x656d202c
 80023f4:	2c656772 	.word	0x2c656772
 80023f8:	62757020 	.word	0x62757020
 80023fc:	6873696c 	.word	0x6873696c
 8002400:	6964202c 	.word	0x6964202c
 8002404:	69727473 	.word	0x69727473
 8002408:	65747562 	.word	0x65747562
 800240c:	7573202c 	.word	0x7573202c
 8002410:	63696c62 	.word	0x63696c62
 8002414:	65736e65 	.word	0x65736e65
 8002418:	6e61202c 	.word	0x6e61202c
 800241c:	726f2f64 	.word	0x726f2f64
 8002420:	6c657320 	.word	0x6c657320
 8002424:	6f63206c 	.word	0x6f63206c
 8002428:	73656970 	.word	0x73656970
 800242c:	0d666f20 	.word	0x0d666f20
 8002430:	6568740a 	.word	0x6568740a
 8002434:	666f5320 	.word	0x666f5320
 8002438:	72617774 	.word	0x72617774
 800243c:	61202c65 	.word	0x61202c65
 8002440:	7420646e 	.word	0x7420646e
 8002444:	6570206f 	.word	0x6570206f
 8002448:	74696d72 	.word	0x74696d72
 800244c:	72657020 	.word	0x72657020
 8002450:	736e6f73 	.word	0x736e6f73
 8002454:	206f7420 	.word	0x206f7420
 8002458:	6d6f6877 	.word	0x6d6f6877
 800245c:	65687420 	.word	0x65687420
 8002460:	666f5320 	.word	0x666f5320
 8002464:	72617774 	.word	0x72617774
 8002468:	73692065 	.word	0x73692065
 800246c:	72756620 	.word	0x72756620
 8002470:	6873696e 	.word	0x6873696e
 8002474:	74206465 	.word	0x74206465
 8002478:	6f64206f 	.word	0x6f64206f
 800247c:	2c6f7320 	.word	0x2c6f7320
 8002480:	75730a0d 	.word	0x75730a0d
 8002484:	63656a62 	.word	0x63656a62
 8002488:	6f742074 	.word	0x6f742074
 800248c:	65687420 	.word	0x65687420
 8002490:	6c6f6620 	.word	0x6c6f6620
 8002494:	69776f6c 	.word	0x69776f6c
 8002498:	6320676e 	.word	0x6320676e
 800249c:	69646e6f 	.word	0x69646e6f
 80024a0:	6e6f6974 	.word	0x6e6f6974
 80024a4:	0a0d3a73 	.word	0x0a0d3a73
 80024a8:	68540a0d 	.word	0x68540a0d
 80024ac:	62612065 	.word	0x62612065
 80024b0:	2065766f 	.word	0x2065766f
 80024b4:	79706f63 	.word	0x79706f63
 80024b8:	68676972 	.word	0x68676972
 80024bc:	6f6e2074 	.word	0x6f6e2074
 80024c0:	65636974 	.word	0x65636974
 80024c4:	646e6120 	.word	0x646e6120
 80024c8:	69687420 	.word	0x69687420
 80024cc:	65702073 	.word	0x65702073
 80024d0:	73696d72 	.word	0x73696d72
 80024d4:	6e6f6973 	.word	0x6e6f6973
 80024d8:	746f6e20 	.word	0x746f6e20
 80024dc:	20656369 	.word	0x20656369
 80024e0:	6c616873 	.word	0x6c616873
 80024e4:	6562206c 	.word	0x6562206c
 80024e8:	636e6920 	.word	0x636e6920
 80024ec:	6564756c 	.word	0x6564756c
 80024f0:	6e692064 	.word	0x6e692064
 80024f4:	6c6c6120 	.word	0x6c6c6120
 80024f8:	6f630a0d 	.word	0x6f630a0d
 80024fc:	73656970 	.word	0x73656970
 8002500:	20726f20 	.word	0x20726f20
 8002504:	73627573 	.word	0x73627573
 8002508:	746e6174 	.word	0x746e6174
 800250c:	206c6169 	.word	0x206c6169
 8002510:	74726f70 	.word	0x74726f70
 8002514:	736e6f69 	.word	0x736e6f69
 8002518:	20666f20 	.word	0x20666f20
 800251c:	20656874 	.word	0x20656874
 8002520:	74666f53 	.word	0x74666f53
 8002524:	65726177 	.word	0x65726177
 8002528:	6649202e 	.word	0x6649202e
 800252c:	756f7920 	.word	0x756f7920
 8002530:	73697720 	.word	0x73697720
 8002534:	6f742068 	.word	0x6f742068
 8002538:	65737520 	.word	0x65737520
 800253c:	72756f20 	.word	0x72756f20
 8002540:	616d4120 	.word	0x616d4120
 8002544:	0d6e6f7a 	.word	0x0d6e6f7a
 8002548:	6572460a 	.word	0x6572460a
 800254c:	4f545265 	.word	0x4f545265
 8002550:	616e2053 	.word	0x616e2053
 8002554:	202c656d 	.word	0x202c656d
 8002558:	61656c70 	.word	0x61656c70
 800255c:	64206573 	.word	0x64206573
 8002560:	6f73206f 	.word	0x6f73206f
 8002564:	206e6920 	.word	0x206e6920
 8002568:	61662061 	.word	0x61662061
 800256c:	75207269 	.word	0x75207269
 8002570:	77206573 	.word	0x77206573
 8002574:	74207961 	.word	0x74207961
 8002578:	20746168 	.word	0x20746168
 800257c:	73656f64 	.word	0x73656f64
 8002580:	746f6e20 	.word	0x746f6e20
 8002584:	75616320 	.word	0x75616320
 8002588:	63206573 	.word	0x63206573
 800258c:	75666e6f 	.word	0x75666e6f
 8002590:	6e6f6973 	.word	0x6e6f6973
 8002594:	0d0a0d2e 	.word	0x0d0a0d2e
 8002598:	4548540a 	.word	0x4548540a
 800259c:	464f5320 	.word	0x464f5320
 80025a0:	52415754 	.word	0x52415754
 80025a4:	53492045 	.word	0x53492045
 80025a8:	4f525020 	.word	0x4f525020
 80025ac:	45444956 	.word	0x45444956
 80025b0:	41222044 	.word	0x41222044
 80025b4:	53492053 	.word	0x53492053
 80025b8:	57202c22 	.word	0x57202c22
 80025bc:	4f485449 	.word	0x4f485449
 80025c0:	57205455 	.word	0x57205455
 80025c4:	41525241 	.word	0x41525241
 80025c8:	2059544e 	.word	0x2059544e
 80025cc:	4120464f 	.word	0x4120464f
 80025d0:	4b20594e 	.word	0x4b20594e
 80025d4:	2c444e49 	.word	0x2c444e49
 80025d8:	50584520 	.word	0x50584520
 80025dc:	53534552 	.word	0x53534552
 80025e0:	0d524f20 	.word	0x0d524f20
 80025e4:	504d490a 	.word	0x504d490a
 80025e8:	4445494c 	.word	0x4445494c
 80025ec:	4e49202c 	.word	0x4e49202c
 80025f0:	44554c43 	.word	0x44554c43
 80025f4:	20474e49 	.word	0x20474e49
 80025f8:	20545542 	.word	0x20545542
 80025fc:	20544f4e 	.word	0x20544f4e
 8002600:	494d494c 	.word	0x494d494c
 8002604:	20444554 	.word	0x20444554
 8002608:	54204f54 	.word	0x54204f54
 800260c:	57204548 	.word	0x57204548
 8002610:	41525241 	.word	0x41525241
 8002614:	4549544e 	.word	0x4549544e
 8002618:	464f2053 	.word	0x464f2053
 800261c:	52454d20 	.word	0x52454d20
 8002620:	4e414843 	.word	0x4e414843
 8002624:	49424154 	.word	0x49424154
 8002628:	5954494c 	.word	0x5954494c
 800262c:	4946202c 	.word	0x4946202c
 8002630:	53454e54 	.word	0x53454e54
 8002634:	460a0d53 	.word	0x460a0d53
 8002638:	4120524f 	.word	0x4120524f
 800263c:	52415020 	.word	0x52415020
 8002640:	55434954 	.word	0x55434954
 8002644:	2052414c 	.word	0x2052414c
 8002648:	50525550 	.word	0x50525550
 800264c:	2045534f 	.word	0x2045534f
 8002650:	20444e41 	.word	0x20444e41
 8002654:	494e4f4e 	.word	0x494e4f4e
 8002658:	4952464e 	.word	0x4952464e
 800265c:	4d45474e 	.word	0x4d45474e
 8002660:	2e544e45 	.word	0x2e544e45
 8002664:	204e4920 	.word	0x204e4920
 8002668:	45204f4e 	.word	0x45204f4e
 800266c:	544e4556 	.word	0x544e4556
 8002670:	41485320 	.word	0x41485320
 8002674:	54204c4c 	.word	0x54204c4c
 8002678:	41204548 	.word	0x41204548
 800267c:	4f485455 	.word	0x4f485455
 8002680:	4f205352 	.word	0x4f205352
 8002684:	430a0d52 	.word	0x430a0d52
 8002688:	5259504f 	.word	0x5259504f
 800268c:	54484749 	.word	0x54484749
 8002690:	4c4f4820 	.word	0x4c4f4820
 8002694:	53524544 	.word	0x53524544
 8002698:	20454220 	.word	0x20454220
 800269c:	4241494c 	.word	0x4241494c
 80026a0:	4620454c 	.word	0x4620454c
 80026a4:	4120524f 	.word	0x4120524f
 80026a8:	4320594e 	.word	0x4320594e
 80026ac:	4d49414c 	.word	0x4d49414c
 80026b0:	4144202c 	.word	0x4144202c
 80026b4:	4547414d 	.word	0x4547414d
 80026b8:	524f2053 	.word	0x524f2053
 80026bc:	48544f20 	.word	0x48544f20
 80026c0:	4c205245 	.word	0x4c205245
 80026c4:	49424149 	.word	0x49424149
 80026c8:	5954494c 	.word	0x5954494c
 80026cc:	4857202c 	.word	0x4857202c
 80026d0:	45485445 	.word	0x45485445
 80026d4:	490a0d52 	.word	0x490a0d52
 80026d8:	4e41204e 	.word	0x4e41204e
 80026dc:	54434120 	.word	0x54434120
 80026e0:	204e4f49 	.word	0x204e4f49
 80026e4:	4320464f 	.word	0x4320464f
 80026e8:	52544e4f 	.word	0x52544e4f
 80026ec:	2c544341 	.word	0x2c544341
 80026f0:	524f5420 	.word	0x524f5420
 80026f4:	524f2054 	.word	0x524f2054
 80026f8:	48544f20 	.word	0x48544f20
 80026fc:	49575245 	.word	0x49575245
 8002700:	202c4553 	.word	0x202c4553
 8002704:	53495241 	.word	0x53495241
 8002708:	20474e49 	.word	0x20474e49
 800270c:	4d4f5246 	.word	0x4d4f5246
 8002710:	554f202c 	.word	0x554f202c
 8002714:	464f2054 	.word	0x464f2054
 8002718:	20524f20 	.word	0x20524f20
 800271c:	0a0d4e49 	.word	0x0a0d4e49
 8002720:	4e4e4f43 	.word	0x4e4e4f43
 8002724:	49544345 	.word	0x49544345
 8002728:	57204e4f 	.word	0x57204e4f
 800272c:	20485449 	.word	0x20485449
 8002730:	20454854 	.word	0x20454854
 8002734:	54464f53 	.word	0x54464f53
 8002738:	45524157 	.word	0x45524157
 800273c:	20524f20 	.word	0x20524f20
 8002740:	20454854 	.word	0x20454854
 8002744:	20455355 	.word	0x20455355
 8002748:	4f20524f 	.word	0x4f20524f
 800274c:	52454854 	.word	0x52454854
 8002750:	41454420 	.word	0x41454420
 8002754:	474e494c 	.word	0x474e494c
 8002758:	4e492053 	.word	0x4e492053
 800275c:	45485420 	.word	0x45485420
 8002760:	464f5320 	.word	0x464f5320
 8002764:	52415754 	.word	0x52415754
 8002768:	0a0d2e45 	.word	0x0a0d2e45
 800276c:	74680a0d 	.word	0x74680a0d
 8002770:	2f3a7074 	.word	0x2f3a7074
 8002774:	7777772f 	.word	0x7777772f
 8002778:	6572462e 	.word	0x6572462e
 800277c:	4f545265 	.word	0x4f545265
 8002780:	726f2e53 	.word	0x726f2e53
 8002784:	680a0d67 	.word	0x680a0d67
 8002788:	3a707474 	.word	0x3a707474
 800278c:	77612f2f 	.word	0x77612f2f
 8002790:	6d612e73 	.word	0x6d612e73
 8002794:	6e6f7a61 	.word	0x6e6f7a61
 8002798:	6d6f632e 	.word	0x6d6f632e
 800279c:	6572662f 	.word	0x6572662f
 80027a0:	6f747265 	.word	0x6f747265
 80027a4:	2a0a0d73 	.word	0x2a0a0d73
 80027a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027c8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027cc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027d8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027dc:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027e8:	2a2a2a2a 	.word	0x2a2a2a2a
 80027ec:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f0:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f4:	2a2a2a2a 	.word	0x2a2a2a2a
 80027f8:	430a0d2a 	.word	0x430a0d2a
 80027fc:	5259504f 	.word	0x5259504f
 8002800:	54484749 	.word	0x54484749
 8002804:	20296328 	.word	0x20296328
 8002808:	36313032 	.word	0x36313032
 800280c:	4d545320 	.word	0x4d545320
 8002810:	6f726369 	.word	0x6f726369
 8002814:	63656c65 	.word	0x63656c65
 8002818:	6e6f7274 	.word	0x6e6f7274
 800281c:	0d736369 	.word	0x0d736369
 8002820:	520a0d0a 	.word	0x520a0d0a
 8002824:	73696465 	.word	0x73696465
 8002828:	62697274 	.word	0x62697274
 800282c:	6f697475 	.word	0x6f697475
 8002830:	6e61206e 	.word	0x6e61206e
 8002834:	73752064 	.word	0x73752064
 8002838:	6e692065 	.word	0x6e692065
 800283c:	756f7320 	.word	0x756f7320
 8002840:	20656372 	.word	0x20656372
 8002844:	20646e61 	.word	0x20646e61
 8002848:	616e6962 	.word	0x616e6962
 800284c:	66207972 	.word	0x66207972
 8002850:	736d726f 	.word	0x736d726f
 8002854:	6977202c 	.word	0x6977202c
 8002858:	6f206874 	.word	0x6f206874
 800285c:	69772072 	.word	0x69772072
 8002860:	756f6874 	.word	0x756f6874
 8002864:	6f6d2074 	.word	0x6f6d2074
 8002868:	69666964 	.word	0x69666964
 800286c:	69746163 	.word	0x69746163
 8002870:	0d2c6e6f 	.word	0x0d2c6e6f
 8002874:	6572610a 	.word	0x6572610a
 8002878:	72657020 	.word	0x72657020
 800287c:	7474696d 	.word	0x7474696d
 8002880:	70206465 	.word	0x70206465
 8002884:	69766f72 	.word	0x69766f72
 8002888:	20646564 	.word	0x20646564
 800288c:	74616874 	.word	0x74616874
 8002890:	65687420 	.word	0x65687420
 8002894:	6c6f6620 	.word	0x6c6f6620
 8002898:	69776f6c 	.word	0x69776f6c
 800289c:	6320676e 	.word	0x6320676e
 80028a0:	69646e6f 	.word	0x69646e6f
 80028a4:	6e6f6974 	.word	0x6e6f6974
 80028a8:	72612073 	.word	0x72612073
 80028ac:	656d2065 	.word	0x656d2065
 80028b0:	0a0d3a74 	.word	0x0a0d3a74
 80028b4:	2e312020 	.word	0x2e312020
 80028b8:	64655220 	.word	0x64655220
 80028bc:	72747369 	.word	0x72747369
 80028c0:	74756269 	.word	0x74756269
 80028c4:	736e6f69 	.word	0x736e6f69
 80028c8:	20666f20 	.word	0x20666f20
 80028cc:	72756f73 	.word	0x72756f73
 80028d0:	63206563 	.word	0x63206563
 80028d4:	2065646f 	.word	0x2065646f
 80028d8:	7473756d 	.word	0x7473756d
 80028dc:	74657220 	.word	0x74657220
 80028e0:	206e6961 	.word	0x206e6961
 80028e4:	20656874 	.word	0x20656874
 80028e8:	766f6261 	.word	0x766f6261
 80028ec:	6f632065 	.word	0x6f632065
 80028f0:	69727970 	.word	0x69727970
 80028f4:	20746867 	.word	0x20746867
 80028f8:	69746f6e 	.word	0x69746f6e
 80028fc:	0d2c6563 	.word	0x0d2c6563
 8002900:	2020200a 	.word	0x2020200a
 8002904:	68742020 	.word	0x68742020
 8002908:	6c207369 	.word	0x6c207369
 800290c:	20747369 	.word	0x20747369
 8002910:	6320666f 	.word	0x6320666f
 8002914:	69646e6f 	.word	0x69646e6f
 8002918:	6e6f6974 	.word	0x6e6f6974
 800291c:	6e612073 	.word	0x6e612073
 8002920:	68742064 	.word	0x68742064
 8002924:	6f662065 	.word	0x6f662065
 8002928:	776f6c6c 	.word	0x776f6c6c
 800292c:	20676e69 	.word	0x20676e69
 8002930:	63736964 	.word	0x63736964
 8002934:	6d69616c 	.word	0x6d69616c
 8002938:	0d2e7265 	.word	0x0d2e7265
 800293c:	3220200a 	.word	0x3220200a
 8002940:	6552202e 	.word	0x6552202e
 8002944:	74736964 	.word	0x74736964
 8002948:	75626972 	.word	0x75626972
 800294c:	6e6f6974 	.word	0x6e6f6974
 8002950:	6e692073 	.word	0x6e692073
 8002954:	6e696220 	.word	0x6e696220
 8002958:	20797261 	.word	0x20797261
 800295c:	6d726f66 	.word	0x6d726f66
 8002960:	73756d20 	.word	0x73756d20
 8002964:	65722074 	.word	0x65722074
 8002968:	646f7270 	.word	0x646f7270
 800296c:	20656375 	.word	0x20656375
 8002970:	20656874 	.word	0x20656874
 8002974:	766f6261 	.word	0x766f6261
 8002978:	6f632065 	.word	0x6f632065
 800297c:	69727970 	.word	0x69727970
 8002980:	20746867 	.word	0x20746867
 8002984:	69746f6e 	.word	0x69746f6e
 8002988:	0d2c6563 	.word	0x0d2c6563
 800298c:	2020200a 	.word	0x2020200a
 8002990:	68742020 	.word	0x68742020
 8002994:	6c207369 	.word	0x6c207369
 8002998:	20747369 	.word	0x20747369
 800299c:	6320666f 	.word	0x6320666f
 80029a0:	69646e6f 	.word	0x69646e6f
 80029a4:	6e6f6974 	.word	0x6e6f6974
 80029a8:	6e612073 	.word	0x6e612073
 80029ac:	68742064 	.word	0x68742064
 80029b0:	6f662065 	.word	0x6f662065
 80029b4:	776f6c6c 	.word	0x776f6c6c
 80029b8:	20676e69 	.word	0x20676e69
 80029bc:	63736964 	.word	0x63736964
 80029c0:	6d69616c 	.word	0x6d69616c
 80029c4:	69207265 	.word	0x69207265
 80029c8:	6874206e 	.word	0x6874206e
 80029cc:	6f642065 	.word	0x6f642065
 80029d0:	656d7563 	.word	0x656d7563
 80029d4:	7461746e 	.word	0x7461746e
 80029d8:	0d6e6f69 	.word	0x0d6e6f69
 80029dc:	2020200a 	.word	0x2020200a
 80029e0:	6e612020 	.word	0x6e612020
 80029e4:	726f2f64 	.word	0x726f2f64
 80029e8:	68746f20 	.word	0x68746f20
 80029ec:	6d207265 	.word	0x6d207265
 80029f0:	72657461 	.word	0x72657461
 80029f4:	736c6169 	.word	0x736c6169
 80029f8:	6f727020 	.word	0x6f727020
 80029fc:	65646976 	.word	0x65646976
 8002a00:	69772064 	.word	0x69772064
 8002a04:	74206874 	.word	0x74206874
 8002a08:	64206568 	.word	0x64206568
 8002a0c:	72747369 	.word	0x72747369
 8002a10:	74756269 	.word	0x74756269
 8002a14:	2e6e6f69 	.word	0x2e6e6f69
 8002a18:	20200a0d 	.word	0x20200a0d
 8002a1c:	4e202e33 	.word	0x4e202e33
 8002a20:	68746965 	.word	0x68746965
 8002a24:	74207265 	.word	0x74207265
 8002a28:	6e206568 	.word	0x6e206568
 8002a2c:	20656d61 	.word	0x20656d61
 8002a30:	5320666f 	.word	0x5320666f
 8002a34:	63694d54 	.word	0x63694d54
 8002a38:	6c656f72 	.word	0x6c656f72
 8002a3c:	72746365 	.word	0x72746365
 8002a40:	63696e6f 	.word	0x63696e6f
 8002a44:	6f6e2073 	.word	0x6f6e2073
 8002a48:	68742072 	.word	0x68742072
 8002a4c:	616e2065 	.word	0x616e2065
 8002a50:	2073656d 	.word	0x2073656d
 8002a54:	6920666f 	.word	0x6920666f
 8002a58:	63207374 	.word	0x63207374
 8002a5c:	72746e6f 	.word	0x72746e6f
 8002a60:	74756269 	.word	0x74756269
 8002a64:	0d73726f 	.word	0x0d73726f
 8002a68:	2020200a 	.word	0x2020200a
 8002a6c:	616d2020 	.word	0x616d2020
 8002a70:	65622079 	.word	0x65622079
 8002a74:	65737520 	.word	0x65737520
 8002a78:	6f742064 	.word	0x6f742064
 8002a7c:	646e6520 	.word	0x646e6520
 8002a80:	6573726f 	.word	0x6573726f
 8002a84:	20726f20 	.word	0x20726f20
 8002a88:	6d6f7270 	.word	0x6d6f7270
 8002a8c:	2065746f 	.word	0x2065746f
 8002a90:	646f7270 	.word	0x646f7270
 8002a94:	73746375 	.word	0x73746375
 8002a98:	72656420 	.word	0x72656420
 8002a9c:	64657669 	.word	0x64657669
 8002aa0:	6f726620 	.word	0x6f726620
 8002aa4:	6874206d 	.word	0x6874206d
 8002aa8:	73207369 	.word	0x73207369
 8002aac:	7774666f 	.word	0x7774666f
 8002ab0:	0d657261 	.word	0x0d657261
 8002ab4:	2020200a 	.word	0x2020200a
 8002ab8:	69772020 	.word	0x69772020
 8002abc:	756f6874 	.word	0x756f6874
 8002ac0:	70732074 	.word	0x70732074
 8002ac4:	66696365 	.word	0x66696365
 8002ac8:	70206369 	.word	0x70206369
 8002acc:	726f6972 	.word	0x726f6972
 8002ad0:	69727720 	.word	0x69727720
 8002ad4:	6e657474 	.word	0x6e657474
 8002ad8:	72657020 	.word	0x72657020
 8002adc:	7373696d 	.word	0x7373696d
 8002ae0:	2e6e6f69 	.word	0x2e6e6f69
 8002ae4:	20200a0d 	.word	0x20200a0d
 8002ae8:	48540a0d 	.word	0x48540a0d
 8002aec:	53205349 	.word	0x53205349
 8002af0:	5754464f 	.word	0x5754464f
 8002af4:	20455241 	.word	0x20455241
 8002af8:	50205349 	.word	0x50205349
 8002afc:	49564f52 	.word	0x49564f52
 8002b00:	20444544 	.word	0x20444544
 8002b04:	54205942 	.word	0x54205942
 8002b08:	43204548 	.word	0x43204548
 8002b0c:	5259504f 	.word	0x5259504f
 8002b10:	54484749 	.word	0x54484749
 8002b14:	4c4f4820 	.word	0x4c4f4820
 8002b18:	53524544 	.word	0x53524544
 8002b1c:	444e4120 	.word	0x444e4120
 8002b20:	4e4f4320 	.word	0x4e4f4320
 8002b24:	42495254 	.word	0x42495254
 8002b28:	524f5455 	.word	0x524f5455
 8002b2c:	41222053 	.word	0x41222053
 8002b30:	53492053 	.word	0x53492053
 8002b34:	410a0d22 	.word	0x410a0d22
 8002b38:	4120444e 	.word	0x4120444e
 8002b3c:	4520594e 	.word	0x4520594e
 8002b40:	45525058 	.word	0x45525058
 8002b44:	4f205353 	.word	0x4f205353
 8002b48:	4d492052 	.word	0x4d492052
 8002b4c:	45494c50 	.word	0x45494c50
 8002b50:	41572044 	.word	0x41572044
 8002b54:	4e415252 	.word	0x4e415252
 8002b58:	53454954 	.word	0x53454954
 8002b5c:	4e49202c 	.word	0x4e49202c
 8002b60:	44554c43 	.word	0x44554c43
 8002b64:	2c474e49 	.word	0x2c474e49
 8002b68:	54554220 	.word	0x54554220
 8002b6c:	544f4e20 	.word	0x544f4e20
 8002b70:	4d494c20 	.word	0x4d494c20
 8002b74:	44455449 	.word	0x44455449
 8002b78:	2c4f5420 	.word	0x2c4f5420
 8002b7c:	45485420 	.word	0x45485420
 8002b80:	4d490a0d 	.word	0x4d490a0d
 8002b84:	45494c50 	.word	0x45494c50
 8002b88:	41572044 	.word	0x41572044
 8002b8c:	4e415252 	.word	0x4e415252
 8002b90:	53454954 	.word	0x53454954
 8002b94:	20464f20 	.word	0x20464f20
 8002b98:	4352454d 	.word	0x4352454d
 8002b9c:	544e4148 	.word	0x544e4148
 8002ba0:	4c494241 	.word	0x4c494241
 8002ba4:	20595449 	.word	0x20595449
 8002ba8:	20444e41 	.word	0x20444e41
 8002bac:	4e544946 	.word	0x4e544946
 8002bb0:	20535345 	.word	0x20535345
 8002bb4:	20524f46 	.word	0x20524f46
 8002bb8:	41502041 	.word	0x41502041
 8002bbc:	43495452 	.word	0x43495452
 8002bc0:	52414c55 	.word	0x52414c55
 8002bc4:	52555020 	.word	0x52555020
 8002bc8:	45534f50 	.word	0x45534f50
 8002bcc:	45524120 	.word	0x45524120
 8002bd0:	49440a0d 	.word	0x49440a0d
 8002bd4:	414c4353 	.word	0x414c4353
 8002bd8:	44454d49 	.word	0x44454d49
 8002bdc:	4e49202e 	.word	0x4e49202e
 8002be0:	204f4e20 	.word	0x204f4e20
 8002be4:	4e455645 	.word	0x4e455645
 8002be8:	48532054 	.word	0x48532054
 8002bec:	204c4c41 	.word	0x204c4c41
 8002bf0:	20454854 	.word	0x20454854
 8002bf4:	59504f43 	.word	0x59504f43
 8002bf8:	48474952 	.word	0x48474952
 8002bfc:	4f482054 	.word	0x4f482054
 8002c00:	5245444c 	.word	0x5245444c
 8002c04:	20524f20 	.word	0x20524f20
 8002c08:	544e4f43 	.word	0x544e4f43
 8002c0c:	55424952 	.word	0x55424952
 8002c10:	53524f54 	.word	0x53524f54
 8002c14:	20454220 	.word	0x20454220
 8002c18:	4241494c 	.word	0x4241494c
 8002c1c:	0a0d454c 	.word	0x0a0d454c
 8002c20:	20524f46 	.word	0x20524f46
 8002c24:	20594e41 	.word	0x20594e41
 8002c28:	45524944 	.word	0x45524944
 8002c2c:	202c5443 	.word	0x202c5443
 8002c30:	49444e49 	.word	0x49444e49
 8002c34:	54434552 	.word	0x54434552
 8002c38:	4e49202c 	.word	0x4e49202c
 8002c3c:	45444943 	.word	0x45444943
 8002c40:	4c41544e 	.word	0x4c41544e
 8002c44:	5053202c 	.word	0x5053202c
 8002c48:	41494345 	.word	0x41494345
 8002c4c:	45202c4c 	.word	0x45202c4c
 8002c50:	504d4558 	.word	0x504d4558
 8002c54:	5952414c 	.word	0x5952414c
 8002c58:	524f202c 	.word	0x524f202c
 8002c5c:	4e4f4320 	.word	0x4e4f4320
 8002c60:	55514553 	.word	0x55514553
 8002c64:	49544e45 	.word	0x49544e45
 8002c68:	0a0d4c41 	.word	0x0a0d4c41
 8002c6c:	414d4144 	.word	0x414d4144
 8002c70:	20534547 	.word	0x20534547
 8002c74:	434e4928 	.word	0x434e4928
 8002c78:	4944554c 	.word	0x4944554c
 8002c7c:	202c474e 	.word	0x202c474e
 8002c80:	20545542 	.word	0x20545542
 8002c84:	20544f4e 	.word	0x20544f4e
 8002c88:	494d494c 	.word	0x494d494c
 8002c8c:	20444554 	.word	0x20444554
 8002c90:	202c4f54 	.word	0x202c4f54
 8002c94:	434f5250 	.word	0x434f5250
 8002c98:	4d455255 	.word	0x4d455255
 8002c9c:	20544e45 	.word	0x20544e45
 8002ca0:	5320464f 	.word	0x5320464f
 8002ca4:	54534255 	.word	0x54534255
 8002ca8:	54555449 	.word	0x54555449
 8002cac:	4f472045 	.word	0x4f472045
 8002cb0:	2053444f 	.word	0x2053444f
 8002cb4:	0a0d524f 	.word	0x0a0d524f
 8002cb8:	56524553 	.word	0x56524553
 8002cbc:	53454349 	.word	0x53454349
 8002cc0:	4f4c203b 	.word	0x4f4c203b
 8002cc4:	4f205353 	.word	0x4f205353
 8002cc8:	53552046 	.word	0x53552046
 8002ccc:	44202c45 	.word	0x44202c45
 8002cd0:	2c415441 	.word	0x2c415441
 8002cd4:	20524f20 	.word	0x20524f20
 8002cd8:	464f5250 	.word	0x464f5250
 8002cdc:	3b535449 	.word	0x3b535449
 8002ce0:	20524f20 	.word	0x20524f20
 8002ce4:	49535542 	.word	0x49535542
 8002ce8:	5353454e 	.word	0x5353454e
 8002cec:	544e4920 	.word	0x544e4920
 8002cf0:	55525245 	.word	0x55525245
 8002cf4:	4f495450 	.word	0x4f495450
 8002cf8:	4820294e 	.word	0x4820294e
 8002cfc:	5645574f 	.word	0x5645574f
 8002d00:	0a0d5245 	.word	0x0a0d5245
 8002d04:	53554143 	.word	0x53554143
 8002d08:	41204445 	.word	0x41204445
 8002d0c:	4f20444e 	.word	0x4f20444e
 8002d10:	4e41204e 	.word	0x4e41204e
 8002d14:	48542059 	.word	0x48542059
 8002d18:	59524f45 	.word	0x59524f45
 8002d1c:	20464f20 	.word	0x20464f20
 8002d20:	4241494c 	.word	0x4241494c
 8002d24:	54494c49 	.word	0x54494c49
 8002d28:	57202c59 	.word	0x57202c59
 8002d2c:	48544548 	.word	0x48544548
 8002d30:	49205245 	.word	0x49205245
 8002d34:	4f43204e 	.word	0x4f43204e
 8002d38:	4152544e 	.word	0x4152544e
 8002d3c:	202c5443 	.word	0x202c5443
 8002d40:	49525453 	.word	0x49525453
 8002d44:	4c205443 	.word	0x4c205443
 8002d48:	49424149 	.word	0x49424149
 8002d4c:	5954494c 	.word	0x5954494c
 8002d50:	4f0a0d2c 	.word	0x4f0a0d2c
 8002d54:	4f542052 	.word	0x4f542052
 8002d58:	28205452 	.word	0x28205452
 8002d5c:	4c434e49 	.word	0x4c434e49
 8002d60:	4e494455 	.word	0x4e494455
 8002d64:	454e2047 	.word	0x454e2047
 8002d68:	47494c47 	.word	0x47494c47
 8002d6c:	45434e45 	.word	0x45434e45
 8002d70:	20524f20 	.word	0x20524f20
 8002d74:	4548544f 	.word	0x4548544f
 8002d78:	53495752 	.word	0x53495752
 8002d7c:	41202945 	.word	0x41202945
 8002d80:	49534952 	.word	0x49534952
 8002d84:	4920474e 	.word	0x4920474e
 8002d88:	4e41204e 	.word	0x4e41204e
 8002d8c:	41572059 	.word	0x41572059
 8002d90:	554f2059 	.word	0x554f2059
 8002d94:	464f2054 	.word	0x464f2054
 8002d98:	45485420 	.word	0x45485420
 8002d9c:	45535520 	.word	0x45535520
 8002da0:	464f0a0d 	.word	0x464f0a0d
 8002da4:	49485420 	.word	0x49485420
 8002da8:	4f532053 	.word	0x4f532053
 8002dac:	41575446 	.word	0x41575446
 8002db0:	202c4552 	.word	0x202c4552
 8002db4:	4e455645 	.word	0x4e455645
 8002db8:	20464920 	.word	0x20464920
 8002dbc:	49564441 	.word	0x49564441
 8002dc0:	20444553 	.word	0x20444553
 8002dc4:	5420464f 	.word	0x5420464f
 8002dc8:	50204548 	.word	0x50204548
 8002dcc:	4953534f 	.word	0x4953534f
 8002dd0:	494c4942 	.word	0x494c4942
 8002dd4:	4f205954 	.word	0x4f205954
 8002dd8:	55532046 	.word	0x55532046
 8002ddc:	44204843 	.word	0x44204843
 8002de0:	47414d41 	.word	0x47414d41
 8002de4:	0a0d2e45 	.word	0x0a0d2e45
 8002de8:	2a2a2a2a 	.word	0x2a2a2a2a
 8002dec:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df0:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df4:	2a2a2a2a 	.word	0x2a2a2a2a
 8002df8:	2a2a2a2a 	.word	0x2a2a2a2a
 8002dfc:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e00:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e04:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e08:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e0c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e10:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e14:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e18:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e1c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e20:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e24:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e28:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e2c:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e30:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e34:	2a2a2a2a 	.word	0x2a2a2a2a
 8002e38:	0a0d2a2a 	.word	0x0a0d2a2a
 8002e3c:	62696843 	.word	0x62696843
 8002e40:	20534f69 	.word	0x20534f69
 8002e44:	6f43202d 	.word	0x6f43202d
 8002e48:	69727970 	.word	0x69727970
 8002e4c:	20746867 	.word	0x20746867
 8002e50:	20294328 	.word	0x20294328
 8002e54:	36303032 	.word	0x36303032
 8002e58:	30322e2e 	.word	0x30322e2e
 8002e5c:	47203631 	.word	0x47203631
 8002e60:	61766f69 	.word	0x61766f69
 8002e64:	20696e6e 	.word	0x20696e6e
 8002e68:	53206944 	.word	0x53206944
 8002e6c:	6f697269 	.word	0x6f697269
 8002e70:	0a0d0a0d 	.word	0x0a0d0a0d
 8002e74:	6563694c 	.word	0x6563694c
 8002e78:	6465736e 	.word	0x6465736e
 8002e7c:	646e7520 	.word	0x646e7520
 8002e80:	74207265 	.word	0x74207265
 8002e84:	41206568 	.word	0x41206568
 8002e88:	68636170 	.word	0x68636170
 8002e8c:	694c2065 	.word	0x694c2065
 8002e90:	736e6563 	.word	0x736e6563
 8002e94:	56202c65 	.word	0x56202c65
 8002e98:	69737265 	.word	0x69737265
 8002e9c:	32206e6f 	.word	0x32206e6f
 8002ea0:	2820302e 	.word	0x2820302e
 8002ea4:	20656874 	.word	0x20656874
 8002ea8:	63694c22 	.word	0x63694c22
 8002eac:	65736e65 	.word	0x65736e65
 8002eb0:	0d3b2922 	.word	0x0d3b2922
 8002eb4:	756f790a 	.word	0x756f790a
 8002eb8:	79616d20 	.word	0x79616d20
 8002ebc:	746f6e20 	.word	0x746f6e20
 8002ec0:	65737520 	.word	0x65737520
 8002ec4:	69687420 	.word	0x69687420
 8002ec8:	69662073 	.word	0x69662073
 8002ecc:	6520656c 	.word	0x6520656c
 8002ed0:	70656378 	.word	0x70656378
 8002ed4:	6e692074 	.word	0x6e692074
 8002ed8:	6d6f6320 	.word	0x6d6f6320
 8002edc:	61696c70 	.word	0x61696c70
 8002ee0:	2065636e 	.word	0x2065636e
 8002ee4:	68746977 	.word	0x68746977
 8002ee8:	65687420 	.word	0x65687420
 8002eec:	63694c20 	.word	0x63694c20
 8002ef0:	65736e65 	.word	0x65736e65
 8002ef4:	590a0d2e 	.word	0x590a0d2e
 8002ef8:	6d20756f 	.word	0x6d20756f
 8002efc:	6f207961 	.word	0x6f207961
 8002f00:	69617462 	.word	0x69617462
 8002f04:	2061206e 	.word	0x2061206e
 8002f08:	79706f63 	.word	0x79706f63
 8002f0c:	20666f20 	.word	0x20666f20
 8002f10:	20656874 	.word	0x20656874
 8002f14:	6563694c 	.word	0x6563694c
 8002f18:	2065736e 	.word	0x2065736e
 8002f1c:	0a0d7461 	.word	0x0a0d7461
 8002f20:	20200a0d 	.word	0x20200a0d
 8002f24:	74682020 	.word	0x74682020
 8002f28:	2f3a7074 	.word	0x2f3a7074
 8002f2c:	7777772f 	.word	0x7777772f
 8002f30:	6170612e 	.word	0x6170612e
 8002f34:	2e656863 	.word	0x2e656863
 8002f38:	2f67726f 	.word	0x2f67726f
 8002f3c:	6563696c 	.word	0x6563696c
 8002f40:	7365736e 	.word	0x7365736e
 8002f44:	43494c2f 	.word	0x43494c2f
 8002f48:	45534e45 	.word	0x45534e45
 8002f4c:	302e322d 	.word	0x302e322d
 8002f50:	0a0d0a0d 	.word	0x0a0d0a0d
 8002f54:	656c6e55 	.word	0x656c6e55
 8002f58:	72207373 	.word	0x72207373
 8002f5c:	69757165 	.word	0x69757165
 8002f60:	20646572 	.word	0x20646572
 8002f64:	61207962 	.word	0x61207962
 8002f68:	696c7070 	.word	0x696c7070
 8002f6c:	6c626163 	.word	0x6c626163
 8002f70:	616c2065 	.word	0x616c2065
 8002f74:	726f2077 	.word	0x726f2077
 8002f78:	72676120 	.word	0x72676120
 8002f7c:	20646565 	.word	0x20646565
 8002f80:	69206f74 	.word	0x69206f74
 8002f84:	7277206e 	.word	0x7277206e
 8002f88:	6e697469 	.word	0x6e697469
 8002f8c:	73202c67 	.word	0x73202c67
 8002f90:	7774666f 	.word	0x7774666f
 8002f94:	0d657261 	.word	0x0d657261
 8002f98:	7369640a 	.word	0x7369640a
 8002f9c:	62697274 	.word	0x62697274
 8002fa0:	64657475 	.word	0x64657475
 8002fa4:	646e7520 	.word	0x646e7520
 8002fa8:	74207265 	.word	0x74207265
 8002fac:	4c206568 	.word	0x4c206568
 8002fb0:	6e656369 	.word	0x6e656369
 8002fb4:	69206573 	.word	0x69206573
 8002fb8:	69642073 	.word	0x69642073
 8002fbc:	69727473 	.word	0x69727473
 8002fc0:	65747562 	.word	0x65747562
 8002fc4:	6e6f2064 	.word	0x6e6f2064
 8002fc8:	206e6120 	.word	0x206e6120
 8002fcc:	20534122 	.word	0x20534122
 8002fd0:	20225349 	.word	0x20225349
 8002fd4:	49534142 	.word	0x49534142
 8002fd8:	0a0d2c53 	.word	0x0a0d2c53
 8002fdc:	48544957 	.word	0x48544957
 8002fe0:	2054554f 	.word	0x2054554f
 8002fe4:	52524157 	.word	0x52524157
 8002fe8:	49544e41 	.word	0x49544e41
 8002fec:	4f205345 	.word	0x4f205345
 8002ff0:	4f432052 	.word	0x4f432052
 8002ff4:	5449444e 	.word	0x5449444e
 8002ff8:	534e4f49 	.word	0x534e4f49
 8002ffc:	20464f20 	.word	0x20464f20
 8003000:	20594e41 	.word	0x20594e41
 8003004:	444e494b 	.word	0x444e494b
 8003008:	6965202c 	.word	0x6965202c
 800300c:	72656874 	.word	0x72656874
 8003010:	70786520 	.word	0x70786520
 8003014:	73736572 	.word	0x73736572
 8003018:	20726f20 	.word	0x20726f20
 800301c:	6c706d69 	.word	0x6c706d69
 8003020:	2e646569 	.word	0x2e646569
 8003024:	65530a0d 	.word	0x65530a0d
 8003028:	68742065 	.word	0x68742065
 800302c:	694c2065 	.word	0x694c2065
 8003030:	736e6563 	.word	0x736e6563
 8003034:	6f662065 	.word	0x6f662065
 8003038:	68742072 	.word	0x68742072
 800303c:	70732065 	.word	0x70732065
 8003040:	66696365 	.word	0x66696365
 8003044:	6c206369 	.word	0x6c206369
 8003048:	75676e61 	.word	0x75676e61
 800304c:	20656761 	.word	0x20656761
 8003050:	65766f67 	.word	0x65766f67
 8003054:	6e696e72 	.word	0x6e696e72
 8003058:	65702067 	.word	0x65702067
 800305c:	73696d72 	.word	0x73696d72
 8003060:	6e6f6973 	.word	0x6e6f6973
 8003064:	6e612073 	.word	0x6e612073
 8003068:	6c0a0d64 	.word	0x6c0a0d64
 800306c:	74696d69 	.word	0x74696d69
 8003070:	6f697461 	.word	0x6f697461
 8003074:	7520736e 	.word	0x7520736e
 8003078:	7265646e 	.word	0x7265646e
 800307c:	65687420 	.word	0x65687420
 8003080:	63694c20 	.word	0x63694c20
 8003084:	65736e65 	.word	0x65736e65
 8003088:	2a0a0d2e 	.word	0x2a0a0d2e
 800308c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003090:	2a2a2a2a 	.word	0x2a2a2a2a
 8003094:	2a2a2a2a 	.word	0x2a2a2a2a
 8003098:	2a2a2a2a 	.word	0x2a2a2a2a
 800309c:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030c8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030cc:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d0:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d4:	2a2a2a2a 	.word	0x2a2a2a2a
 80030d8:	2a2a2a2a 	.word	0x2a2a2a2a
 80030dc:	430a0d2a 	.word	0x430a0d2a
 80030e0:	7279706f 	.word	0x7279706f
 80030e4:	74686769 	.word	0x74686769
 80030e8:	29632820 	.word	0x29632820
 80030ec:	31303220 	.word	0x31303220
 80030f0:	30322d37 	.word	0x30322d37
 80030f4:	202c3831 	.word	0x202c3831
 80030f8:	74726542 	.word	0x74726542
 80030fc:	20646c6f 	.word	0x20646c6f
 8003100:	206e6156 	.word	0x206e6156
 8003104:	206e6564 	.word	0x206e6564
 8003108:	67726542 	.word	0x67726542
 800310c:	76282068 	.word	0x76282068
 8003110:	65646e61 	.word	0x65646e61
 8003114:	7265626e 	.word	0x7265626e
 8003118:	62406867 	.word	0x62406867
 800311c:	6f747265 	.word	0x6f747265
 8003120:	6f2e646c 	.word	0x6f2e646c
 8003124:	0d296772 	.word	0x0d296772
 8003128:	6c6c410a 	.word	0x6c6c410a
 800312c:	67697220 	.word	0x67697220
 8003130:	20737468 	.word	0x20737468
 8003134:	65736572 	.word	0x65736572
 8003138:	64657672 	.word	0x64657672
 800313c:	540a0d2e 	.word	0x540a0d2e
 8003140:	20736968 	.word	0x20736968
 8003144:	6b726f77 	.word	0x6b726f77
 8003148:	73616820 	.word	0x73616820
 800314c:	65656220 	.word	0x65656220
 8003150:	6564206e 	.word	0x6564206e
 8003154:	6f6c6576 	.word	0x6f6c6576
 8003158:	20646570 	.word	0x20646570
 800315c:	73206f74 	.word	0x73206f74
 8003160:	6f707075 	.word	0x6f707075
 8003164:	72207472 	.word	0x72207472
 8003168:	61657365 	.word	0x61657365
 800316c:	20686372 	.word	0x20686372
 8003170:	646e7566 	.word	0x646e7566
 8003174:	62206465 	.word	0x62206465
 8003178:	220a0d79 	.word	0x220a0d79
 800317c:	646e7546 	.word	0x646e7546
 8003180:	726f6620 	.word	0x726f6620
 8003184:	69635320 	.word	0x69635320
 8003188:	69746e65 	.word	0x69746e65
 800318c:	20636966 	.word	0x20636966
 8003190:	65736552 	.word	0x65736552
 8003194:	68637261 	.word	0x68637261
 8003198:	6c46202c 	.word	0x6c46202c
 800319c:	65646e61 	.word	0x65646e61
 80031a0:	20227372 	.word	0x20227372
 80031a4:	572e4628 	.word	0x572e4628
 80031a8:	2d2e4f2e 	.word	0x2d2e4f2e
 80031ac:	61616c56 	.word	0x61616c56
 80031b0:	7265646e 	.word	0x7265646e
 80031b4:	2e296e65 	.word	0x2e296e65
 80031b8:	0a0d0a0d 	.word	0x0a0d0a0d
 80031bc:	69646552 	.word	0x69646552
 80031c0:	69727473 	.word	0x69727473
 80031c4:	69747562 	.word	0x69747562
 80031c8:	61206e6f 	.word	0x61206e6f
 80031cc:	7520646e 	.word	0x7520646e
 80031d0:	69206573 	.word	0x69206573
 80031d4:	6f73206e 	.word	0x6f73206e
 80031d8:	65637275 	.word	0x65637275
 80031dc:	646e6120 	.word	0x646e6120
 80031e0:	6e696220 	.word	0x6e696220
 80031e4:	20797261 	.word	0x20797261
 80031e8:	6d726f66 	.word	0x6d726f66
 80031ec:	77202c73 	.word	0x77202c73
 80031f0:	20687469 	.word	0x20687469
 80031f4:	7720726f 	.word	0x7720726f
 80031f8:	6f687469 	.word	0x6f687469
 80031fc:	0a0d7475 	.word	0x0a0d7475
 8003200:	69646f6d 	.word	0x69646f6d
 8003204:	61636966 	.word	0x61636966
 8003208:	6e6f6974 	.word	0x6e6f6974
 800320c:	7261202c 	.word	0x7261202c
 8003210:	65702065 	.word	0x65702065
 8003214:	74696d72 	.word	0x74696d72
 8003218:	20646574 	.word	0x20646574
 800321c:	766f7270 	.word	0x766f7270
 8003220:	64656469 	.word	0x64656469
 8003224:	61687420 	.word	0x61687420
 8003228:	68742074 	.word	0x68742074
 800322c:	6f662065 	.word	0x6f662065
 8003230:	776f6c6c 	.word	0x776f6c6c
 8003234:	20676e69 	.word	0x20676e69
 8003238:	646e6f63 	.word	0x646e6f63
 800323c:	6f697469 	.word	0x6f697469
 8003240:	6120736e 	.word	0x6120736e
 8003244:	6d206572 	.word	0x6d206572
 8003248:	0d3a7465 	.word	0x0d3a7465
 800324c:	2020200a 	.word	0x2020200a
 8003250:	52202a20 	.word	0x52202a20
 8003254:	73696465 	.word	0x73696465
 8003258:	62697274 	.word	0x62697274
 800325c:	6f697475 	.word	0x6f697475
 8003260:	6f20736e 	.word	0x6f20736e
 8003264:	6f732066 	.word	0x6f732066
 8003268:	65637275 	.word	0x65637275
 800326c:	646f6320 	.word	0x646f6320
 8003270:	756d2065 	.word	0x756d2065
 8003274:	72207473 	.word	0x72207473
 8003278:	69617465 	.word	0x69617465
 800327c:	6874206e 	.word	0x6874206e
 8003280:	62612065 	.word	0x62612065
 8003284:	2065766f 	.word	0x2065766f
 8003288:	79706f63 	.word	0x79706f63
 800328c:	68676972 	.word	0x68676972
 8003290:	200a0d74 	.word	0x200a0d74
 8003294:	20202020 	.word	0x20202020
 8003298:	746f6e20 	.word	0x746f6e20
 800329c:	2c656369 	.word	0x2c656369
 80032a0:	69687420 	.word	0x69687420
 80032a4:	696c2073 	.word	0x696c2073
 80032a8:	6f207473 	.word	0x6f207473
 80032ac:	6f632066 	.word	0x6f632066
 80032b0:	7469646e 	.word	0x7469646e
 80032b4:	736e6f69 	.word	0x736e6f69
 80032b8:	646e6120 	.word	0x646e6120
 80032bc:	65687420 	.word	0x65687420
 80032c0:	6c6f6620 	.word	0x6c6f6620
 80032c4:	69776f6c 	.word	0x69776f6c
 80032c8:	6420676e 	.word	0x6420676e
 80032cc:	6c637369 	.word	0x6c637369
 80032d0:	656d6961 	.word	0x656d6961
 80032d4:	0a0d2e72 	.word	0x0a0d2e72
 80032d8:	20202020 	.word	0x20202020
 80032dc:	6552202a 	.word	0x6552202a
 80032e0:	74736964 	.word	0x74736964
 80032e4:	75626972 	.word	0x75626972
 80032e8:	6e6f6974 	.word	0x6e6f6974
 80032ec:	6e692073 	.word	0x6e692073
 80032f0:	6e696220 	.word	0x6e696220
 80032f4:	20797261 	.word	0x20797261
 80032f8:	6d726f66 	.word	0x6d726f66
 80032fc:	73756d20 	.word	0x73756d20
 8003300:	65722074 	.word	0x65722074
 8003304:	646f7270 	.word	0x646f7270
 8003308:	20656375 	.word	0x20656375
 800330c:	20656874 	.word	0x20656874
 8003310:	766f6261 	.word	0x766f6261
 8003314:	6f632065 	.word	0x6f632065
 8003318:	69727970 	.word	0x69727970
 800331c:	0d746867 	.word	0x0d746867
 8003320:	2020200a 	.word	0x2020200a
 8003324:	6e202020 	.word	0x6e202020
 8003328:	6369746f 	.word	0x6369746f
 800332c:	74202c65 	.word	0x74202c65
 8003330:	20736968 	.word	0x20736968
 8003334:	7473696c 	.word	0x7473696c
 8003338:	20666f20 	.word	0x20666f20
 800333c:	646e6f63 	.word	0x646e6f63
 8003340:	6f697469 	.word	0x6f697469
 8003344:	6120736e 	.word	0x6120736e
 8003348:	7420646e 	.word	0x7420646e
 800334c:	66206568 	.word	0x66206568
 8003350:	6f6c6c6f 	.word	0x6f6c6c6f
 8003354:	676e6977 	.word	0x676e6977
 8003358:	73696420 	.word	0x73696420
 800335c:	69616c63 	.word	0x69616c63
 8003360:	2072656d 	.word	0x2072656d
 8003364:	74206e69 	.word	0x74206e69
 8003368:	0a0d6568 	.word	0x0a0d6568
 800336c:	20202020 	.word	0x20202020
 8003370:	6f642020 	.word	0x6f642020
 8003374:	656d7563 	.word	0x656d7563
 8003378:	7461746e 	.word	0x7461746e
 800337c:	206e6f69 	.word	0x206e6f69
 8003380:	2f646e61 	.word	0x2f646e61
 8003384:	6f20726f 	.word	0x6f20726f
 8003388:	72656874 	.word	0x72656874
 800338c:	74616d20 	.word	0x74616d20
 8003390:	61697265 	.word	0x61697265
 8003394:	7020736c 	.word	0x7020736c
 8003398:	69766f72 	.word	0x69766f72
 800339c:	20646564 	.word	0x20646564
 80033a0:	68746977 	.word	0x68746977
 80033a4:	65687420 	.word	0x65687420
 80033a8:	73696420 	.word	0x73696420
 80033ac:	62697274 	.word	0x62697274
 80033b0:	6f697475 	.word	0x6f697475
 80033b4:	0a0d2e6e 	.word	0x0a0d2e6e
 80033b8:	20202020 	.word	0x20202020
 80033bc:	654e202a 	.word	0x654e202a
 80033c0:	65687469 	.word	0x65687469
 80033c4:	68742072 	.word	0x68742072
 80033c8:	616e2065 	.word	0x616e2065
 80033cc:	6f20656d 	.word	0x6f20656d
 80033d0:	68742066 	.word	0x68742066
 80033d4:	75612065 	.word	0x75612065
 80033d8:	726f6874 	.word	0x726f6874
 80033dc:	726f6e20 	.word	0x726f6e20
 80033e0:	65687420 	.word	0x65687420
 80033e4:	20200a0d 	.word	0x20200a0d
 80033e8:	20202020 	.word	0x20202020
 80033ec:	656d616e 	.word	0x656d616e
 80033f0:	666f2073 	.word	0x666f2073
 80033f4:	73746920 	.word	0x73746920
 80033f8:	6e6f6320 	.word	0x6e6f6320
 80033fc:	62697274 	.word	0x62697274
 8003400:	726f7475 	.word	0x726f7475
 8003404:	616d2073 	.word	0x616d2073
 8003408:	65622079 	.word	0x65622079
 800340c:	65737520 	.word	0x65737520
 8003410:	6f742064 	.word	0x6f742064
 8003414:	646e6520 	.word	0x646e6520
 8003418:	6573726f 	.word	0x6573726f
 800341c:	20726f20 	.word	0x20726f20
 8003420:	6d6f7270 	.word	0x6d6f7270
 8003424:	2065746f 	.word	0x2065746f
 8003428:	646f7270 	.word	0x646f7270
 800342c:	73746375 	.word	0x73746375
 8003430:	20200a0d 	.word	0x20200a0d
 8003434:	20202020 	.word	0x20202020
 8003438:	69726564 	.word	0x69726564
 800343c:	20646576 	.word	0x20646576
 8003440:	6d6f7266 	.word	0x6d6f7266
 8003444:	69687420 	.word	0x69687420
 8003448:	6f732073 	.word	0x6f732073
 800344c:	61777466 	.word	0x61777466
 8003450:	77206572 	.word	0x77206572
 8003454:	6f687469 	.word	0x6f687469
 8003458:	73207475 	.word	0x73207475
 800345c:	69636570 	.word	0x69636570
 8003460:	20636966 	.word	0x20636966
 8003464:	6f697270 	.word	0x6f697270
 8003468:	72772072 	.word	0x72772072
 800346c:	65747469 	.word	0x65747469
 8003470:	6570206e 	.word	0x6570206e
 8003474:	73696d72 	.word	0x73696d72
 8003478:	6e6f6973 	.word	0x6e6f6973
 800347c:	0d0a0d2e 	.word	0x0d0a0d2e
 8003480:	4948540a 	.word	0x4948540a
 8003484:	4f532053 	.word	0x4f532053
 8003488:	41575446 	.word	0x41575446
 800348c:	49204552 	.word	0x49204552
 8003490:	52502053 	.word	0x52502053
 8003494:	4449564f 	.word	0x4449564f
 8003498:	42204445 	.word	0x42204445
 800349c:	48542059 	.word	0x48542059
 80034a0:	4f432045 	.word	0x4f432045
 80034a4:	49525950 	.word	0x49525950
 80034a8:	20544847 	.word	0x20544847
 80034ac:	444c4f48 	.word	0x444c4f48
 80034b0:	20535245 	.word	0x20535245
 80034b4:	20444e41 	.word	0x20444e41
 80034b8:	544e4f43 	.word	0x544e4f43
 80034bc:	55424952 	.word	0x55424952
 80034c0:	53524f54 	.word	0x53524f54
 80034c4:	53412220 	.word	0x53412220
 80034c8:	22534920 	.word	0x22534920
 80034cc:	444e4120 	.word	0x444e4120
 80034d0:	4e410a0d 	.word	0x4e410a0d
 80034d4:	58452059 	.word	0x58452059
 80034d8:	53455250 	.word	0x53455250
 80034dc:	524f2053 	.word	0x524f2053
 80034e0:	504d4920 	.word	0x504d4920
 80034e4:	4445494c 	.word	0x4445494c
 80034e8:	52415720 	.word	0x52415720
 80034ec:	544e4152 	.word	0x544e4152
 80034f0:	2c534549 	.word	0x2c534549
 80034f4:	434e4920 	.word	0x434e4920
 80034f8:	4944554c 	.word	0x4944554c
 80034fc:	202c474e 	.word	0x202c474e
 8003500:	20545542 	.word	0x20545542
 8003504:	20544f4e 	.word	0x20544f4e
 8003508:	494d494c 	.word	0x494d494c
 800350c:	20444554 	.word	0x20444554
 8003510:	202c4f54 	.word	0x202c4f54
 8003514:	20454854 	.word	0x20454854
 8003518:	4c504d49 	.word	0x4c504d49
 800351c:	0d444549 	.word	0x0d444549
 8003520:	5241570a 	.word	0x5241570a
 8003524:	544e4152 	.word	0x544e4152
 8003528:	20534549 	.word	0x20534549
 800352c:	4d20464f 	.word	0x4d20464f
 8003530:	48435245 	.word	0x48435245
 8003534:	41544e41 	.word	0x41544e41
 8003538:	494c4942 	.word	0x494c4942
 800353c:	41205954 	.word	0x41205954
 8003540:	4620444e 	.word	0x4620444e
 8003544:	454e5449 	.word	0x454e5449
 8003548:	46205353 	.word	0x46205353
 800354c:	4120524f 	.word	0x4120524f
 8003550:	52415020 	.word	0x52415020
 8003554:	55434954 	.word	0x55434954
 8003558:	2052414c 	.word	0x2052414c
 800355c:	50525550 	.word	0x50525550
 8003560:	2045534f 	.word	0x2045534f
 8003564:	0d455241 	.word	0x0d455241
 8003568:	5349440a 	.word	0x5349440a
 800356c:	49414c43 	.word	0x49414c43
 8003570:	2e44454d 	.word	0x2e44454d
 8003574:	204e4920 	.word	0x204e4920
 8003578:	45204f4e 	.word	0x45204f4e
 800357c:	544e4556 	.word	0x544e4556
 8003580:	41485320 	.word	0x41485320
 8003584:	54204c4c 	.word	0x54204c4c
 8003588:	41204548 	.word	0x41204548
 800358c:	4f485455 	.word	0x4f485455
 8003590:	524f2052 	.word	0x524f2052
 8003594:	53494420 	.word	0x53494420
 8003598:	42495254 	.word	0x42495254
 800359c:	524f5455 	.word	0x524f5455
 80035a0:	20454220 	.word	0x20454220
 80035a4:	4241494c 	.word	0x4241494c
 80035a8:	4620454c 	.word	0x4620454c
 80035ac:	4120524f 	.word	0x4120524f
 80035b0:	0a0d594e 	.word	0x0a0d594e
 80035b4:	45524944 	.word	0x45524944
 80035b8:	202c5443 	.word	0x202c5443
 80035bc:	49444e49 	.word	0x49444e49
 80035c0:	54434552 	.word	0x54434552
 80035c4:	4e49202c 	.word	0x4e49202c
 80035c8:	45444943 	.word	0x45444943
 80035cc:	4c41544e 	.word	0x4c41544e
 80035d0:	5053202c 	.word	0x5053202c
 80035d4:	41494345 	.word	0x41494345
 80035d8:	45202c4c 	.word	0x45202c4c
 80035dc:	504d4558 	.word	0x504d4558
 80035e0:	5952414c 	.word	0x5952414c
 80035e4:	524f202c 	.word	0x524f202c
 80035e8:	4e4f4320 	.word	0x4e4f4320
 80035ec:	55514553 	.word	0x55514553
 80035f0:	49544e45 	.word	0x49544e45
 80035f4:	44204c41 	.word	0x44204c41
 80035f8:	47414d41 	.word	0x47414d41
 80035fc:	0a0d5345 	.word	0x0a0d5345
 8003600:	434e4928 	.word	0x434e4928
 8003604:	4944554c 	.word	0x4944554c
 8003608:	202c474e 	.word	0x202c474e
 800360c:	20545542 	.word	0x20545542
 8003610:	20544f4e 	.word	0x20544f4e
 8003614:	494d494c 	.word	0x494d494c
 8003618:	20444554 	.word	0x20444554
 800361c:	202c4f54 	.word	0x202c4f54
 8003620:	434f5250 	.word	0x434f5250
 8003624:	4d455255 	.word	0x4d455255
 8003628:	20544e45 	.word	0x20544e45
 800362c:	5320464f 	.word	0x5320464f
 8003630:	54534255 	.word	0x54534255
 8003634:	54555449 	.word	0x54555449
 8003638:	4f472045 	.word	0x4f472045
 800363c:	2053444f 	.word	0x2053444f
 8003640:	5320524f 	.word	0x5320524f
 8003644:	49565245 	.word	0x49565245
 8003648:	3b534543 	.word	0x3b534543
 800364c:	4f4c0a0d 	.word	0x4f4c0a0d
 8003650:	4f205353 	.word	0x4f205353
 8003654:	53552046 	.word	0x53552046
 8003658:	44202c45 	.word	0x44202c45
 800365c:	2c415441 	.word	0x2c415441
 8003660:	20524f20 	.word	0x20524f20
 8003664:	464f5250 	.word	0x464f5250
 8003668:	3b535449 	.word	0x3b535449
 800366c:	20524f20 	.word	0x20524f20
 8003670:	49535542 	.word	0x49535542
 8003674:	5353454e 	.word	0x5353454e
 8003678:	544e4920 	.word	0x544e4920
 800367c:	55525245 	.word	0x55525245
 8003680:	4f495450 	.word	0x4f495450
 8003684:	4820294e 	.word	0x4820294e
 8003688:	5645574f 	.word	0x5645574f
 800368c:	43205245 	.word	0x43205245
 8003690:	45535541 	.word	0x45535541
 8003694:	4e412044 	.word	0x4e412044
 8003698:	4f0a0d44 	.word	0x4f0a0d44
 800369c:	4e41204e 	.word	0x4e41204e
 80036a0:	48542059 	.word	0x48542059
 80036a4:	59524f45 	.word	0x59524f45
 80036a8:	20464f20 	.word	0x20464f20
 80036ac:	4241494c 	.word	0x4241494c
 80036b0:	54494c49 	.word	0x54494c49
 80036b4:	57202c59 	.word	0x57202c59
 80036b8:	48544548 	.word	0x48544548
 80036bc:	49205245 	.word	0x49205245
 80036c0:	4f43204e 	.word	0x4f43204e
 80036c4:	4152544e 	.word	0x4152544e
 80036c8:	202c5443 	.word	0x202c5443
 80036cc:	49525453 	.word	0x49525453
 80036d0:	4c205443 	.word	0x4c205443
 80036d4:	49424149 	.word	0x49424149
 80036d8:	5954494c 	.word	0x5954494c
 80036dc:	524f202c 	.word	0x524f202c
 80036e0:	524f5420 	.word	0x524f5420
 80036e4:	280a0d54 	.word	0x280a0d54
 80036e8:	4c434e49 	.word	0x4c434e49
 80036ec:	4e494455 	.word	0x4e494455
 80036f0:	454e2047 	.word	0x454e2047
 80036f4:	47494c47 	.word	0x47494c47
 80036f8:	45434e45 	.word	0x45434e45
 80036fc:	20524f20 	.word	0x20524f20
 8003700:	4548544f 	.word	0x4548544f
 8003704:	53495752 	.word	0x53495752
 8003708:	41202945 	.word	0x41202945
 800370c:	49534952 	.word	0x49534952
 8003710:	4920474e 	.word	0x4920474e
 8003714:	4e41204e 	.word	0x4e41204e
 8003718:	41572059 	.word	0x41572059
 800371c:	554f2059 	.word	0x554f2059
 8003720:	464f2054 	.word	0x464f2054
 8003724:	45485420 	.word	0x45485420
 8003728:	45535520 	.word	0x45535520
 800372c:	20464f20 	.word	0x20464f20
 8003730:	53494854 	.word	0x53494854
 8003734:	4f530a0d 	.word	0x4f530a0d
 8003738:	41575446 	.word	0x41575446
 800373c:	202c4552 	.word	0x202c4552
 8003740:	4e455645 	.word	0x4e455645
 8003744:	20464920 	.word	0x20464920
 8003748:	49564441 	.word	0x49564441
 800374c:	20444553 	.word	0x20444553
 8003750:	5420464f 	.word	0x5420464f
 8003754:	50204548 	.word	0x50204548
 8003758:	4953534f 	.word	0x4953534f
 800375c:	494c4942 	.word	0x494c4942
 8003760:	4f205954 	.word	0x4f205954
 8003764:	55532046 	.word	0x55532046
 8003768:	44204843 	.word	0x44204843
 800376c:	47414d41 	.word	0x47414d41
 8003770:	0a0d2e45 	.word	0x0a0d2e45
 8003774:	2a2a2a2a 	.word	0x2a2a2a2a
 8003778:	2a2a2a2a 	.word	0x2a2a2a2a
 800377c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003780:	2a2a2a2a 	.word	0x2a2a2a2a
 8003784:	2a2a2a2a 	.word	0x2a2a2a2a
 8003788:	2a2a2a2a 	.word	0x2a2a2a2a
 800378c:	2a2a2a2a 	.word	0x2a2a2a2a
 8003790:	2a2a2a2a 	.word	0x2a2a2a2a
 8003794:	2a2a2a2a 	.word	0x2a2a2a2a
 8003798:	2a2a2a2a 	.word	0x2a2a2a2a
 800379c:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a4:	2a2a2a2a 	.word	0x2a2a2a2a
 80037a8:	2a2a2a2a 	.word	0x2a2a2a2a
 80037ac:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b4:	2a2a2a2a 	.word	0x2a2a2a2a
 80037b8:	2a2a2a2a 	.word	0x2a2a2a2a
 80037bc:	2a2a2a2a 	.word	0x2a2a2a2a
 80037c0:	2a2a2a2a 	.word	0x2a2a2a2a
 80037c4:	0a0d2a2a 	.word	0x0a0d2a2a
 80037c8:	0d00      	.short	0x0d00
 80037ca:	0a          	.byte	0x0a

080037cb <_binary_data_license_bin_end>:
	...

080037cc <__aeabi_uldivmod>:
 80037cc:	b953      	cbnz	r3, 80037e4 <__aeabi_uldivmod+0x18>
 80037ce:	b94a      	cbnz	r2, 80037e4 <__aeabi_uldivmod+0x18>
 80037d0:	2900      	cmp	r1, #0
 80037d2:	bf08      	it	eq
 80037d4:	2800      	cmpeq	r0, #0
 80037d6:	bf1c      	itt	ne
 80037d8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80037dc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80037e0:	f000 b976 	b.w	8003ad0 <__aeabi_idiv0>
 80037e4:	f1ad 0c08 	sub.w	ip, sp, #8
 80037e8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80037ec:	f000 f806 	bl	80037fc <__udivmoddi4>
 80037f0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80037f4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80037f8:	b004      	add	sp, #16
 80037fa:	4770      	bx	lr

080037fc <__udivmoddi4>:
 80037fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003800:	9e08      	ldr	r6, [sp, #32]
 8003802:	460d      	mov	r5, r1
 8003804:	4604      	mov	r4, r0
 8003806:	4688      	mov	r8, r1
 8003808:	2b00      	cmp	r3, #0
 800380a:	d14d      	bne.n	80038a8 <__udivmoddi4+0xac>
 800380c:	428a      	cmp	r2, r1
 800380e:	4694      	mov	ip, r2
 8003810:	d968      	bls.n	80038e4 <__udivmoddi4+0xe8>
 8003812:	fab2 f282 	clz	r2, r2
 8003816:	b152      	cbz	r2, 800382e <__udivmoddi4+0x32>
 8003818:	fa01 f302 	lsl.w	r3, r1, r2
 800381c:	f1c2 0120 	rsb	r1, r2, #32
 8003820:	fa20 f101 	lsr.w	r1, r0, r1
 8003824:	fa0c fc02 	lsl.w	ip, ip, r2
 8003828:	ea41 0803 	orr.w	r8, r1, r3
 800382c:	4094      	lsls	r4, r2
 800382e:	ea4f 411c 	mov.w	r1, ip, lsr #16
 8003832:	fbb8 f7f1 	udiv	r7, r8, r1
 8003836:	fa1f fe8c 	uxth.w	lr, ip
 800383a:	fb01 8817 	mls	r8, r1, r7, r8
 800383e:	fb07 f00e 	mul.w	r0, r7, lr
 8003842:	0c23      	lsrs	r3, r4, #16
 8003844:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8003848:	4298      	cmp	r0, r3
 800384a:	d90a      	bls.n	8003862 <__udivmoddi4+0x66>
 800384c:	eb1c 0303 	adds.w	r3, ip, r3
 8003850:	f107 35ff 	add.w	r5, r7, #4294967295	; 0xffffffff
 8003854:	f080 811e 	bcs.w	8003a94 <__udivmoddi4+0x298>
 8003858:	4298      	cmp	r0, r3
 800385a:	f240 811b 	bls.w	8003a94 <__udivmoddi4+0x298>
 800385e:	3f02      	subs	r7, #2
 8003860:	4463      	add	r3, ip
 8003862:	1a1b      	subs	r3, r3, r0
 8003864:	fbb3 f0f1 	udiv	r0, r3, r1
 8003868:	fb01 3310 	mls	r3, r1, r0, r3
 800386c:	fb00 fe0e 	mul.w	lr, r0, lr
 8003870:	b2a4      	uxth	r4, r4
 8003872:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8003876:	45a6      	cmp	lr, r4
 8003878:	d90a      	bls.n	8003890 <__udivmoddi4+0x94>
 800387a:	eb1c 0404 	adds.w	r4, ip, r4
 800387e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8003882:	f080 8109 	bcs.w	8003a98 <__udivmoddi4+0x29c>
 8003886:	45a6      	cmp	lr, r4
 8003888:	f240 8106 	bls.w	8003a98 <__udivmoddi4+0x29c>
 800388c:	4464      	add	r4, ip
 800388e:	3802      	subs	r0, #2
 8003890:	2100      	movs	r1, #0
 8003892:	eba4 040e 	sub.w	r4, r4, lr
 8003896:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800389a:	b11e      	cbz	r6, 80038a4 <__udivmoddi4+0xa8>
 800389c:	2300      	movs	r3, #0
 800389e:	40d4      	lsrs	r4, r2
 80038a0:	e9c6 4300 	strd	r4, r3, [r6]
 80038a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80038a8:	428b      	cmp	r3, r1
 80038aa:	d908      	bls.n	80038be <__udivmoddi4+0xc2>
 80038ac:	2e00      	cmp	r6, #0
 80038ae:	f000 80ee 	beq.w	8003a8e <__udivmoddi4+0x292>
 80038b2:	2100      	movs	r1, #0
 80038b4:	e9c6 0500 	strd	r0, r5, [r6]
 80038b8:	4608      	mov	r0, r1
 80038ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80038be:	fab3 f183 	clz	r1, r3
 80038c2:	2900      	cmp	r1, #0
 80038c4:	d14a      	bne.n	800395c <__udivmoddi4+0x160>
 80038c6:	42ab      	cmp	r3, r5
 80038c8:	d302      	bcc.n	80038d0 <__udivmoddi4+0xd4>
 80038ca:	4282      	cmp	r2, r0
 80038cc:	f200 80fc 	bhi.w	8003ac8 <__udivmoddi4+0x2cc>
 80038d0:	1a84      	subs	r4, r0, r2
 80038d2:	eb65 0303 	sbc.w	r3, r5, r3
 80038d6:	2001      	movs	r0, #1
 80038d8:	4698      	mov	r8, r3
 80038da:	2e00      	cmp	r6, #0
 80038dc:	d0e2      	beq.n	80038a4 <__udivmoddi4+0xa8>
 80038de:	e9c6 4800 	strd	r4, r8, [r6]
 80038e2:	e7df      	b.n	80038a4 <__udivmoddi4+0xa8>
 80038e4:	b902      	cbnz	r2, 80038e8 <__udivmoddi4+0xec>
 80038e6:	deff      	udf	#255	; 0xff
 80038e8:	fab2 f282 	clz	r2, r2
 80038ec:	2a00      	cmp	r2, #0
 80038ee:	f040 8091 	bne.w	8003a14 <__udivmoddi4+0x218>
 80038f2:	eba1 000c 	sub.w	r0, r1, ip
 80038f6:	2101      	movs	r1, #1
 80038f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80038fc:	fa1f fe8c 	uxth.w	lr, ip
 8003900:	fbb0 f3f7 	udiv	r3, r0, r7
 8003904:	fb07 0013 	mls	r0, r7, r3, r0
 8003908:	0c25      	lsrs	r5, r4, #16
 800390a:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 800390e:	fb0e f003 	mul.w	r0, lr, r3
 8003912:	42a8      	cmp	r0, r5
 8003914:	d908      	bls.n	8003928 <__udivmoddi4+0x12c>
 8003916:	eb1c 0505 	adds.w	r5, ip, r5
 800391a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800391e:	d202      	bcs.n	8003926 <__udivmoddi4+0x12a>
 8003920:	42a8      	cmp	r0, r5
 8003922:	f200 80ce 	bhi.w	8003ac2 <__udivmoddi4+0x2c6>
 8003926:	4643      	mov	r3, r8
 8003928:	1a2d      	subs	r5, r5, r0
 800392a:	fbb5 f0f7 	udiv	r0, r5, r7
 800392e:	fb07 5510 	mls	r5, r7, r0, r5
 8003932:	fb0e fe00 	mul.w	lr, lr, r0
 8003936:	b2a4      	uxth	r4, r4
 8003938:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800393c:	45a6      	cmp	lr, r4
 800393e:	d908      	bls.n	8003952 <__udivmoddi4+0x156>
 8003940:	eb1c 0404 	adds.w	r4, ip, r4
 8003944:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 8003948:	d202      	bcs.n	8003950 <__udivmoddi4+0x154>
 800394a:	45a6      	cmp	lr, r4
 800394c:	f200 80b6 	bhi.w	8003abc <__udivmoddi4+0x2c0>
 8003950:	4628      	mov	r0, r5
 8003952:	eba4 040e 	sub.w	r4, r4, lr
 8003956:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800395a:	e79e      	b.n	800389a <__udivmoddi4+0x9e>
 800395c:	f1c1 0720 	rsb	r7, r1, #32
 8003960:	408b      	lsls	r3, r1
 8003962:	fa22 fc07 	lsr.w	ip, r2, r7
 8003966:	ea4c 0c03 	orr.w	ip, ip, r3
 800396a:	fa25 fa07 	lsr.w	sl, r5, r7
 800396e:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8003972:	fbba f8f9 	udiv	r8, sl, r9
 8003976:	fa20 f307 	lsr.w	r3, r0, r7
 800397a:	fb09 aa18 	mls	sl, r9, r8, sl
 800397e:	408d      	lsls	r5, r1
 8003980:	fa1f fe8c 	uxth.w	lr, ip
 8003984:	431d      	orrs	r5, r3
 8003986:	fa00 f301 	lsl.w	r3, r0, r1
 800398a:	fb08 f00e 	mul.w	r0, r8, lr
 800398e:	0c2c      	lsrs	r4, r5, #16
 8003990:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 8003994:	42a0      	cmp	r0, r4
 8003996:	fa02 f201 	lsl.w	r2, r2, r1
 800399a:	d90b      	bls.n	80039b4 <__udivmoddi4+0x1b8>
 800399c:	eb1c 0404 	adds.w	r4, ip, r4
 80039a0:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80039a4:	f080 8088 	bcs.w	8003ab8 <__udivmoddi4+0x2bc>
 80039a8:	42a0      	cmp	r0, r4
 80039aa:	f240 8085 	bls.w	8003ab8 <__udivmoddi4+0x2bc>
 80039ae:	f1a8 0802 	sub.w	r8, r8, #2
 80039b2:	4464      	add	r4, ip
 80039b4:	1a24      	subs	r4, r4, r0
 80039b6:	fbb4 f0f9 	udiv	r0, r4, r9
 80039ba:	fb09 4410 	mls	r4, r9, r0, r4
 80039be:	fb00 fe0e 	mul.w	lr, r0, lr
 80039c2:	b2ad      	uxth	r5, r5
 80039c4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 80039c8:	45a6      	cmp	lr, r4
 80039ca:	d908      	bls.n	80039de <__udivmoddi4+0x1e2>
 80039cc:	eb1c 0404 	adds.w	r4, ip, r4
 80039d0:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 80039d4:	d26c      	bcs.n	8003ab0 <__udivmoddi4+0x2b4>
 80039d6:	45a6      	cmp	lr, r4
 80039d8:	d96a      	bls.n	8003ab0 <__udivmoddi4+0x2b4>
 80039da:	3802      	subs	r0, #2
 80039dc:	4464      	add	r4, ip
 80039de:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80039e2:	fba0 9502 	umull	r9, r5, r0, r2
 80039e6:	eba4 040e 	sub.w	r4, r4, lr
 80039ea:	42ac      	cmp	r4, r5
 80039ec:	46c8      	mov	r8, r9
 80039ee:	46ae      	mov	lr, r5
 80039f0:	d356      	bcc.n	8003aa0 <__udivmoddi4+0x2a4>
 80039f2:	d053      	beq.n	8003a9c <__udivmoddi4+0x2a0>
 80039f4:	2e00      	cmp	r6, #0
 80039f6:	d069      	beq.n	8003acc <__udivmoddi4+0x2d0>
 80039f8:	ebb3 0208 	subs.w	r2, r3, r8
 80039fc:	eb64 040e 	sbc.w	r4, r4, lr
 8003a00:	fa22 f301 	lsr.w	r3, r2, r1
 8003a04:	fa04 f707 	lsl.w	r7, r4, r7
 8003a08:	431f      	orrs	r7, r3
 8003a0a:	40cc      	lsrs	r4, r1
 8003a0c:	e9c6 7400 	strd	r7, r4, [r6]
 8003a10:	2100      	movs	r1, #0
 8003a12:	e747      	b.n	80038a4 <__udivmoddi4+0xa8>
 8003a14:	fa0c fc02 	lsl.w	ip, ip, r2
 8003a18:	f1c2 0120 	rsb	r1, r2, #32
 8003a1c:	fa25 f301 	lsr.w	r3, r5, r1
 8003a20:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8003a24:	fa20 f101 	lsr.w	r1, r0, r1
 8003a28:	4095      	lsls	r5, r2
 8003a2a:	430d      	orrs	r5, r1
 8003a2c:	fbb3 f1f7 	udiv	r1, r3, r7
 8003a30:	fb07 3311 	mls	r3, r7, r1, r3
 8003a34:	fa1f fe8c 	uxth.w	lr, ip
 8003a38:	0c28      	lsrs	r0, r5, #16
 8003a3a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8003a3e:	fb01 f30e 	mul.w	r3, r1, lr
 8003a42:	4283      	cmp	r3, r0
 8003a44:	fa04 f402 	lsl.w	r4, r4, r2
 8003a48:	d908      	bls.n	8003a5c <__udivmoddi4+0x260>
 8003a4a:	eb1c 0000 	adds.w	r0, ip, r0
 8003a4e:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
 8003a52:	d22f      	bcs.n	8003ab4 <__udivmoddi4+0x2b8>
 8003a54:	4283      	cmp	r3, r0
 8003a56:	d92d      	bls.n	8003ab4 <__udivmoddi4+0x2b8>
 8003a58:	3902      	subs	r1, #2
 8003a5a:	4460      	add	r0, ip
 8003a5c:	1ac0      	subs	r0, r0, r3
 8003a5e:	fbb0 f3f7 	udiv	r3, r0, r7
 8003a62:	fb07 0013 	mls	r0, r7, r3, r0
 8003a66:	b2ad      	uxth	r5, r5
 8003a68:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 8003a6c:	fb03 f00e 	mul.w	r0, r3, lr
 8003a70:	42a8      	cmp	r0, r5
 8003a72:	d908      	bls.n	8003a86 <__udivmoddi4+0x28a>
 8003a74:	eb1c 0505 	adds.w	r5, ip, r5
 8003a78:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8003a7c:	d216      	bcs.n	8003aac <__udivmoddi4+0x2b0>
 8003a7e:	42a8      	cmp	r0, r5
 8003a80:	d914      	bls.n	8003aac <__udivmoddi4+0x2b0>
 8003a82:	3b02      	subs	r3, #2
 8003a84:	4465      	add	r5, ip
 8003a86:	1a28      	subs	r0, r5, r0
 8003a88:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003a8c:	e738      	b.n	8003900 <__udivmoddi4+0x104>
 8003a8e:	4631      	mov	r1, r6
 8003a90:	4630      	mov	r0, r6
 8003a92:	e707      	b.n	80038a4 <__udivmoddi4+0xa8>
 8003a94:	462f      	mov	r7, r5
 8003a96:	e6e4      	b.n	8003862 <__udivmoddi4+0x66>
 8003a98:	4618      	mov	r0, r3
 8003a9a:	e6f9      	b.n	8003890 <__udivmoddi4+0x94>
 8003a9c:	454b      	cmp	r3, r9
 8003a9e:	d2a9      	bcs.n	80039f4 <__udivmoddi4+0x1f8>
 8003aa0:	ebb9 0802 	subs.w	r8, r9, r2
 8003aa4:	eb65 0e0c 	sbc.w	lr, r5, ip
 8003aa8:	3801      	subs	r0, #1
 8003aaa:	e7a3      	b.n	80039f4 <__udivmoddi4+0x1f8>
 8003aac:	4643      	mov	r3, r8
 8003aae:	e7ea      	b.n	8003a86 <__udivmoddi4+0x28a>
 8003ab0:	4628      	mov	r0, r5
 8003ab2:	e794      	b.n	80039de <__udivmoddi4+0x1e2>
 8003ab4:	4641      	mov	r1, r8
 8003ab6:	e7d1      	b.n	8003a5c <__udivmoddi4+0x260>
 8003ab8:	46d0      	mov	r8, sl
 8003aba:	e77b      	b.n	80039b4 <__udivmoddi4+0x1b8>
 8003abc:	4464      	add	r4, ip
 8003abe:	3802      	subs	r0, #2
 8003ac0:	e747      	b.n	8003952 <__udivmoddi4+0x156>
 8003ac2:	3b02      	subs	r3, #2
 8003ac4:	4465      	add	r5, ip
 8003ac6:	e72f      	b.n	8003928 <__udivmoddi4+0x12c>
 8003ac8:	4608      	mov	r0, r1
 8003aca:	e706      	b.n	80038da <__udivmoddi4+0xde>
 8003acc:	4631      	mov	r1, r6
 8003ace:	e6e9      	b.n	80038a4 <__udivmoddi4+0xa8>

08003ad0 <__aeabi_idiv0>:
 8003ad0:	4770      	bx	lr
 8003ad2:	bf00      	nop

08003ad4 <memcpy>:
 8003ad4:	4684      	mov	ip, r0
 8003ad6:	ea41 0300 	orr.w	r3, r1, r0
 8003ada:	f013 0303 	ands.w	r3, r3, #3
 8003ade:	d149      	bne.n	8003b74 <memcpy+0xa0>
 8003ae0:	3a40      	subs	r2, #64	; 0x40
 8003ae2:	d323      	bcc.n	8003b2c <memcpy+0x58>
 8003ae4:	680b      	ldr	r3, [r1, #0]
 8003ae6:	6003      	str	r3, [r0, #0]
 8003ae8:	684b      	ldr	r3, [r1, #4]
 8003aea:	6043      	str	r3, [r0, #4]
 8003aec:	688b      	ldr	r3, [r1, #8]
 8003aee:	6083      	str	r3, [r0, #8]
 8003af0:	68cb      	ldr	r3, [r1, #12]
 8003af2:	60c3      	str	r3, [r0, #12]
 8003af4:	690b      	ldr	r3, [r1, #16]
 8003af6:	6103      	str	r3, [r0, #16]
 8003af8:	694b      	ldr	r3, [r1, #20]
 8003afa:	6143      	str	r3, [r0, #20]
 8003afc:	698b      	ldr	r3, [r1, #24]
 8003afe:	6183      	str	r3, [r0, #24]
 8003b00:	69cb      	ldr	r3, [r1, #28]
 8003b02:	61c3      	str	r3, [r0, #28]
 8003b04:	6a0b      	ldr	r3, [r1, #32]
 8003b06:	6203      	str	r3, [r0, #32]
 8003b08:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8003b0a:	6243      	str	r3, [r0, #36]	; 0x24
 8003b0c:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003b0e:	6283      	str	r3, [r0, #40]	; 0x28
 8003b10:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8003b12:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003b14:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8003b16:	6303      	str	r3, [r0, #48]	; 0x30
 8003b18:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8003b1a:	6343      	str	r3, [r0, #52]	; 0x34
 8003b1c:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8003b1e:	6383      	str	r3, [r0, #56]	; 0x38
 8003b20:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8003b22:	63c3      	str	r3, [r0, #60]	; 0x3c
 8003b24:	3040      	adds	r0, #64	; 0x40
 8003b26:	3140      	adds	r1, #64	; 0x40
 8003b28:	3a40      	subs	r2, #64	; 0x40
 8003b2a:	d2db      	bcs.n	8003ae4 <memcpy+0x10>
 8003b2c:	3230      	adds	r2, #48	; 0x30
 8003b2e:	d30b      	bcc.n	8003b48 <memcpy+0x74>
 8003b30:	680b      	ldr	r3, [r1, #0]
 8003b32:	6003      	str	r3, [r0, #0]
 8003b34:	684b      	ldr	r3, [r1, #4]
 8003b36:	6043      	str	r3, [r0, #4]
 8003b38:	688b      	ldr	r3, [r1, #8]
 8003b3a:	6083      	str	r3, [r0, #8]
 8003b3c:	68cb      	ldr	r3, [r1, #12]
 8003b3e:	60c3      	str	r3, [r0, #12]
 8003b40:	3010      	adds	r0, #16
 8003b42:	3110      	adds	r1, #16
 8003b44:	3a10      	subs	r2, #16
 8003b46:	d2f3      	bcs.n	8003b30 <memcpy+0x5c>
 8003b48:	320c      	adds	r2, #12
 8003b4a:	d305      	bcc.n	8003b58 <memcpy+0x84>
 8003b4c:	f851 3b04 	ldr.w	r3, [r1], #4
 8003b50:	f840 3b04 	str.w	r3, [r0], #4
 8003b54:	3a04      	subs	r2, #4
 8003b56:	d2f9      	bcs.n	8003b4c <memcpy+0x78>
 8003b58:	3204      	adds	r2, #4
 8003b5a:	d008      	beq.n	8003b6e <memcpy+0x9a>
 8003b5c:	07d2      	lsls	r2, r2, #31
 8003b5e:	bf1c      	itt	ne
 8003b60:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8003b64:	f800 3b01 	strbne.w	r3, [r0], #1
 8003b68:	d301      	bcc.n	8003b6e <memcpy+0x9a>
 8003b6a:	880b      	ldrh	r3, [r1, #0]
 8003b6c:	8003      	strh	r3, [r0, #0]
 8003b6e:	4660      	mov	r0, ip
 8003b70:	4770      	bx	lr
 8003b72:	bf00      	nop
 8003b74:	2a08      	cmp	r2, #8
 8003b76:	d313      	bcc.n	8003ba0 <memcpy+0xcc>
 8003b78:	078b      	lsls	r3, r1, #30
 8003b7a:	d0b1      	beq.n	8003ae0 <memcpy+0xc>
 8003b7c:	f010 0303 	ands.w	r3, r0, #3
 8003b80:	d0ae      	beq.n	8003ae0 <memcpy+0xc>
 8003b82:	f1c3 0304 	rsb	r3, r3, #4
 8003b86:	1ad2      	subs	r2, r2, r3
 8003b88:	07db      	lsls	r3, r3, #31
 8003b8a:	bf1c      	itt	ne
 8003b8c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8003b90:	f800 3b01 	strbne.w	r3, [r0], #1
 8003b94:	d3a4      	bcc.n	8003ae0 <memcpy+0xc>
 8003b96:	f831 3b02 	ldrh.w	r3, [r1], #2
 8003b9a:	f820 3b02 	strh.w	r3, [r0], #2
 8003b9e:	e79f      	b.n	8003ae0 <memcpy+0xc>
 8003ba0:	3a04      	subs	r2, #4
 8003ba2:	d3d9      	bcc.n	8003b58 <memcpy+0x84>
 8003ba4:	3a01      	subs	r2, #1
 8003ba6:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003baa:	f800 3b01 	strb.w	r3, [r0], #1
 8003bae:	d2f9      	bcs.n	8003ba4 <memcpy+0xd0>
 8003bb0:	780b      	ldrb	r3, [r1, #0]
 8003bb2:	7003      	strb	r3, [r0, #0]
 8003bb4:	784b      	ldrb	r3, [r1, #1]
 8003bb6:	7043      	strb	r3, [r0, #1]
 8003bb8:	788b      	ldrb	r3, [r1, #2]
 8003bba:	7083      	strb	r3, [r0, #2]
 8003bbc:	4660      	mov	r0, ip
 8003bbe:	4770      	bx	lr

08003bc0 <strcmp>:
 8003bc0:	ea80 0c01 	eor.w	ip, r0, r1
 8003bc4:	f01c 0f03 	tst.w	ip, #3
 8003bc8:	d137      	bne.n	8003c3a <strcmp+0x7a>
 8003bca:	f010 0c03 	ands.w	ip, r0, #3
 8003bce:	f020 0003 	bic.w	r0, r0, #3
 8003bd2:	f021 0103 	bic.w	r1, r1, #3
 8003bd6:	f850 2b04 	ldr.w	r2, [r0], #4
 8003bda:	bf08      	it	eq
 8003bdc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003be0:	d00e      	beq.n	8003c00 <strcmp+0x40>
 8003be2:	f08c 0c03 	eor.w	ip, ip, #3
 8003be6:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8003bea:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8003bee:	fa23 fc0c 	lsr.w	ip, r3, ip
 8003bf2:	f851 3b04 	ldr.w	r3, [r1], #4
 8003bf6:	ea42 020c 	orr.w	r2, r2, ip
 8003bfa:	ea43 030c 	orr.w	r3, r3, ip
 8003bfe:	bf00      	nop
 8003c00:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003c04:	429a      	cmp	r2, r3
 8003c06:	bf01      	itttt	eq
 8003c08:	ea2c 0c02 	biceq.w	ip, ip, r2
 8003c0c:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8003c10:	f850 2b04 	ldreq.w	r2, [r0], #4
 8003c14:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003c18:	d0f2      	beq.n	8003c00 <strcmp+0x40>
 8003c1a:	ea4f 6002 	mov.w	r0, r2, lsl #24
 8003c1e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8003c22:	2801      	cmp	r0, #1
 8003c24:	bf28      	it	cs
 8003c26:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8003c2a:	bf08      	it	eq
 8003c2c:	0a1b      	lsreq	r3, r3, #8
 8003c2e:	d0f4      	beq.n	8003c1a <strcmp+0x5a>
 8003c30:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8003c34:	0e00      	lsrs	r0, r0, #24
 8003c36:	1ac0      	subs	r0, r0, r3
 8003c38:	4770      	bx	lr
 8003c3a:	f010 0f03 	tst.w	r0, #3
 8003c3e:	d00a      	beq.n	8003c56 <strcmp+0x96>
 8003c40:	f810 2b01 	ldrb.w	r2, [r0], #1
 8003c44:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003c48:	2a01      	cmp	r2, #1
 8003c4a:	bf28      	it	cs
 8003c4c:	429a      	cmpcs	r2, r3
 8003c4e:	d0f4      	beq.n	8003c3a <strcmp+0x7a>
 8003c50:	eba2 0003 	sub.w	r0, r2, r3
 8003c54:	4770      	bx	lr
 8003c56:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8003c5a:	f850 2b04 	ldr.w	r2, [r0], #4
 8003c5e:	f001 0503 	and.w	r5, r1, #3
 8003c62:	f021 0103 	bic.w	r1, r1, #3
 8003c66:	f851 3b04 	ldr.w	r3, [r1], #4
 8003c6a:	2d02      	cmp	r5, #2
 8003c6c:	d026      	beq.n	8003cbc <strcmp+0xfc>
 8003c6e:	d84d      	bhi.n	8003d0c <strcmp+0x14c>
 8003c70:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 8003c74:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 8003c78:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003c7c:	ea2c 0c02 	bic.w	ip, ip, r2
 8003c80:	d10d      	bne.n	8003c9e <strcmp+0xde>
 8003c82:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003c86:	bf08      	it	eq
 8003c88:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003c8c:	d10a      	bne.n	8003ca4 <strcmp+0xe4>
 8003c8e:	ea85 0502 	eor.w	r5, r5, r2
 8003c92:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 8003c96:	d10c      	bne.n	8003cb2 <strcmp+0xf2>
 8003c98:	f850 2b04 	ldr.w	r2, [r0], #4
 8003c9c:	e7e8      	b.n	8003c70 <strcmp+0xb0>
 8003c9e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8003ca2:	e05b      	b.n	8003d5c <strcmp+0x19c>
 8003ca4:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 8003ca8:	d154      	bne.n	8003d54 <strcmp+0x194>
 8003caa:	780b      	ldrb	r3, [r1, #0]
 8003cac:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8003cb0:	e054      	b.n	8003d5c <strcmp+0x19c>
 8003cb2:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8003cb6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8003cba:	e04f      	b.n	8003d5c <strcmp+0x19c>
 8003cbc:	ea4f 4502 	mov.w	r5, r2, lsl #16
 8003cc0:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003cc4:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8003cc8:	ea2c 0c02 	bic.w	ip, ip, r2
 8003ccc:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8003cd0:	d118      	bne.n	8003d04 <strcmp+0x144>
 8003cd2:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003cd6:	bf08      	it	eq
 8003cd8:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003cdc:	d107      	bne.n	8003cee <strcmp+0x12e>
 8003cde:	ea85 0502 	eor.w	r5, r5, r2
 8003ce2:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 8003ce6:	d109      	bne.n	8003cfc <strcmp+0x13c>
 8003ce8:	f850 2b04 	ldr.w	r2, [r0], #4
 8003cec:	e7e6      	b.n	8003cbc <strcmp+0xfc>
 8003cee:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 8003cf2:	d12f      	bne.n	8003d54 <strcmp+0x194>
 8003cf4:	880b      	ldrh	r3, [r1, #0]
 8003cf6:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8003cfa:	e02f      	b.n	8003d5c <strcmp+0x19c>
 8003cfc:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8003d00:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8003d04:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8003d08:	e028      	b.n	8003d5c <strcmp+0x19c>
 8003d0a:	bf00      	nop
 8003d0c:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8003d10:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 8003d14:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8003d18:	ea2c 0c02 	bic.w	ip, ip, r2
 8003d1c:	d10d      	bne.n	8003d3a <strcmp+0x17a>
 8003d1e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8003d22:	bf08      	it	eq
 8003d24:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003d28:	d10a      	bne.n	8003d40 <strcmp+0x180>
 8003d2a:	ea85 0502 	eor.w	r5, r5, r2
 8003d2e:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 8003d32:	d10a      	bne.n	8003d4a <strcmp+0x18a>
 8003d34:	f850 2b04 	ldr.w	r2, [r0], #4
 8003d38:	e7e8      	b.n	8003d0c <strcmp+0x14c>
 8003d3a:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8003d3e:	e00d      	b.n	8003d5c <strcmp+0x19c>
 8003d40:	f012 0fff 	tst.w	r2, #255	; 0xff
 8003d44:	d006      	beq.n	8003d54 <strcmp+0x194>
 8003d46:	f851 3b04 	ldr.w	r3, [r1], #4
 8003d4a:	ea4f 2512 	mov.w	r5, r2, lsr #8
 8003d4e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003d52:	e003      	b.n	8003d5c <strcmp+0x19c>
 8003d54:	f04f 0000 	mov.w	r0, #0
 8003d58:	bc20      	pop	{r5}
 8003d5a:	4770      	bx	lr
 8003d5c:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 8003d60:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8003d64:	2801      	cmp	r0, #1
 8003d66:	bf28      	it	cs
 8003d68:	4290      	cmpcs	r0, r2
 8003d6a:	bf04      	itt	eq
 8003d6c:	0a2d      	lsreq	r5, r5, #8
 8003d6e:	0a1b      	lsreq	r3, r3, #8
 8003d70:	d0f4      	beq.n	8003d5c <strcmp+0x19c>
 8003d72:	eba2 0000 	sub.w	r0, r2, r0
 8003d76:	bc20      	pop	{r5}
 8003d78:	4770      	bx	lr
 8003d7a:	bf00      	nop

08003d7c <Vector6C.part.0>:
extern UBaseType_t uxSavedInterruptStatus;

static inline void osalOsRescheduleS(void)
{
    osalDbgCheckClassS();
    if(uxYieldPending()) taskYIELD();
 8003d7c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003d80:	4a0d      	ldr	r2, [pc, #52]	; (8003db8 <Vector6C.part.0+0x3c>)
 8003d82:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003d86:	6011      	str	r1, [r2, #0]
 8003d88:	4a0c      	ldr	r2, [pc, #48]	; (8003dbc <Vector6C.part.0+0x40>)
 8003d8a:	6812      	ldr	r2, [r2, #0]
 8003d8c:	b14a      	cbz	r2, 8003da2 <Vector6C.part.0+0x26>
 8003d8e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003d92:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003d96:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003d9a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003d9e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003da2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003da6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003daa:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003dae:	f3bf 8f4f 	dsb	sy
 8003db2:	f3bf 8f6f 	isb	sy
}
 8003db6:	4770      	bx	lr
 8003db8:	2000134c 	.word	0x2000134c
 8003dbc:	20001358 	.word	0x20001358

08003dc0 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003dc0:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
bool sduRequestsHook(USBDriver *usbp) {
 8003dc4:	4603      	mov	r3, r0
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003dc6:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8003dca:	2a20      	cmp	r2, #32
 8003dcc:	d114      	bne.n	8003df8 <sduRequestsHook+0x38>
    switch (usbp->setup[1]) {
 8003dce:	f890 2075 	ldrb.w	r2, [r0, #117]	; 0x75
 8003dd2:	2000      	movs	r0, #0
 8003dd4:	2a21      	cmp	r2, #33	; 0x21
 8003dd6:	d802      	bhi.n	8003dde <sduRequestsHook+0x1e>
 8003dd8:	2a1f      	cmp	r2, #31
 8003dda:	d803      	bhi.n	8003de4 <sduRequestsHook+0x24>
 8003ddc:	4770      	bx	lr
 8003dde:	2a22      	cmp	r2, #34	; 0x22
 8003de0:	d007      	beq.n	8003df2 <sduRequestsHook+0x32>
 8003de2:	4770      	bx	lr
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8003de4:	4a05      	ldr	r2, [pc, #20]	; (8003dfc <sduRequestsHook+0x3c>)
 8003de6:	669a      	str	r2, [r3, #104]	; 0x68
 8003de8:	2207      	movs	r2, #7
 8003dea:	66da      	str	r2, [r3, #108]	; 0x6c
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003dec:	6718      	str	r0, [r3, #112]	; 0x70
      return true;
 8003dee:	2001      	movs	r0, #1
 8003df0:	4770      	bx	lr
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003df2:	e9c3 001a 	strd	r0, r0, [r3, #104]	; 0x68
 8003df6:	e7f9      	b.n	8003dec <sduRequestsHook+0x2c>
    default:
      return false;
    }
  }
  return false;
 8003df8:	2000      	movs	r0, #0
}
 8003dfa:	4770      	bx	lr
 8003dfc:	20000850 	.word	0x20000850

08003e00 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8003e00:	4770      	bx	lr
	...

08003e04 <set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 8003e04:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8003e08:	4a07      	ldr	r2, [pc, #28]	; (8003e28 <set_address+0x24>)
 8003e0a:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
 8003e0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
static void set_address(USBDriver *usbp) {
 8003e12:	b510      	push	{r4, lr}
 8003e14:	64d3      	str	r3, [r2, #76]	; 0x4c
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003e16:	6843      	ldr	r3, [r0, #4]
static void set_address(USBDriver *usbp) {
 8003e18:	4604      	mov	r4, r0
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003e1a:	681b      	ldr	r3, [r3, #0]
 8003e1c:	b10b      	cbz	r3, 8003e22 <set_address+0x1e>
 8003e1e:	2101      	movs	r1, #1
 8003e20:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8003e22:	2303      	movs	r3, #3
 8003e24:	7023      	strb	r3, [r4, #0]
}
 8003e26:	bd10      	pop	{r4, pc}
 8003e28:	40005c00 	.word	0x40005c00

08003e2c <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8003e2c:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8003e2e:	4b0b      	ldr	r3, [pc, #44]	; (8003e5c <Vector6C+0x30>)
 8003e30:	6819      	ldr	r1, [r3, #0]
 8003e32:	689a      	ldr	r2, [r3, #8]
 8003e34:	f001 010e 	and.w	r1, r1, #14
 8003e38:	420a      	tst	r2, r1
 8003e3a:	d005      	beq.n	8003e48 <Vector6C+0x1c>
 8003e3c:	4a08      	ldr	r2, [pc, #32]	; (8003e60 <Vector6C+0x34>)
 8003e3e:	6059      	str	r1, [r3, #4]
 8003e40:	6813      	ldr	r3, [r2, #0]
 8003e42:	b10b      	cbz	r3, 8003e48 <Vector6C+0x1c>
 8003e44:	6850      	ldr	r0, [r2, #4]
 8003e46:	4798      	blx	r3
UBaseType_t uxYieldPending( void )
{
    UBaseType_t isIt = xYieldPending;
    xYieldPending = pdFALSE;
 8003e48:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003e4a:	4b06      	ldr	r3, [pc, #24]	; (8003e64 <Vector6C+0x38>)
 8003e4c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003e4e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003e50:	b11a      	cbz	r2, 8003e5a <Vector6C+0x2e>
}
 8003e52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8003e56:	f7ff bf91 	b.w	8003d7c <Vector6C.part.0>
 8003e5a:	bd08      	pop	{r3, pc}
 8003e5c:	40020000 	.word	0x40020000
 8003e60:	20000fe8 	.word	0x20000fe8
 8003e64:	2000164c 	.word	0x2000164c

08003e68 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003e68:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8003e6a:	4b19      	ldr	r3, [pc, #100]	; (8003ed0 <Vector70+0x68>)
 8003e6c:	6819      	ldr	r1, [r3, #0]
 8003e6e:	69da      	ldr	r2, [r3, #28]
 8003e70:	0909      	lsrs	r1, r1, #4
 8003e72:	f001 010e 	and.w	r1, r1, #14
 8003e76:	420a      	tst	r2, r1
 8003e78:	d006      	beq.n	8003e88 <Vector70+0x20>
 8003e7a:	010a      	lsls	r2, r1, #4
 8003e7c:	605a      	str	r2, [r3, #4]
 8003e7e:	4a15      	ldr	r2, [pc, #84]	; (8003ed4 <Vector70+0x6c>)
 8003e80:	6893      	ldr	r3, [r2, #8]
 8003e82:	b10b      	cbz	r3, 8003e88 <Vector70+0x20>
 8003e84:	68d0      	ldr	r0, [r2, #12]
 8003e86:	4798      	blx	r3
 8003e88:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003e8a:	4b13      	ldr	r3, [pc, #76]	; (8003ed8 <Vector70+0x70>)
 8003e8c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003e8e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003e90:	b1e2      	cbz	r2, 8003ecc <Vector70+0x64>
 8003e92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003e96:	4a11      	ldr	r2, [pc, #68]	; (8003edc <Vector70+0x74>)
 8003e98:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003e9c:	6011      	str	r1, [r2, #0]
 8003e9e:	4a10      	ldr	r2, [pc, #64]	; (8003ee0 <Vector70+0x78>)
 8003ea0:	6812      	ldr	r2, [r2, #0]
 8003ea2:	b14a      	cbz	r2, 8003eb8 <Vector70+0x50>
 8003ea4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003ea8:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003eac:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003eb0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003eb4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003eb8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003ebc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003ec0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003ec4:	f3bf 8f4f 	dsb	sy
 8003ec8:	f3bf 8f6f 	isb	sy
}
 8003ecc:	bd08      	pop	{r3, pc}
 8003ece:	bf00      	nop
 8003ed0:	40020000 	.word	0x40020000
 8003ed4:	20000fe8 	.word	0x20000fe8
 8003ed8:	2000164c 	.word	0x2000164c
 8003edc:	2000134c 	.word	0x2000134c
 8003ee0:	20001358 	.word	0x20001358

08003ee4 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8003ee4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8003ee6:	4b19      	ldr	r3, [pc, #100]	; (8003f4c <Vector74+0x68>)
 8003ee8:	6819      	ldr	r1, [r3, #0]
 8003eea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003eec:	0a09      	lsrs	r1, r1, #8
 8003eee:	f001 010e 	and.w	r1, r1, #14
 8003ef2:	420a      	tst	r2, r1
 8003ef4:	d006      	beq.n	8003f04 <Vector74+0x20>
 8003ef6:	020a      	lsls	r2, r1, #8
 8003ef8:	605a      	str	r2, [r3, #4]
 8003efa:	4a15      	ldr	r2, [pc, #84]	; (8003f50 <Vector74+0x6c>)
 8003efc:	6913      	ldr	r3, [r2, #16]
 8003efe:	b10b      	cbz	r3, 8003f04 <Vector74+0x20>
 8003f00:	6950      	ldr	r0, [r2, #20]
 8003f02:	4798      	blx	r3
 8003f04:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003f06:	4b13      	ldr	r3, [pc, #76]	; (8003f54 <Vector74+0x70>)
 8003f08:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003f0a:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003f0c:	b1e2      	cbz	r2, 8003f48 <Vector74+0x64>
 8003f0e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f12:	4a11      	ldr	r2, [pc, #68]	; (8003f58 <Vector74+0x74>)
 8003f14:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003f18:	6011      	str	r1, [r2, #0]
 8003f1a:	4a10      	ldr	r2, [pc, #64]	; (8003f5c <Vector74+0x78>)
 8003f1c:	6812      	ldr	r2, [r2, #0]
 8003f1e:	b14a      	cbz	r2, 8003f34 <Vector74+0x50>
 8003f20:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003f24:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003f28:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003f2c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003f30:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003f34:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f38:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003f3c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003f40:	f3bf 8f4f 	dsb	sy
 8003f44:	f3bf 8f6f 	isb	sy
}
 8003f48:	bd08      	pop	{r3, pc}
 8003f4a:	bf00      	nop
 8003f4c:	40020000 	.word	0x40020000
 8003f50:	20000fe8 	.word	0x20000fe8
 8003f54:	2000164c 	.word	0x2000164c
 8003f58:	2000134c 	.word	0x2000134c
 8003f5c:	20001358 	.word	0x20001358

08003f60 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8003f60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8003f62:	4b19      	ldr	r3, [pc, #100]	; (8003fc8 <Vector78+0x68>)
 8003f64:	6819      	ldr	r1, [r3, #0]
 8003f66:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003f68:	0b09      	lsrs	r1, r1, #12
 8003f6a:	f001 010e 	and.w	r1, r1, #14
 8003f6e:	420a      	tst	r2, r1
 8003f70:	d006      	beq.n	8003f80 <Vector78+0x20>
 8003f72:	030a      	lsls	r2, r1, #12
 8003f74:	605a      	str	r2, [r3, #4]
 8003f76:	4a15      	ldr	r2, [pc, #84]	; (8003fcc <Vector78+0x6c>)
 8003f78:	6993      	ldr	r3, [r2, #24]
 8003f7a:	b10b      	cbz	r3, 8003f80 <Vector78+0x20>
 8003f7c:	69d0      	ldr	r0, [r2, #28]
 8003f7e:	4798      	blx	r3
 8003f80:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003f82:	4b13      	ldr	r3, [pc, #76]	; (8003fd0 <Vector78+0x70>)
 8003f84:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8003f86:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8003f88:	b1e2      	cbz	r2, 8003fc4 <Vector78+0x64>
 8003f8a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003f8e:	4a11      	ldr	r2, [pc, #68]	; (8003fd4 <Vector78+0x74>)
 8003f90:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8003f94:	6011      	str	r1, [r2, #0]
 8003f96:	4a10      	ldr	r2, [pc, #64]	; (8003fd8 <Vector78+0x78>)
 8003f98:	6812      	ldr	r2, [r2, #0]
 8003f9a:	b14a      	cbz	r2, 8003fb0 <Vector78+0x50>
 8003f9c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003fa0:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8003fa4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003fa8:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8003fac:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8003fb0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003fb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003fb8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003fbc:	f3bf 8f4f 	dsb	sy
 8003fc0:	f3bf 8f6f 	isb	sy
}
 8003fc4:	bd08      	pop	{r3, pc}
 8003fc6:	bf00      	nop
 8003fc8:	40020000 	.word	0x40020000
 8003fcc:	20000fe8 	.word	0x20000fe8
 8003fd0:	2000164c 	.word	0x2000164c
 8003fd4:	2000134c 	.word	0x2000134c
 8003fd8:	20001358 	.word	0x20001358

08003fdc <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8003fdc:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8003fde:	4b19      	ldr	r3, [pc, #100]	; (8004044 <Vector7C+0x68>)
 8003fe0:	6819      	ldr	r1, [r3, #0]
 8003fe2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8003fe4:	0c09      	lsrs	r1, r1, #16
 8003fe6:	f001 010e 	and.w	r1, r1, #14
 8003fea:	420a      	tst	r2, r1
 8003fec:	d006      	beq.n	8003ffc <Vector7C+0x20>
 8003fee:	040a      	lsls	r2, r1, #16
 8003ff0:	605a      	str	r2, [r3, #4]
 8003ff2:	4a15      	ldr	r2, [pc, #84]	; (8004048 <Vector7C+0x6c>)
 8003ff4:	6a13      	ldr	r3, [r2, #32]
 8003ff6:	b10b      	cbz	r3, 8003ffc <Vector7C+0x20>
 8003ff8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8003ffa:	4798      	blx	r3
 8003ffc:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8003ffe:	4b13      	ldr	r3, [pc, #76]	; (800404c <Vector7C+0x70>)
 8004000:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8004002:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8004004:	b1e2      	cbz	r2, 8004040 <Vector7C+0x64>
 8004006:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800400a:	4a11      	ldr	r2, [pc, #68]	; (8004050 <Vector7C+0x74>)
 800400c:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004010:	6011      	str	r1, [r2, #0]
 8004012:	4a10      	ldr	r2, [pc, #64]	; (8004054 <Vector7C+0x78>)
 8004014:	6812      	ldr	r2, [r2, #0]
 8004016:	b14a      	cbz	r2, 800402c <Vector7C+0x50>
 8004018:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800401c:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004020:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004024:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004028:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800402c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004030:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004034:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004038:	f3bf 8f4f 	dsb	sy
 800403c:	f3bf 8f6f 	isb	sy
}
 8004040:	bd08      	pop	{r3, pc}
 8004042:	bf00      	nop
 8004044:	40020000 	.word	0x40020000
 8004048:	20000fe8 	.word	0x20000fe8
 800404c:	2000164c 	.word	0x2000164c
 8004050:	2000134c 	.word	0x2000134c
 8004054:	20001358 	.word	0x20001358

08004058 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8004058:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800405a:	4b19      	ldr	r3, [pc, #100]	; (80040c0 <Vector80+0x68>)
 800405c:	6819      	ldr	r1, [r3, #0]
 800405e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8004060:	0d09      	lsrs	r1, r1, #20
 8004062:	f001 010e 	and.w	r1, r1, #14
 8004066:	420a      	tst	r2, r1
 8004068:	d006      	beq.n	8004078 <Vector80+0x20>
 800406a:	050a      	lsls	r2, r1, #20
 800406c:	605a      	str	r2, [r3, #4]
 800406e:	4a15      	ldr	r2, [pc, #84]	; (80040c4 <Vector80+0x6c>)
 8004070:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8004072:	b10b      	cbz	r3, 8004078 <Vector80+0x20>
 8004074:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8004076:	4798      	blx	r3
 8004078:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 800407a:	4b13      	ldr	r3, [pc, #76]	; (80040c8 <Vector80+0x70>)
 800407c:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 800407e:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 8004080:	b1e2      	cbz	r2, 80040bc <Vector80+0x64>
 8004082:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004086:	4a11      	ldr	r2, [pc, #68]	; (80040cc <Vector80+0x74>)
 8004088:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800408c:	6011      	str	r1, [r2, #0]
 800408e:	4a10      	ldr	r2, [pc, #64]	; (80040d0 <Vector80+0x78>)
 8004090:	6812      	ldr	r2, [r2, #0]
 8004092:	b14a      	cbz	r2, 80040a8 <Vector80+0x50>
 8004094:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004098:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800409c:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80040a0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80040a4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80040a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80040ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80040b0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80040b4:	f3bf 8f4f 	dsb	sy
 80040b8:	f3bf 8f6f 	isb	sy
}
 80040bc:	bd08      	pop	{r3, pc}
 80040be:	bf00      	nop
 80040c0:	40020000 	.word	0x40020000
 80040c4:	20000fe8 	.word	0x20000fe8
 80040c8:	2000164c 	.word	0x2000164c
 80040cc:	2000134c 	.word	0x2000134c
 80040d0:	20001358 	.word	0x20001358

080040d4 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80040d4:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80040d6:	4b19      	ldr	r3, [pc, #100]	; (800413c <Vector84+0x68>)
 80040d8:	6819      	ldr	r1, [r3, #0]
 80040da:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 80040de:	0e09      	lsrs	r1, r1, #24
 80040e0:	f001 010e 	and.w	r1, r1, #14
 80040e4:	420a      	tst	r2, r1
 80040e6:	d006      	beq.n	80040f6 <Vector84+0x22>
 80040e8:	060a      	lsls	r2, r1, #24
 80040ea:	605a      	str	r2, [r3, #4]
 80040ec:	4a14      	ldr	r2, [pc, #80]	; (8004140 <Vector84+0x6c>)
 80040ee:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80040f0:	b10b      	cbz	r3, 80040f6 <Vector84+0x22>
 80040f2:	6b50      	ldr	r0, [r2, #52]	; 0x34
 80040f4:	4798      	blx	r3
 80040f6:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 80040f8:	4b12      	ldr	r3, [pc, #72]	; (8004144 <Vector84+0x70>)
 80040fa:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 80040fc:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_EPILOGUE();
 80040fe:	b1e2      	cbz	r2, 800413a <Vector84+0x66>
 8004100:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004104:	4a10      	ldr	r2, [pc, #64]	; (8004148 <Vector84+0x74>)
 8004106:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800410a:	6011      	str	r1, [r2, #0]
 800410c:	4a0f      	ldr	r2, [pc, #60]	; (800414c <Vector84+0x78>)
 800410e:	6812      	ldr	r2, [r2, #0]
 8004110:	b14a      	cbz	r2, 8004126 <Vector84+0x52>
 8004112:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004116:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800411a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800411e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004122:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004126:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800412a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800412e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004132:	f3bf 8f4f 	dsb	sy
 8004136:	f3bf 8f6f 	isb	sy
}
 800413a:	bd08      	pop	{r3, pc}
 800413c:	40020000 	.word	0x40020000
 8004140:	20000fe8 	.word	0x20000fe8
 8004144:	2000164c 	.word	0x2000164c
 8004148:	2000134c 	.word	0x2000134c
 800414c:	20001358 	.word	0x20001358

08004150 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8004150:	4a02      	ldr	r2, [pc, #8]	; (800415c <notify3+0xc>)
 8004152:	68d3      	ldr	r3, [r2, #12]
 8004154:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004158:	60d3      	str	r3, [r2, #12]
}
 800415a:	4770      	bx	lr
 800415c:	40004800 	.word	0x40004800

08004160 <usb_packet_write_from_buffer>:
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8004160:	4b0d      	ldr	r3, [pc, #52]	; (8004198 <usb_packet_write_from_buffer+0x38>)
                                         size_t n) {
 8004162:	b510      	push	{r4, lr}
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8004164:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004166:	0104      	lsls	r4, r0, #4
 8004168:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800416c:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8004170:	eb03 1000 	add.w	r0, r3, r0, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8004174:	58e3      	ldr	r3, [r4, r3]
 8004176:	4411      	add	r1, r2
 8004178:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800417c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8004180:	005b      	lsls	r3, r3, #1
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8004182:	6042      	str	r2, [r0, #4]
  while (i > 0) {
 8004184:	2a00      	cmp	r2, #0
 8004186:	eba1 0002 	sub.w	r0, r1, r2
 800418a:	dc00      	bgt.n	800418e <usb_packet_write_from_buffer+0x2e>
}
 800418c:	bd10      	pop	{r4, pc}
    w |= *buf++ << 8;
 800418e:	8800      	ldrh	r0, [r0, #0]
    i -= 2;
 8004190:	3a02      	subs	r2, #2
    w |= *buf++ << 8;
 8004192:	f843 0b04 	str.w	r0, [r3], #4
    i -= 2;
 8004196:	e7f5      	b.n	8004184 <usb_packet_write_from_buffer+0x24>
 8004198:	40005c00 	.word	0x40005c00

0800419c <_put.lto_priv.2>:
}

static msg_t _put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 800419c:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
 80041a0:	429a      	cmp	r2, r3
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 80041a2:	bf1f      	itttt	ne
 80041a4:	6842      	ldrne	r2, [r0, #4]
 80041a6:	54d1      	strbne	r1, [r2, r3]
  msp->eos += 1;
 80041a8:	68c3      	ldrne	r3, [r0, #12]
 80041aa:	3301      	addne	r3, #1
 80041ac:	bf1a      	itte	ne
 80041ae:	60c3      	strne	r3, [r0, #12]
  return MSG_OK;
 80041b0:	2000      	movne	r0, #0
    return MSG_RESET;
 80041b2:	f06f 0001 	mvneq.w	r0, #1
}
 80041b6:	4770      	bx	lr

080041b8 <_get.lto_priv.2>:

static msg_t _get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 80041b8:	e9d0 2303 	ldrd	r2, r3, [r0, #12]
 80041bc:	429a      	cmp	r2, r3
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 80041be:	bf1f      	itttt	ne
 80041c0:	6842      	ldrne	r2, [r0, #4]
 80041c2:	5cd2      	ldrbne	r2, [r2, r3]
  msp->offset += 1;
 80041c4:	3301      	addne	r3, #1
 80041c6:	6103      	strne	r3, [r0, #16]
  return b;
 80041c8:	bf14      	ite	ne
 80041ca:	4610      	movne	r0, r2
    return MSG_RESET;
 80041cc:	f06f 0001 	mvneq.w	r0, #1
}
 80041d0:	4770      	bx	lr

080041d2 <strToInt>:

    return (result>=base)? -1 : result;
}

int32_t strToInt(char* string, uint8_t base)
{
 80041d2:	b570      	push	{r4, r5, r6, lr}
    uint32_t value = 0;
    bool invert = false;
    unsigned int i = 0;

    if(string[0] == '\0') {
 80041d4:	7803      	ldrb	r3, [r0, #0]
 80041d6:	b1e3      	cbz	r3, 8004212 <strToInt+0x40>
        return -1;
    }

    if(string[0] == '-') {
 80041d8:	2b2d      	cmp	r3, #45	; 0x2d
 80041da:	d127      	bne.n	800422c <strToInt+0x5a>
        invert = true;
        i++;
 80041dc:	2201      	movs	r2, #1
    bool invert = false;
 80041de:	4614      	mov	r4, r2
 80041e0:	4402      	add	r2, r0
        invert = true;
 80041e2:	2000      	movs	r0, #0
 80041e4:	e01b      	b.n	800421e <strToInt+0x4c>
    }

    for(; string[i]; i++) {
        value *= base;
 80041e6:	fb00 f501 	mul.w	r5, r0, r1
    if(input >= '0' && input <= '9') {
 80041ea:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 80041ee:	b2c0      	uxtb	r0, r0
    input &=~ 0x20;
 80041f0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    if(input >= '0' && input <= '9') {
 80041f4:	2809      	cmp	r0, #9
    if(input >= 'A' && input <= 'Z') {
 80041f6:	f1a3 0641 	sub.w	r6, r3, #65	; 0x41
    int8_t result = -1;
 80041fa:	bf8c      	ite	hi
 80041fc:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
        result = input - '0';
 8004200:	b240      	sxtbls	r0, r0
    if(input >= 'A' && input <= 'Z') {
 8004202:	2e19      	cmp	r6, #25
 8004204:	d808      	bhi.n	8004218 <strToInt+0x46>
        result = input - 'A' + 10;
 8004206:	f1a3 0037 	sub.w	r0, r3, #55	; 0x37
 800420a:	b2c3      	uxtb	r3, r0
    if(result >= base) {
 800420c:	4299      	cmp	r1, r3
        result = input - 'A' + 10;
 800420e:	b240      	sxtb	r0, r0
    if(result >= base) {
 8004210:	d804      	bhi.n	800421c <strToInt+0x4a>
        return -1;
 8004212:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004216:	e008      	b.n	800422a <strToInt+0x58>

        int8_t ci = charToInt(string[i], base);
        if(ci < 0) {
 8004218:	1c43      	adds	r3, r0, #1
 800421a:	d006      	beq.n	800422a <strToInt+0x58>
            return -1;
        }

        value += ci;
 800421c:	4428      	add	r0, r5
    for(; string[i]; i++) {
 800421e:	f812 3b01 	ldrb.w	r3, [r2], #1
 8004222:	2b00      	cmp	r3, #0
 8004224:	d1df      	bne.n	80041e6 <strToInt+0x14>
    }

    return (invert)? -value : value;
 8004226:	b104      	cbz	r4, 800422a <strToInt+0x58>
 8004228:	4240      	negs	r0, r0
}
 800422a:	bd70      	pop	{r4, r5, r6, pc}
    unsigned int i = 0;
 800422c:	2200      	movs	r2, #0
 800422e:	e7d6      	b.n	80041de <strToInt+0xc>

08004230 <NVIC_SystemReset.lto_priv.0>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8004230:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004234:	4905      	ldr	r1, [pc, #20]	; (800424c <NVIC_SystemReset.lto_priv.0+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8004236:	4b06      	ldr	r3, [pc, #24]	; (8004250 <NVIC_SystemReset.lto_priv.0+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004238:	68ca      	ldr	r2, [r1, #12]
 800423a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800423e:	4313      	orrs	r3, r2
 8004240:	60cb      	str	r3, [r1, #12]
 8004242:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8004246:	bf00      	nop
 8004248:	e7fd      	b.n	8004246 <NVIC_SystemReset.lto_priv.0+0x16>
 800424a:	bf00      	nop
 800424c:	e000ed00 	.word	0xe000ed00
 8004250:	05fa0004 	.word	0x05fa0004

08004254 <shellCommandRegister>:
    {"license", cmdLicense, NULL},
    {"sanity", cmdSanity, NULL},
};

void shellCommandRegister(char* name, shellcmd_t function, void* user)
{
 8004254:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* -1 since there should be a final line with NULL, NULL, NULL */
    if(shellCommandsIndex >= sizeof(shellCommands)/sizeof(ShellCommand)-1) {
 8004256:	4d07      	ldr	r5, [pc, #28]	; (8004274 <shellCommandRegister+0x20>)
 8004258:	782b      	ldrb	r3, [r5, #0]
 800425a:	2b0d      	cmp	r3, #13
 800425c:	d808      	bhi.n	8004270 <shellCommandRegister+0x1c>
        return;
    }
    shellCommands[shellCommandsIndex].sc_name = name;
 800425e:	240c      	movs	r4, #12
 8004260:	435c      	muls	r4, r3
 8004262:	4f05      	ldr	r7, [pc, #20]	; (8004278 <shellCommandRegister+0x24>)
    shellCommands[shellCommandsIndex].sc_function = function;
    shellCommands[shellCommandsIndex].sc_user = user;
    shellCommandsIndex++;
 8004264:	3301      	adds	r3, #1
    shellCommands[shellCommandsIndex].sc_name = name;
 8004266:	193e      	adds	r6, r7, r4
    shellCommands[shellCommandsIndex].sc_user = user;
 8004268:	e9c6 1201 	strd	r1, r2, [r6, #4]
    shellCommands[shellCommandsIndex].sc_name = name;
 800426c:	5138      	str	r0, [r7, r4]
    shellCommandsIndex++;
 800426e:	702b      	strb	r3, [r5, #0]
}
 8004270:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004272:	bf00      	nop
 8004274:	20000910 	.word	0x20000910
 8004278:	2000085c 	.word	0x2000085c

0800427c <get_descriptor>:
        uint16_t lang)
{

    (void)usbp;
    (void)lang;
    switch (dtype) {
 800427c:	2902      	cmp	r1, #2
{
 800427e:	4613      	mov	r3, r2
 8004280:	b570      	push	{r4, r5, r6, lr}
    switch (dtype) {
 8004282:	d054      	beq.n	800432e <get_descriptor+0xb2>
 8004284:	2903      	cmp	r1, #3
 8004286:	d004      	beq.n	8004292 <get_descriptor+0x16>
        case USB_DESCRIPTOR_DEVICE:
            return &vcom_device_descriptor;
 8004288:	2901      	cmp	r1, #1
 800428a:	482b      	ldr	r0, [pc, #172]	; (8004338 <get_descriptor+0xbc>)
 800428c:	bf18      	it	ne
 800428e:	2000      	movne	r0, #0
                usbMakeSerial();
                return &vcom_strings[dindex];
            }
    }
    return NULL;
}
 8004290:	bd70      	pop	{r4, r5, r6, pc}
            if (dindex < 3)
 8004292:	2a02      	cmp	r2, #2
 8004294:	d803      	bhi.n	800429e <get_descriptor+0x22>
                return &vcom_strings[dindex];
 8004296:	4829      	ldr	r0, [pc, #164]	; (800433c <get_descriptor+0xc0>)
 8004298:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 800429c:	e7f8      	b.n	8004290 <get_descriptor+0x14>
            if (dindex == 3) {
 800429e:	2a03      	cmp	r2, #3
 80042a0:	d147      	bne.n	8004332 <get_descriptor+0xb6>
    if(serialString[0]) {
 80042a2:	4927      	ldr	r1, [pc, #156]	; (8004340 <get_descriptor+0xc4>)
 80042a4:	780a      	ldrb	r2, [r1, #0]
 80042a6:	b10a      	cbz	r2, 80042ac <get_descriptor+0x30>
                return &vcom_strings[dindex];
 80042a8:	4826      	ldr	r0, [pc, #152]	; (8004344 <get_descriptor+0xc8>)
 80042aa:	e7f1      	b.n	8004290 <get_descriptor+0x14>
    serialString[0] = USB_DESC_BYTE(sizeof(serialString));
 80042ac:	2084      	movs	r0, #132	; 0x84
    serialString[1] = USB_DESC_BYTE(USB_DESCRIPTOR_STRING);
 80042ae:	460c      	mov	r4, r1
    serialString[0] = USB_DESC_BYTE(sizeof(serialString));
 80042b0:	7008      	strb	r0, [r1, #0]
        serialString[3+i]=0;
 80042b2:	4616      	mov	r6, r2
 80042b4:	4608      	mov	r0, r1
    serialString[1] = USB_DESC_BYTE(USB_DESCRIPTOR_STRING);
 80042b6:	704b      	strb	r3, [r1, #1]
        serialString[2+i]=hexNibble((idReg[i>>2] >> (4*((i>>1)%2))) & 0xF);
 80042b8:	0893      	lsrs	r3, r2, #2
 80042ba:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80042be:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 80042c2:	f893 37e8 	ldrb.w	r3, [r3, #2024]	; 0x7e8
 80042c6:	f3c2 0540 	ubfx	r5, r2, #1, #1
 80042ca:	00ad      	lsls	r5, r5, #2
 80042cc:	412b      	asrs	r3, r5
 80042ce:	f003 030f 	and.w	r3, r3, #15
    if(a<10) {
 80042d2:	2b09      	cmp	r3, #9
 80042d4:	f102 0202 	add.w	r2, r2, #2
        return '0'+a;
 80042d8:	bf94      	ite	ls
 80042da:	3330      	addls	r3, #48	; 0x30
        return 'a'+a-10;
 80042dc:	3357      	addhi	r3, #87	; 0x57
    for(i=0; i<48; i+=2) {
 80042de:	2a30      	cmp	r2, #48	; 0x30
        serialString[2+i]=hexNibble((idReg[i>>2] >> (4*((i>>1)%2))) & 0xF);
 80042e0:	70a3      	strb	r3, [r4, #2]
        serialString[3+i]=0;
 80042e2:	70e6      	strb	r6, [r4, #3]
    for(i=0; i<48; i+=2) {
 80042e4:	f104 0402 	add.w	r4, r4, #2
 80042e8:	d1e6      	bne.n	80042b8 <get_descriptor+0x3c>
    serialString[50]='-';
 80042ea:	232d      	movs	r3, #45	; 0x2d
    serialString[51]=0;
 80042ec:	f881 6033 	strb.w	r6, [r1, #51]	; 0x33
    serialString[50]='-';
 80042f0:	f881 3032 	strb.w	r3, [r1, #50]	; 0x32
        serialString[53+i]=0;
 80042f4:	2400      	movs	r4, #0
    serialString[51]=0;
 80042f6:	2114      	movs	r1, #20
 80042f8:	4d13      	ldr	r5, [pc, #76]	; (8004348 <get_descriptor+0xcc>)
        serialString[52+i]=hexNibble(*buildId >> 4);
 80042fa:	f815 3f01 	ldrb.w	r3, [r5, #1]!
        serialString[53+i]=0;
 80042fe:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
        serialString[52+i]=hexNibble(*buildId >> 4);
 8004302:	091a      	lsrs	r2, r3, #4
    if(a<10) {
 8004304:	2b9f      	cmp	r3, #159	; 0x9f
        serialString[54+i]=hexNibble(*buildId & 0xF);
 8004306:	f003 030f 	and.w	r3, r3, #15
        return '0'+a;
 800430a:	bf94      	ite	ls
 800430c:	3230      	addls	r2, #48	; 0x30
        return 'a'+a-10;
 800430e:	3257      	addhi	r2, #87	; 0x57
    if(a<10) {
 8004310:	2b09      	cmp	r3, #9
        return '0'+a;
 8004312:	bf94      	ite	ls
 8004314:	3330      	addls	r3, #48	; 0x30
        return 'a'+a-10;
 8004316:	3357      	addhi	r3, #87	; 0x57
    for(i=0; i<80; i+=4) {
 8004318:	3901      	subs	r1, #1
        serialString[52+i]=hexNibble(*buildId >> 4);
 800431a:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
        serialString[54+i]=hexNibble(*buildId & 0xF);
 800431e:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
        serialString[55+i]=0;
 8004322:	f880 4037 	strb.w	r4, [r0, #55]	; 0x37
    for(i=0; i<80; i+=4) {
 8004326:	f100 0004 	add.w	r0, r0, #4
 800432a:	d1e6      	bne.n	80042fa <get_descriptor+0x7e>
 800432c:	e7bc      	b.n	80042a8 <get_descriptor+0x2c>
    switch (dtype) {
 800432e:	4807      	ldr	r0, [pc, #28]	; (800434c <get_descriptor+0xd0>)
 8004330:	e7ae      	b.n	8004290 <get_descriptor+0x14>
    return NULL;
 8004332:	2000      	movs	r0, #0
 8004334:	e7ac      	b.n	8004290 <get_descriptor+0x14>
 8004336:	bf00      	nop
 8004338:	0800cc2c 	.word	0x0800cc2c
 800433c:	0800ccdc 	.word	0x0800ccdc
 8004340:	20001231 	.word	0x20001231
 8004344:	0800ccf4 	.word	0x0800ccf4
 8004348:	0800cd67 	.word	0x0800cd67
 800434c:	0800cbe0 	.word	0x0800cbe0

08004350 <i2cSafeResultToString>:
}


const char* i2cSafeResultToString(i2c_result result)
{
    if(result == I2C_BUS_OK) return "OK";
 8004350:	4602      	mov	r2, r0
 8004352:	b188      	cbz	r0, 8004378 <i2cSafeResultToString+0x28>
    else if(result == I2C_BUS_TIMEOUT) return "Timeout";
 8004354:	1c41      	adds	r1, r0, #1
 8004356:	d011      	beq.n	800437c <i2cSafeResultToString+0x2c>
    else if(result == I2C_BUS_RESET) return "Transfer Error";
 8004358:	1c83      	adds	r3, r0, #2
 800435a:	d011      	beq.n	8004380 <i2cSafeResultToString+0x30>
    else if(result == I2C_BUS_STUCK_SCL_PULLED_LOW) return "SCL stuck low";
 800435c:	2801      	cmp	r0, #1
 800435e:	d011      	beq.n	8004384 <i2cSafeResultToString+0x34>
    else if(result == I2C_BUS_STUCK_SDA_PULLED_LOW) return "SDA stuck low";
 8004360:	2802      	cmp	r0, #2
 8004362:	d011      	beq.n	8004388 <i2cSafeResultToString+0x38>
    else if(result == I2C_BUS_STUCK_SCL_PULLED_HIGH) return "SCL stuck high";
 8004364:	2803      	cmp	r0, #3
 8004366:	d011      	beq.n	800438c <i2cSafeResultToString+0x3c>
    else if(result == I2C_BUS_STUCK_SDA_PULLED_HIGH) return "SDA stuck high";
 8004368:	2804      	cmp	r0, #4
 800436a:	d011      	beq.n	8004390 <i2cSafeResultToString+0x40>
    else if(result == I2C_BUS_STUCK_SHORTED_TOGETHER) return "SDA/SCL shorted together";
    else return "Unknown";
 800436c:	4b09      	ldr	r3, [pc, #36]	; (8004394 <i2cSafeResultToString+0x44>)
 800436e:	480a      	ldr	r0, [pc, #40]	; (8004398 <i2cSafeResultToString+0x48>)
 8004370:	2a05      	cmp	r2, #5
 8004372:	bf08      	it	eq
 8004374:	4618      	moveq	r0, r3
 8004376:	4770      	bx	lr
    if(result == I2C_BUS_OK) return "OK";
 8004378:	4808      	ldr	r0, [pc, #32]	; (800439c <i2cSafeResultToString+0x4c>)
 800437a:	4770      	bx	lr
    else if(result == I2C_BUS_TIMEOUT) return "Timeout";
 800437c:	4808      	ldr	r0, [pc, #32]	; (80043a0 <i2cSafeResultToString+0x50>)
 800437e:	4770      	bx	lr
    else if(result == I2C_BUS_RESET) return "Transfer Error";
 8004380:	4808      	ldr	r0, [pc, #32]	; (80043a4 <i2cSafeResultToString+0x54>)
 8004382:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SCL_PULLED_LOW) return "SCL stuck low";
 8004384:	4808      	ldr	r0, [pc, #32]	; (80043a8 <i2cSafeResultToString+0x58>)
 8004386:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SDA_PULLED_LOW) return "SDA stuck low";
 8004388:	4808      	ldr	r0, [pc, #32]	; (80043ac <i2cSafeResultToString+0x5c>)
 800438a:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SCL_PULLED_HIGH) return "SCL stuck high";
 800438c:	4808      	ldr	r0, [pc, #32]	; (80043b0 <i2cSafeResultToString+0x60>)
 800438e:	4770      	bx	lr
    else if(result == I2C_BUS_STUCK_SDA_PULLED_HIGH) return "SDA stuck high";
 8004390:	4808      	ldr	r0, [pc, #32]	; (80043b4 <i2cSafeResultToString+0x64>)
}
 8004392:	4770      	bx	lr
 8004394:	0800ba58 	.word	0x0800ba58
 8004398:	0800bab6 	.word	0x0800bab6
 800439c:	0800ba71 	.word	0x0800ba71
 80043a0:	0800ba74 	.word	0x0800ba74
 80043a4:	0800ba7c 	.word	0x0800ba7c
 80043a8:	0800ba8b 	.word	0x0800ba8b
 80043ac:	0800baa8 	.word	0x0800baa8
 80043b0:	0800ba99 	.word	0x0800ba99
 80043b4:	0800ba49 	.word	0x0800ba49

080043b8 <gpioGetPortDriver>:
    return &GPIODriverData.ports[index];
}

static const GPIOPort* gpioGetPortDriver(uint8_t index)
{
    if(index >= GPIODriverData.numPorts) {
 80043b8:	4b04      	ldr	r3, [pc, #16]	; (80043cc <gpioGetPortDriver+0x14>)
 80043ba:	791a      	ldrb	r2, [r3, #4]
 80043bc:	4282      	cmp	r2, r0
        return &gpioDummyPort;
    }

    return &GPIODriverData.ports[index];
 80043be:	bf83      	ittte	hi
 80043c0:	220c      	movhi	r2, #12
 80043c2:	681b      	ldrhi	r3, [r3, #0]
 80043c4:	fb02 3000 	mlahi	r0, r2, r0, r3
        return &gpioDummyPort;
 80043c8:	4801      	ldrls	r0, [pc, #4]	; (80043d0 <gpioGetPortDriver+0x18>)
}
 80043ca:	4770      	bx	lr
 80043cc:	20000928 	.word	0x20000928
 80043d0:	0800ca4c 	.word	0x0800ca4c

080043d4 <gpioGetPin>:

    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
}

bool gpioGetPin(uint16_t pin)
{
 80043d4:	b513      	push	{r0, r1, r4, lr}
 80043d6:	4604      	mov	r4, r0
    uint8_t gpioPort = pin >> 8;
    uint8_t gpioPin = pin & 0xff;

    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 80043d8:	0a00      	lsrs	r0, r0, #8
 80043da:	f7ff ffed 	bl	80043b8 <gpioGetPortDriver>

    uint32_t value = 0;
 80043de:	2300      	movs	r3, #0
 80043e0:	9301      	str	r3, [sp, #4]
    port->functions->getValue(port, &value);
 80043e2:	6883      	ldr	r3, [r0, #8]
 80043e4:	a901      	add	r1, sp, #4
 80043e6:	68db      	ldr	r3, [r3, #12]
 80043e8:	4798      	blx	r3

    return (value >> gpioPin) & 1;
 80043ea:	9801      	ldr	r0, [sp, #4]
 80043ec:	b2e4      	uxtb	r4, r4
 80043ee:	40e0      	lsrs	r0, r4
}
 80043f0:	f000 0001 	and.w	r0, r0, #1
 80043f4:	b002      	add	sp, #8
 80043f6:	bd10      	pop	{r4, pc}

080043f8 <gpioPortIoDisable>:

    return value;
}

void gpioPortIoDisable(uint8_t gpioPort, bool disable)
{
 80043f8:	b510      	push	{r4, lr}
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 80043fa:	f7ff ffdd 	bl	80043b8 <gpioGetPortDriver>

    if(port->functions->busIoDisable) {
 80043fe:	6883      	ldr	r3, [r0, #8]
 8004400:	691b      	ldr	r3, [r3, #16]
 8004402:	b113      	cbz	r3, 800440a <gpioPortIoDisable+0x12>
        port->functions->busIoDisable(port, disable);
    }
}
 8004404:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        port->functions->busIoDisable(port, disable);
 8004408:	4718      	bx	r3
}
 800440a:	bd10      	pop	{r4, pc}

0800440c <gpioCPUSetPinMode>:
{
    (void)driver;
    (void)pin;
    (void)pinMode;

    palSetPadMode((ioportid_t)driver->driver, pin, pinMode);
 800440c:	2301      	movs	r3, #1
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 800440e:	2a03      	cmp	r2, #3
{
 8004410:	b5f0      	push	{r4, r5, r6, r7, lr}
    palSetPadMode((ioportid_t)driver->driver, pin, pinMode);
 8004412:	6800      	ldr	r0, [r0, #0]
 8004414:	fa03 f101 	lsl.w	r1, r3, r1
 8004418:	d129      	bne.n	800446e <gpioCPUSetPinMode+0x62>
    port->BSRR = mask;
 800441a:	6101      	str	r1, [r0, #16]
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
 800441c:	4b16      	ldr	r3, [pc, #88]	; (8004478 <gpioCPUSetPinMode+0x6c>)
 800441e:	2608      	movs	r6, #8
 8004420:	5c9f      	ldrb	r7, [r3, r2]
  mh = ml = crh = crl = 0;
 8004422:	2300      	movs	r3, #0
 8004424:	461a      	mov	r2, r3
 8004426:	461d      	mov	r5, r3
 8004428:	461c      	mov	r4, r3
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
    crl <<= 4;
    crh <<= 4;
    if ((mask & 0x0080) == 0)
 800442a:	f011 0f80 	tst.w	r1, #128	; 0x80
    ml <<= 4;
 800442e:	ea4f 1404 	mov.w	r4, r4, lsl #4
    crl <<= 4;
 8004432:	ea4f 1202 	mov.w	r2, r2, lsl #4
    mh <<= 4;
 8004436:	ea4f 1505 	mov.w	r5, r5, lsl #4
    crh <<= 4;
 800443a:	ea4f 1303 	mov.w	r3, r3, lsl #4
      ml |= 0xf;
 800443e:	bf0c      	ite	eq
 8004440:	f044 040f 	orreq.w	r4, r4, #15
    else
      crl |= cfg;
 8004444:	433a      	orrne	r2, r7
    if ((mask & 0x8000) == 0)
 8004446:	f411 4f00 	tst.w	r1, #32768	; 0x8000
      mh |= 0xf;
 800444a:	bf0c      	ite	eq
 800444c:	f045 050f 	orreq.w	r5, r5, #15
    else
      crh |= cfg;
 8004450:	433b      	orrne	r3, r7
  for (i = 0; i < 8; i++) {
 8004452:	3e01      	subs	r6, #1
    mask <<= 1;
 8004454:	ea4f 0141 	mov.w	r1, r1, lsl #1
  for (i = 0; i < 8; i++) {
 8004458:	d1e7      	bne.n	800442a <gpioCPUSetPinMode+0x1e>
  }
  port->CRH = (port->CRH & mh) | crh;
 800445a:	6841      	ldr	r1, [r0, #4]
 800445c:	4029      	ands	r1, r5
 800445e:	430b      	orrs	r3, r1
 8004460:	6043      	str	r3, [r0, #4]
  port->CRL = (port->CRL & ml) | crl;
 8004462:	6803      	ldr	r3, [r0, #0]
 8004464:	4023      	ands	r3, r4
 8004466:	4313      	orrs	r3, r2
 8004468:	6003      	str	r3, [r0, #0]

    return true;
}
 800446a:	2001      	movs	r0, #1
 800446c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
 800446e:	2a04      	cmp	r2, #4
    port->BRR = mask;
 8004470:	bf08      	it	eq
 8004472:	6141      	streq	r1, [r0, #20]
 8004474:	e7d2      	b.n	800441c <gpioCPUSetPinMode+0x10>
 8004476:	bf00      	nop
 8004478:	0800c90c 	.word	0x0800c90c

0800447c <gpioCPUSetValue>:
    (void)driver;
    (void)pinsToChange;
    (void)newValue;

    //syssts_t sts = osalSysGetStatusAndLockX();
    palWriteGroup((ioportid_t)driver->driver, pinsToChange, 0, newValue);
 800447c:	6803      	ldr	r3, [r0, #0]
 800447e:	ea21 0002 	bic.w	r0, r1, r2
 8004482:	400a      	ands	r2, r1
 8004484:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8004488:	611a      	str	r2, [r3, #16]
    //osalSysRestoreStatusX(sts);

    return true;
}
 800448a:	2001      	movs	r0, #1
 800448c:	4770      	bx	lr

0800448e <gpioCPUGetValue>:
static bool gpioCPUGetValue(const GPIOPort* driver, uint32_t* value)
{
    (void)driver;
    (void)value;

    *value = palReadPort((ioportid_t)driver->driver);
 800448e:	6803      	ldr	r3, [r0, #0]

    return true;
}
 8004490:	2001      	movs	r0, #1
    *value = palReadPort((ioportid_t)driver->driver);
 8004492:	689b      	ldr	r3, [r3, #8]
 8004494:	600b      	str	r3, [r1, #0]
}
 8004496:	4770      	bx	lr

08004498 <gpioCPUInit>:
    .getValue = gpioCPUGetValue,
    .status = gpioCPUStatus
};

void gpioCPUInit(uint8_t gpioPortId, ioportid_t port)
{
 8004498:	b510      	push	{r4, lr}
    if(index >= GPIODriverData.numPorts) {
 800449a:	4a0c      	ldr	r2, [pc, #48]	; (80044cc <gpioCPUInit+0x34>)
 800449c:	7913      	ldrb	r3, [r2, #4]
 800449e:	4283      	cmp	r3, r0
 80044a0:	d912      	bls.n	80044c8 <gpioCPUInit+0x30>
    if(GPIODriverData.registeredPorts & _BV(index)) {
 80044a2:	6894      	ldr	r4, [r2, #8]
 80044a4:	fa24 f300 	lsr.w	r3, r4, r0
 80044a8:	07db      	lsls	r3, r3, #31
 80044aa:	d40d      	bmi.n	80044c8 <gpioCPUInit+0x30>
    GPIODriverData.registeredPorts |= _BV(index);
 80044ac:	2301      	movs	r3, #1
 80044ae:	4083      	lsls	r3, r0
 80044b0:	4323      	orrs	r3, r4
 80044b2:	6093      	str	r3, [r2, #8]
    return &GPIODriverData.ports[index];
 80044b4:	230c      	movs	r3, #12
 80044b6:	4358      	muls	r0, r3
 80044b8:	6813      	ldr	r3, [r2, #0]
    GPIOPort* portDriver = gpioRegisterPortDriver(gpioPortId);
    if(!portDriver) {
 80044ba:	181a      	adds	r2, r3, r0
 80044bc:	d004      	beq.n	80044c8 <gpioCPUInit+0x30>
        return;
    }

    portDriver->driver = port;
 80044be:	5019      	str	r1, [r3, r0]
    portDriver->functions = &gpioCPUFunctions;
 80044c0:	4b03      	ldr	r3, [pc, #12]	; (80044d0 <gpioCPUInit+0x38>)
 80044c2:	6093      	str	r3, [r2, #8]
    portDriver->numPins = 16;
 80044c4:	2310      	movs	r3, #16
 80044c6:	6053      	str	r3, [r2, #4]
}
 80044c8:	bd10      	pop	{r4, pc}
 80044ca:	bf00      	nop
 80044cc:	20000928 	.word	0x20000928
 80044d0:	0800ca1c 	.word	0x0800ca1c

080044d4 <converterTune>:
#include "converter.h"
#include "shell.h"
#include "chprintf.h"

bool converterTune(ConverterManager* converter, ConverterTuneRequest* tuneRequest)
{
 80044d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* Iterate over all bands */
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 80044d8:	f04f 0c14 	mov.w	ip, #20
{
 80044dc:	4604      	mov	r4, r0
 80044de:	460d      	mov	r5, r1
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 80044e0:	6941      	ldr	r1, [r0, #20]
 80044e2:	2000      	movs	r0, #0
 80044e4:	b2c6      	uxtb	r6, r0
 80044e6:	fb0c f806 	mul.w	r8, ip, r6
 80044ea:	eb01 0208 	add.w	r2, r1, r8
 80044ee:	6913      	ldr	r3, [r2, #16]
 80044f0:	b1b3      	cbz	r3, 8004520 <converterTune+0x4c>
        if(_BV(i) & converter-> disabledBands) {
 80044f2:	69e7      	ldr	r7, [r4, #28]
 80044f4:	40f7      	lsrs	r7, r6
 80044f6:	07fb      	lsls	r3, r7, #31
 80044f8:	d41d      	bmi.n	8004536 <converterTune+0x62>
            continue;
        }

        uint32_t tmpFreq = tuneRequest->inputFrequencyKHz;

        if((tuneRequest->forceBand && tuneRequest->bandId == i) ||
 80044fa:	7a2b      	ldrb	r3, [r5, #8]
 80044fc:	b1a3      	cbz	r3, 8004528 <converterTune+0x54>
 80044fe:	7a6b      	ldrb	r3, [r5, #9]
 8004500:	42b3      	cmp	r3, r6
 8004502:	d118      	bne.n	8004536 <converterTune+0x62>
                (!tuneRequest->forceBand &&
                 tmpFreq >= converter->bands[i].minFrequencyKHz &&
                 tmpFreq <= converter->bands[i].maxFrequencyKHz)) {


            if(converter->activeBand != 0xff && converter->activeBand != i) {
 8004504:	7e23      	ldrb	r3, [r4, #24]
 8004506:	2bff      	cmp	r3, #255	; 0xff
 8004508:	d117      	bne.n	800453a <converterTune+0x66>
                    converter->bands[converter->activeBand].functions->converterLeaveBand(converter,
                            &converter->bands[converter->activeBand]);
                }
            }

            converter->activeBand = i;
 800450a:	7626      	strb	r6, [r4, #24]
            tuneRequest->bandId = i;
 800450c:	726e      	strb	r6, [r5, #9]

            bool retVal = converter->bands[i].functions->converterTuneBand(converter, &converter->bands[i], tuneRequest);
 800450e:	6961      	ldr	r1, [r4, #20]
 8004510:	462a      	mov	r2, r5
 8004512:	4441      	add	r1, r8
 8004514:	690b      	ldr	r3, [r1, #16]
 8004516:	4620      	mov	r0, r4
 8004518:	681b      	ldr	r3, [r3, #0]
 800451a:	4798      	blx	r3
            if(retVal) {
 800451c:	4606      	mov	r6, r0
 800451e:	b9c0      	cbnz	r0, 8004552 <converterTune+0x7e>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8004520:	2600      	movs	r6, #0
        }
    }


    return false;
}
 8004522:	4630      	mov	r0, r6
 8004524:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        uint32_t tmpFreq = tuneRequest->inputFrequencyKHz;
 8004528:	682f      	ldr	r7, [r5, #0]
                (!tuneRequest->forceBand &&
 800452a:	6853      	ldr	r3, [r2, #4]
 800452c:	42bb      	cmp	r3, r7
 800452e:	d802      	bhi.n	8004536 <converterTune+0x62>
                 tmpFreq >= converter->bands[i].minFrequencyKHz &&
 8004530:	6893      	ldr	r3, [r2, #8]
 8004532:	42bb      	cmp	r3, r7
 8004534:	d2e6      	bcs.n	8004504 <converterTune+0x30>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8004536:	3001      	adds	r0, #1
 8004538:	e7d4      	b.n	80044e4 <converterTune+0x10>
            if(converter->activeBand != 0xff && converter->activeBand != i) {
 800453a:	42b3      	cmp	r3, r6
 800453c:	d0e5      	beq.n	800450a <converterTune+0x36>
                if(converter->bands[converter->activeBand].functions->converterLeaveBand) {
 800453e:	2214      	movs	r2, #20
 8004540:	fb02 1103 	mla	r1, r2, r3, r1
 8004544:	690b      	ldr	r3, [r1, #16]
 8004546:	685b      	ldr	r3, [r3, #4]
 8004548:	2b00      	cmp	r3, #0
 800454a:	d0de      	beq.n	800450a <converterTune+0x36>
                    converter->bands[converter->activeBand].functions->converterLeaveBand(converter,
 800454c:	4620      	mov	r0, r4
 800454e:	4798      	blx	r3
 8004550:	e7db      	b.n	800450a <converterTune+0x36>
                converter->currentTune = *tuneRequest;
 8004552:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004554:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8004556:	682b      	ldr	r3, [r5, #0]
 8004558:	6023      	str	r3, [r4, #0]
 800455a:	e7e2      	b.n	8004522 <converterTune+0x4e>

0800455c <converterTuneBypass>:


#include "converter.h"

static bool converterTuneBypass(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 800455c:	b510      	push	{r4, lr}
 800455e:	4614      	mov	r4, r2
    (void) band;

    converter->setConverterGpio(converter, 0);
 8004560:	6a03      	ldr	r3, [r0, #32]
 8004562:	2100      	movs	r1, #0
 8004564:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = tuneRequest->inputFrequencyKHz;
 8004566:	6823      	ldr	r3, [r4, #0]
    tuneRequest->spectrumInversion = false;

    return true;
}
 8004568:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = tuneRequest->inputFrequencyKHz;
 800456a:	60e3      	str	r3, [r4, #12]
    tuneRequest->spectrumInversion = false;
 800456c:	2300      	movs	r3, #0
 800456e:	7423      	strb	r3, [r4, #16]
}
 8004570:	bd10      	pop	{r4, pc}

08004572 <converterTuneSW>:

#include "converter.h"


static bool converterTuneSW(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 8004572:	b510      	push	{r4, lr}
 8004574:	4614      	mov	r4, r2
    (void) band;

    /* Switch on LO and Mixer */
    converter->setConverterGpio(converter, _BV(CONVERTER_IO_PIN_MIX_SW_EN) | _BV(CONVERTER_IO_PIN_MIX_SW_LO));
 8004576:	6a03      	ldr	r3, [r0, #32]
 8004578:	f44f 7180 	mov.w	r1, #256	; 0x100
 800457c:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = configCPU_CLOCK_HZ/1000 +tuneRequest->inputFrequencyKHz;
 800457e:	6823      	ldr	r3, [r4, #0]
    tuneRequest->spectrumInversion = false;

    return true;
}
 8004580:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = configCPU_CLOCK_HZ/1000 +tuneRequest->inputFrequencyKHz;
 8004582:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 8004586:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800458a:	60e3      	str	r3, [r4, #12]
    tuneRequest->spectrumInversion = false;
 800458c:	2300      	movs	r3, #0
 800458e:	7423      	strb	r3, [r4, #16]
}
 8004590:	bd10      	pop	{r4, pc}

08004592 <converterLeaveSW>:

static bool converterLeaveSW(const ConverterManager* converter, const ConverterBand* band)
{
 8004592:	b508      	push	{r3, lr}
    (void) converter;
    (void) band;

    /* Turn everything off */
    converter->setConverterGpio(converter, 0);
 8004594:	2100      	movs	r1, #0
 8004596:	6a03      	ldr	r3, [r0, #32]
 8004598:	4798      	blx	r3

    return true;
}
 800459a:	2001      	movs	r0, #1
 800459c:	bd08      	pop	{r3, pc}

0800459e <converterTuneSHF>:
 */

#include "converter.h"

static bool converterTuneSHF(const ConverterManager* converter, const ConverterBand* band, ConverterTuneRequest* tuneRequest)
{
 800459e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ConverterSHFConfig* config = (ConverterSHFConfig*)band->userData;
 80045a0:	68cd      	ldr	r5, [r1, #12]
{
 80045a2:	4616      	mov	r6, r2
    } else {
        ioOut |= _BV(CONVERTER_IO_PIN_ANT_HIGH);
    }*/

    if(config->useHighSideMixing) {
        loFreq = tuneRequest->inputFrequencyKHz + config->ifFrequencyKHz;
 80045a4:	6814      	ldr	r4, [r2, #0]
    if(config->useHighSideMixing) {
 80045a6:	782a      	ldrb	r2, [r5, #0]
{
 80045a8:	4607      	mov	r7, r0
        loFreq = tuneRequest->inputFrequencyKHz + config->ifFrequencyKHz;
 80045aa:	686b      	ldr	r3, [r5, #4]
    if(config->useHighSideMixing) {
 80045ac:	b1aa      	cbz	r2, 80045da <converterTuneSHF+0x3c>
        loFreq = tuneRequest->inputFrequencyKHz + config->ifFrequencyKHz;
 80045ae:	441c      	add	r4, r3
        }
        loFreq = tuneRequest->inputFrequencyKHz - config->ifFrequencyKHz;
    }

    /* If tuning failed, try to use LO/2 and enable doubler */
    if(!config->loTune(loFreq, 2)) {
 80045b0:	2102      	movs	r1, #2
 80045b2:	4620      	mov	r0, r4
 80045b4:	68ab      	ldr	r3, [r5, #8]
 80045b6:	4798      	blx	r3
 80045b8:	b9a8      	cbnz	r0, 80045e6 <converterTuneSHF+0x48>
        loFreq /= 2;
        ioOut |= _BV(CONVERTER_IO_PIN_MIX_X2);

        /* Try again, if it fails now it is fatal */
        if(!config->loTune(loFreq, 2)) {
 80045ba:	2102      	movs	r1, #2
 80045bc:	68ab      	ldr	r3, [r5, #8]
 80045be:	0860      	lsrs	r0, r4, #1
 80045c0:	4798      	blx	r3
 80045c2:	b160      	cbz	r0, 80045de <converterTuneSHF+0x40>
        ioOut |= _BV(CONVERTER_IO_PIN_MIX_X2);
 80045c4:	f44f 4140 	mov.w	r1, #49152	; 0xc000
            return false;
        }
    }

    converter->setConverterGpio(converter, ioOut);
 80045c8:	4638      	mov	r0, r7
 80045ca:	6a3b      	ldr	r3, [r7, #32]
 80045cc:	4798      	blx	r3

    tuneRequest->outputFrequencyKHz = config->ifFrequencyKHz;
 80045ce:	686b      	ldr	r3, [r5, #4]
    tuneRequest->spectrumInversion = config->useHighSideMixing;

    return true;
 80045d0:	2001      	movs	r0, #1
    tuneRequest->outputFrequencyKHz = config->ifFrequencyKHz;
 80045d2:	60f3      	str	r3, [r6, #12]
    tuneRequest->spectrumInversion = config->useHighSideMixing;
 80045d4:	782b      	ldrb	r3, [r5, #0]
 80045d6:	7433      	strb	r3, [r6, #16]
    return true;
 80045d8:	e002      	b.n	80045e0 <converterTuneSHF+0x42>
        if(tuneRequest->inputFrequencyKHz < config->ifFrequencyKHz) {
 80045da:	429c      	cmp	r4, r3
 80045dc:	d201      	bcs.n	80045e2 <converterTuneSHF+0x44>
            return false;
 80045de:	2000      	movs	r0, #0
}
 80045e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        loFreq = tuneRequest->inputFrequencyKHz - config->ifFrequencyKHz;
 80045e2:	1ae4      	subs	r4, r4, r3
 80045e4:	e7e4      	b.n	80045b0 <converterTuneSHF+0x12>
    uint32_t ioOut = _BV(CONVERTER_IO_PIN_MIX_EN);
 80045e6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80045ea:	e7ed      	b.n	80045c8 <converterTuneSHF+0x2a>

080045ec <converterLeaveSHF>:

static bool converterLeaveSHF(const ConverterManager* converter, const ConverterBand* band)
{
 80045ec:	b510      	push	{r4, lr}
 80045ee:	4604      	mov	r4, r0
    ConverterSHFConfig* config = (ConverterSHFConfig*)band->userData;

    /* Turn everything off */
    config->loTune(0, -127);
 80045f0:	68cb      	ldr	r3, [r1, #12]
 80045f2:	2000      	movs	r0, #0
 80045f4:	f06f 017e 	mvn.w	r1, #126	; 0x7e
 80045f8:	689b      	ldr	r3, [r3, #8]
 80045fa:	4798      	blx	r3
    converter->setConverterGpio(converter, 0);
 80045fc:	4620      	mov	r0, r4
 80045fe:	2100      	movs	r1, #0
 8004600:	6a23      	ldr	r3, [r4, #32]
 8004602:	4798      	blx	r3

    return true;
}
 8004604:	2001      	movs	r0, #1
 8004606:	bd10      	pop	{r4, pc}

08004608 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004608:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800460a:	4b0f      	ldr	r3, [pc, #60]	; (8004648 <prvInsertBlockIntoFreeList+0x40>)
 800460c:	461a      	mov	r2, r3
 800460e:	681b      	ldr	r3, [r3, #0]
 8004610:	4283      	cmp	r3, r0
 8004612:	d3fb      	bcc.n	800460c <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8004614:	6854      	ldr	r4, [r2, #4]
 8004616:	1911      	adds	r1, r2, r4
 8004618:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800461a:	bf01      	itttt	eq
 800461c:	6841      	ldreq	r1, [r0, #4]
 800461e:	4610      	moveq	r0, r2
 8004620:	1909      	addeq	r1, r1, r4
 8004622:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004624:	6844      	ldr	r4, [r0, #4]
 8004626:	1901      	adds	r1, r0, r4
 8004628:	428b      	cmp	r3, r1
 800462a:	d107      	bne.n	800463c <prvInsertBlockIntoFreeList+0x34>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800462c:	4907      	ldr	r1, [pc, #28]	; (800464c <prvInsertBlockIntoFreeList+0x44>)
 800462e:	6809      	ldr	r1, [r1, #0]
 8004630:	428b      	cmp	r3, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004632:	bf1f      	itttt	ne
 8004634:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004636:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004638:	1909      	addne	r1, r1, r4
 800463a:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800463c:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800463e:	6003      	str	r3, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004640:	bf18      	it	ne
 8004642:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8004644:	bd10      	pop	{r4, pc}
 8004646:	bf00      	nop
 8004648:	20001618 	.word	0x20001618
 800464c:	200011b0 	.word	0x200011b0

08004650 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8004650:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8004652:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8004654:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8004656:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004658:	689a      	ldr	r2, [r3, #8]
 800465a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800465c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800465e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8004660:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8004662:	3301      	adds	r3, #1
 8004664:	6003      	str	r3, [r0, #0]
}
 8004666:	4770      	bx	lr

08004668 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8004668:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800466a:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800466c:	1c63      	adds	r3, r4, #1
 800466e:	d10a      	bne.n	8004686 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8004670:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8004672:	685a      	ldr	r2, [r3, #4]
 8004674:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8004676:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8004678:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800467a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800467c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800467e:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8004680:	3301      	adds	r3, #1
 8004682:	6003      	str	r3, [r0, #0]
}
 8004684:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004686:	f100 0208 	add.w	r2, r0, #8
 800468a:	4613      	mov	r3, r2
 800468c:	6852      	ldr	r2, [r2, #4]
 800468e:	6815      	ldr	r5, [r2, #0]
 8004690:	42a5      	cmp	r5, r4
 8004692:	d9fa      	bls.n	800468a <vListInsert+0x22>
 8004694:	e7ed      	b.n	8004672 <vListInsert+0xa>

08004696 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8004696:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004698:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
 800469c:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800469e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80046a0:	6859      	ldr	r1, [r3, #4]
 80046a2:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80046a4:	bf08      	it	eq
 80046a6:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80046a8:	2200      	movs	r2, #0
 80046aa:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80046ac:	681a      	ldr	r2, [r3, #0]
 80046ae:	3a01      	subs	r2, #1
 80046b0:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80046b2:	6818      	ldr	r0, [r3, #0]
}
 80046b4:	4770      	bx	lr
	...

080046b8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 80046b8:	4a02      	ldr	r2, [pc, #8]	; (80046c4 <vTaskSuspendAll+0xc>)
 80046ba:	6813      	ldr	r3, [r2, #0]
 80046bc:	3301      	adds	r3, #1
 80046be:	6013      	str	r3, [r2, #0]
}
 80046c0:	4770      	bx	lr
 80046c2:	bf00      	nop
 80046c4:	2000136c 	.word	0x2000136c

080046c8 <prvGetExpectedIdleTime>:
			/* When port optimised task selection is used the uxTopReadyPriority
			variable is used as a bit map.  If bits other than the least
			significant bit are set then there are tasks that have a priority
			above the idle priority that are in the Ready state.  This takes
			care of the case where the co-operative scheduler is in use. */
			if( uxTopReadyPriority > uxLeastSignificantBit )
 80046c8:	4b09      	ldr	r3, [pc, #36]	; (80046f0 <prvGetExpectedIdleTime+0x28>)
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 80046ca:	4a0a      	ldr	r2, [pc, #40]	; (80046f4 <prvGetExpectedIdleTime+0x2c>)
			if( uxTopReadyPriority > uxLeastSignificantBit )
 80046cc:	681b      	ldr	r3, [r3, #0]
		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
 80046ce:	6812      	ldr	r2, [r2, #0]
 80046d0:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80046d2:	b958      	cbnz	r0, 80046ec <prvGetExpectedIdleTime+0x24>
		{
			xReturn = 0;
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
 80046d4:	4a08      	ldr	r2, [pc, #32]	; (80046f8 <prvGetExpectedIdleTime+0x30>)
 80046d6:	6812      	ldr	r2, [r2, #0]
 80046d8:	2a01      	cmp	r2, #1
 80046da:	d808      	bhi.n	80046ee <prvGetExpectedIdleTime+0x26>
			/* There are other idle priority tasks in the ready state.  If
			time slicing is used then the very next tick interrupt must be
			processed. */
			xReturn = 0;
		}
		else if( uxHigherPriorityReadyTasks != pdFALSE )
 80046dc:	2b01      	cmp	r3, #1
 80046de:	d806      	bhi.n	80046ee <prvGetExpectedIdleTime+0x26>
			configUSE_PREEMPTION is 0. */
			xReturn = 0;
		}
		else
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
 80046e0:	4b06      	ldr	r3, [pc, #24]	; (80046fc <prvGetExpectedIdleTime+0x34>)
 80046e2:	6818      	ldr	r0, [r3, #0]
 80046e4:	4b06      	ldr	r3, [pc, #24]	; (8004700 <prvGetExpectedIdleTime+0x38>)
 80046e6:	681b      	ldr	r3, [r3, #0]
 80046e8:	1ac0      	subs	r0, r0, r3
 80046ea:	4770      	bx	lr
			xReturn = 0;
 80046ec:	2000      	movs	r0, #0
		}

		return xReturn;
	}
 80046ee:	4770      	bx	lr
 80046f0:	20001374 	.word	0x20001374
 80046f4:	200011a8 	.word	0x200011a8
 80046f8:	200011b8 	.word	0x200011b8
 80046fc:	200015f8 	.word	0x200015f8
 8004700:	20001648 	.word	0x20001648

08004704 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004704:	4a06      	ldr	r2, [pc, #24]	; (8004720 <prvResetNextTaskUnblockTime+0x1c>)
 8004706:	6813      	ldr	r3, [r2, #0]
 8004708:	6819      	ldr	r1, [r3, #0]
 800470a:	4b06      	ldr	r3, [pc, #24]	; (8004724 <prvResetNextTaskUnblockTime+0x20>)
 800470c:	b919      	cbnz	r1, 8004716 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800470e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8004712:	601a      	str	r2, [r3, #0]
	}
}
 8004714:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004716:	6812      	ldr	r2, [r2, #0]
 8004718:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800471a:	68d2      	ldr	r2, [r2, #12]
 800471c:	6852      	ldr	r2, [r2, #4]
 800471e:	e7f8      	b.n	8004712 <prvResetNextTaskUnblockTime+0xe>
 8004720:	200011ac 	.word	0x200011ac
 8004724:	200015f8 	.word	0x200015f8

08004728 <xTaskIncrementTick>:
{
 8004728:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800472c:	4b38      	ldr	r3, [pc, #224]	; (8004810 <xTaskIncrementTick+0xe8>)
 800472e:	681b      	ldr	r3, [r3, #0]
 8004730:	2b00      	cmp	r3, #0
 8004732:	d166      	bne.n	8004802 <xTaskIncrementTick+0xda>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8004734:	4b37      	ldr	r3, [pc, #220]	; (8004814 <xTaskIncrementTick+0xec>)
 8004736:	681d      	ldr	r5, [r3, #0]
 8004738:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 800473a:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800473c:	b97d      	cbnz	r5, 800475e <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 800473e:	4b36      	ldr	r3, [pc, #216]	; (8004818 <xTaskIncrementTick+0xf0>)
 8004740:	681a      	ldr	r2, [r3, #0]
 8004742:	6812      	ldr	r2, [r2, #0]
 8004744:	b102      	cbz	r2, 8004748 <xTaskIncrementTick+0x20>
 8004746:	e7fe      	b.n	8004746 <xTaskIncrementTick+0x1e>
 8004748:	4a34      	ldr	r2, [pc, #208]	; (800481c <xTaskIncrementTick+0xf4>)
 800474a:	6819      	ldr	r1, [r3, #0]
 800474c:	6810      	ldr	r0, [r2, #0]
 800474e:	6018      	str	r0, [r3, #0]
 8004750:	6011      	str	r1, [r2, #0]
 8004752:	4a33      	ldr	r2, [pc, #204]	; (8004820 <xTaskIncrementTick+0xf8>)
 8004754:	6813      	ldr	r3, [r2, #0]
 8004756:	3301      	adds	r3, #1
 8004758:	6013      	str	r3, [r2, #0]
 800475a:	f7ff ffd3 	bl	8004704 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800475e:	4e31      	ldr	r6, [pc, #196]	; (8004824 <xTaskIncrementTick+0xfc>)
BaseType_t xSwitchRequired = pdFALSE;
 8004760:	2400      	movs	r4, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8004762:	6833      	ldr	r3, [r6, #0]
 8004764:	4f30      	ldr	r7, [pc, #192]	; (8004828 <xTaskIncrementTick+0x100>)
 8004766:	42ab      	cmp	r3, r5
 8004768:	d910      	bls.n	800478c <xTaskIncrementTick+0x64>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800476a:	2214      	movs	r2, #20
 800476c:	4b2f      	ldr	r3, [pc, #188]	; (800482c <xTaskIncrementTick+0x104>)
 800476e:	681b      	ldr	r3, [r3, #0]
 8004770:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004772:	4353      	muls	r3, r2
 8004774:	58fb      	ldr	r3, [r7, r3]
				xSwitchRequired = pdTRUE;
 8004776:	2b02      	cmp	r3, #2
 8004778:	bf28      	it	cs
 800477a:	2401      	movcs	r4, #1
		if( xYieldPending != pdFALSE )
 800477c:	4b2c      	ldr	r3, [pc, #176]	; (8004830 <xTaskIncrementTick+0x108>)
 800477e:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 8004780:	2b00      	cmp	r3, #0
}
 8004782:	bf0c      	ite	eq
 8004784:	4620      	moveq	r0, r4
 8004786:	2001      	movne	r0, #1
 8004788:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800478c:	f8df a088 	ldr.w	sl, [pc, #136]	; 8004818 <xTaskIncrementTick+0xf0>
					prvAddTaskToReadyList( pxTCB );
 8004790:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8004834 <xTaskIncrementTick+0x10c>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004794:	f8da 3000 	ldr.w	r3, [sl]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	b91b      	cbnz	r3, 80047a4 <xTaskIncrementTick+0x7c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800479c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80047a0:	6033      	str	r3, [r6, #0]
					break;
 80047a2:	e7e2      	b.n	800476a <xTaskIncrementTick+0x42>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80047a4:	f8da 3000 	ldr.w	r3, [sl]
 80047a8:	68db      	ldr	r3, [r3, #12]
 80047aa:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80047ae:	f8db 2004 	ldr.w	r2, [fp, #4]
					if( xConstTickCount < xItemValue )
 80047b2:	4295      	cmp	r5, r2
 80047b4:	d201      	bcs.n	80047ba <xTaskIncrementTick+0x92>
						xNextTaskUnblockTime = xItemValue;
 80047b6:	6032      	str	r2, [r6, #0]
						break;
 80047b8:	e7d7      	b.n	800476a <xTaskIncrementTick+0x42>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80047ba:	f10b 0804 	add.w	r8, fp, #4
 80047be:	4640      	mov	r0, r8
 80047c0:	f7ff ff69 	bl	8004696 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80047c4:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
 80047c8:	b11a      	cbz	r2, 80047d2 <xTaskIncrementTick+0xaa>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80047ca:	f10b 0018 	add.w	r0, fp, #24
 80047ce:	f7ff ff62 	bl	8004696 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80047d2:	2201      	movs	r2, #1
 80047d4:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
 80047d8:	f8d9 3000 	ldr.w	r3, [r9]
 80047dc:	4082      	lsls	r2, r0
 80047de:	431a      	orrs	r2, r3
 80047e0:	f8c9 2000 	str.w	r2, [r9]
 80047e4:	2214      	movs	r2, #20
 80047e6:	4641      	mov	r1, r8
 80047e8:	fb02 7000 	mla	r0, r2, r0, r7
 80047ec:	f7ff ff30 	bl	8004650 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80047f0:	4b0e      	ldr	r3, [pc, #56]	; (800482c <xTaskIncrementTick+0x104>)
 80047f2:	f8db 202c 	ldr.w	r2, [fp, #44]	; 0x2c
 80047f6:	6819      	ldr	r1, [r3, #0]
 80047f8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 80047fa:	429a      	cmp	r2, r3
 80047fc:	bf28      	it	cs
 80047fe:	2401      	movcs	r4, #1
 8004800:	e7c8      	b.n	8004794 <xTaskIncrementTick+0x6c>
		++uxPendedTicks;
 8004802:	4a0d      	ldr	r2, [pc, #52]	; (8004838 <xTaskIncrementTick+0x110>)
BaseType_t xSwitchRequired = pdFALSE;
 8004804:	2400      	movs	r4, #0
		++uxPendedTicks;
 8004806:	6813      	ldr	r3, [r2, #0]
 8004808:	3301      	adds	r3, #1
 800480a:	6013      	str	r3, [r2, #0]
 800480c:	e7b6      	b.n	800477c <xTaskIncrementTick+0x54>
 800480e:	bf00      	nop
 8004810:	2000136c 	.word	0x2000136c
 8004814:	20001648 	.word	0x20001648
 8004818:	200011ac 	.word	0x200011ac
 800481c:	200011b4 	.word	0x200011b4
 8004820:	200015fc 	.word	0x200015fc
 8004824:	200015f8 	.word	0x200015f8
 8004828:	200011b8 	.word	0x200011b8
 800482c:	200011a8 	.word	0x200011a8
 8004830:	2000164c 	.word	0x2000164c
 8004834:	20001374 	.word	0x20001374
 8004838:	20001364 	.word	0x20001364

0800483c <xTaskRemoveFromEventList>:
{
 800483c:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800483e:	68c3      	ldr	r3, [r0, #12]
 8004840:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8004842:	b904      	cbnz	r4, 8004846 <xTaskRemoveFromEventList+0xa>
 8004844:	e7fe      	b.n	8004844 <xTaskRemoveFromEventList+0x8>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8004846:	f104 0518 	add.w	r5, r4, #24
 800484a:	4628      	mov	r0, r5
 800484c:	f7ff ff23 	bl	8004696 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004850:	4b12      	ldr	r3, [pc, #72]	; (800489c <xTaskRemoveFromEventList+0x60>)
 8004852:	681b      	ldr	r3, [r3, #0]
 8004854:	b9f3      	cbnz	r3, 8004894 <xTaskRemoveFromEventList+0x58>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8004856:	1d25      	adds	r5, r4, #4
 8004858:	4628      	mov	r0, r5
 800485a:	f7ff ff1c 	bl	8004696 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800485e:	2301      	movs	r3, #1
 8004860:	490f      	ldr	r1, [pc, #60]	; (80048a0 <xTaskRemoveFromEventList+0x64>)
 8004862:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004864:	6808      	ldr	r0, [r1, #0]
 8004866:	4093      	lsls	r3, r2
 8004868:	4303      	orrs	r3, r0
 800486a:	2014      	movs	r0, #20
 800486c:	600b      	str	r3, [r1, #0]
 800486e:	4629      	mov	r1, r5
 8004870:	4b0c      	ldr	r3, [pc, #48]	; (80048a4 <xTaskRemoveFromEventList+0x68>)
 8004872:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004876:	f7ff feeb 	bl	8004650 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800487a:	4b0b      	ldr	r3, [pc, #44]	; (80048a8 <xTaskRemoveFromEventList+0x6c>)
 800487c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800487e:	681b      	ldr	r3, [r3, #0]
 8004880:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004882:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8004884:	bf85      	ittet	hi
 8004886:	2001      	movhi	r0, #1
 8004888:	4b08      	ldrhi	r3, [pc, #32]	; (80048ac <xTaskRemoveFromEventList+0x70>)
		xReturn = pdFALSE;
 800488a:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
 800488c:	6018      	strhi	r0, [r3, #0]
		prvResetNextTaskUnblockTime();
 800488e:	f7ff ff39 	bl	8004704 <prvResetNextTaskUnblockTime>
}
 8004892:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004894:	4629      	mov	r1, r5
 8004896:	4806      	ldr	r0, [pc, #24]	; (80048b0 <xTaskRemoveFromEventList+0x74>)
 8004898:	e7ed      	b.n	8004876 <xTaskRemoveFromEventList+0x3a>
 800489a:	bf00      	nop
 800489c:	2000136c 	.word	0x2000136c
 80048a0:	20001374 	.word	0x20001374
 80048a4:	200011b8 	.word	0x200011b8
 80048a8:	200011a8 	.word	0x200011a8
 80048ac:	2000164c 	.word	0x2000164c
 80048b0:	20001600 	.word	0x20001600

080048b4 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80048b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80048b6:	4b1a      	ldr	r3, [pc, #104]	; (8004920 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048b8:	4d1a      	ldr	r5, [pc, #104]	; (8004924 <prvAddCurrentTaskToDelayedList+0x70>)
{
 80048ba:	4606      	mov	r6, r0
const TickType_t xConstTickCount = xTickCount;
 80048bc:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048be:	6828      	ldr	r0, [r5, #0]
{
 80048c0:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80048c2:	3004      	adds	r0, #4
 80048c4:	f7ff fee7 	bl	8004696 <uxListRemove>
 80048c8:	b940      	cbnz	r0, 80048dc <prvAddCurrentTaskToDelayedList+0x28>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80048ca:	682a      	ldr	r2, [r5, #0]
 80048cc:	4916      	ldr	r1, [pc, #88]	; (8004928 <prvAddCurrentTaskToDelayedList+0x74>)
 80048ce:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80048d0:	2201      	movs	r2, #1
 80048d2:	680b      	ldr	r3, [r1, #0]
 80048d4:	4082      	lsls	r2, r0
 80048d6:	ea23 0302 	bic.w	r3, r3, r2
 80048da:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80048dc:	1c73      	adds	r3, r6, #1
 80048de:	d107      	bne.n	80048f0 <prvAddCurrentTaskToDelayedList+0x3c>
 80048e0:	b137      	cbz	r7, 80048f0 <prvAddCurrentTaskToDelayedList+0x3c>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80048e2:	6829      	ldr	r1, [r5, #0]
 80048e4:	4811      	ldr	r0, [pc, #68]	; (800492c <prvAddCurrentTaskToDelayedList+0x78>)
 80048e6:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80048e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80048ec:	f7ff beb0 	b.w	8004650 <vListInsertEnd>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80048f0:	682b      	ldr	r3, [r5, #0]
 80048f2:	19a4      	adds	r4, r4, r6
 80048f4:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 80048f6:	d307      	bcc.n	8004908 <prvAddCurrentTaskToDelayedList+0x54>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80048f8:	4b0d      	ldr	r3, [pc, #52]	; (8004930 <prvAddCurrentTaskToDelayedList+0x7c>)
 80048fa:	6818      	ldr	r0, [r3, #0]
 80048fc:	6829      	ldr	r1, [r5, #0]
}
 80048fe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004902:	3104      	adds	r1, #4
 8004904:	f7ff beb0 	b.w	8004668 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004908:	4b0a      	ldr	r3, [pc, #40]	; (8004934 <prvAddCurrentTaskToDelayedList+0x80>)
 800490a:	6818      	ldr	r0, [r3, #0]
 800490c:	6829      	ldr	r1, [r5, #0]
 800490e:	3104      	adds	r1, #4
 8004910:	f7ff feaa 	bl	8004668 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8004914:	4b08      	ldr	r3, [pc, #32]	; (8004938 <prvAddCurrentTaskToDelayedList+0x84>)
 8004916:	681a      	ldr	r2, [r3, #0]
 8004918:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 800491a:	bf88      	it	hi
 800491c:	601c      	strhi	r4, [r3, #0]
}
 800491e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004920:	20001648 	.word	0x20001648
 8004924:	200011a8 	.word	0x200011a8
 8004928:	20001374 	.word	0x20001374
 800492c:	20001620 	.word	0x20001620
 8004930:	200011b4 	.word	0x200011b4
 8004934:	200011ac 	.word	0x200011ac
 8004938:	200015f8 	.word	0x200015f8
 800493c:	00000000 	.word	0x00000000

08004940 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004940:	4b0b      	ldr	r3, [pc, #44]	; (8004970 <pxCurrentTCBConst2>)
 8004942:	6819      	ldr	r1, [r3, #0]
 8004944:	6808      	ldr	r0, [r1, #0]
 8004946:	c830      	ldmia	r0!, {r4, r5}
 8004948:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800494c:	f380 8809 	msr	PSP, r0
 8004950:	f3bf 8f6f 	isb	sy
 8004954:	f04f 0000 	mov.w	r0, #0
 8004958:	f380 8811 	msr	BASEPRI, r0
 800495c:	f04e 0e0d 	orr.w	lr, lr, #13
 8004960:	4770      	bx	lr
 8004962:	bf00      	nop
 8004964:	f3af 8000 	nop.w
 8004968:	f3af 8000 	nop.w
 800496c:	f3af 8000 	nop.w

08004970 <pxCurrentTCBConst2>:
 8004970:	200011a8 	.word	0x200011a8

08004974 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004974:	4806      	ldr	r0, [pc, #24]	; (8004990 <prvPortStartFirstTask+0x1c>)
 8004976:	6800      	ldr	r0, [r0, #0]
 8004978:	6800      	ldr	r0, [r0, #0]
 800497a:	f380 8808 	msr	MSP, r0
 800497e:	b662      	cpsie	i
 8004980:	b661      	cpsie	f
 8004982:	f3bf 8f4f 	dsb	sy
 8004986:	f3bf 8f6f 	isb	sy
 800498a:	df00      	svc	0
 800498c:	bf00      	nop
					"       dsb                       \n"
					"       isb                       \n"
					"       svc 0                     \n" /* System call to start first task. */
					"       nop                       \n"
				);
}
 800498e:	0000      	.short	0x0000
 8004990:	e000ed08 	.word	0xe000ed08

08004994 <vPortEnterCritical>:
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	if(!uxCriticalNesting) {
 8004994:	4a06      	ldr	r2, [pc, #24]	; (80049b0 <vPortEnterCritical+0x1c>)
 8004996:	6813      	ldr	r3, [r2, #0]
 8004998:	b93b      	cbnz	r3, 80049aa <vPortEnterCritical+0x16>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800499a:	f04f 01bf 	mov.w	r1, #191	; 0xbf
 800499e:	f381 8811 	msr	BASEPRI, r1
 80049a2:	f3bf 8f6f 	isb	sy
 80049a6:	f3bf 8f4f 	dsb	sy
		vPortRaiseBASEPRI();
	}

	uxCriticalNesting++;
 80049aa:	3301      	adds	r3, #1
 80049ac:	6013      	str	r3, [r2, #0]
}
 80049ae:	4770      	bx	lr
 80049b0:	20001358 	.word	0x20001358

080049b4 <vTaskEndScheduler>:
{
 80049b4:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 80049b6:	f7ff ffed 	bl	8004994 <vPortEnterCritical>
	xSchedulerRunning = pdFALSE;
 80049ba:	2200      	movs	r2, #0
 80049bc:	4b02      	ldr	r3, [pc, #8]	; (80049c8 <vTaskEndScheduler+0x14>)
 80049be:	601a      	str	r2, [r3, #0]
	asm volatile ("cpsid i");
 80049c0:	b672      	cpsid	i
	asm volatile ("cpsid f");
 80049c2:	b671      	cpsid	f
}
 80049c4:	bd08      	pop	{r3, pc}
 80049c6:	bf00      	nop
 80049c8:	20001614 	.word	0x20001614

080049cc <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 80049cc:	b510      	push	{r4, lr}
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static BaseType_t xPortIsCriticalSection( void ){
uint32_t ulBasePri;
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80049ce:	f3ef 8311 	mrs	r3, BASEPRI
	
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80049d2:	b12b      	cbz	r3, 80049e0 <ibqReleaseEmptyBufferS+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80049d4:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80049d8:	b12b      	cbz	r3, 80049e6 <ibqReleaseEmptyBufferS+0x1a>

  osalDbgCheckClassS();
 80049da:	f7ff ffeb 	bl	80049b4 <vTaskEndScheduler>
 80049de:	e7fe      	b.n	80049de <ibqReleaseEmptyBufferS+0x12>
 80049e0:	f7ff ffe8 	bl	80049b4 <vTaskEndScheduler>
 80049e4:	e7fe      	b.n	80049e4 <ibqReleaseEmptyBufferS+0x18>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80049e6:	68c3      	ldr	r3, [r0, #12]
 80049e8:	b913      	cbnz	r3, 80049f0 <ibqReleaseEmptyBufferS+0x24>
 80049ea:	f7ff ffe3 	bl	80049b4 <vTaskEndScheduler>
 80049ee:	e7fe      	b.n	80049ee <ibqReleaseEmptyBufferS+0x22>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 80049f0:	68c3      	ldr	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 80049f2:	69c2      	ldr	r2, [r0, #28]
  ibqp->bcounter--;
 80049f4:	3b01      	subs	r3, #1
 80049f6:	60c3      	str	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
 80049f8:	6943      	ldr	r3, [r0, #20]
 80049fa:	4413      	add	r3, r2
  if (ibqp->brdptr >= ibqp->btop) {
 80049fc:	6982      	ldr	r2, [r0, #24]
  ibqp->brdptr += ibqp->bsize;
 80049fe:	6143      	str	r3, [r0, #20]
  if (ibqp->brdptr >= ibqp->btop) {
 8004a00:	4293      	cmp	r3, r2
    ibqp->brdptr = ibqp->buffers;
 8004a02:	bf24      	itt	cs
 8004a04:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8004a06:	6143      	strcs	r3, [r0, #20]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004a08:	2300      	movs	r3, #0
 8004a0a:	6283      	str	r3, [r0, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004a0c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004a0e:	b113      	cbz	r3, 8004a16 <ibqReleaseEmptyBufferS+0x4a>
    ibqp->notify(ibqp);
  }
}
 8004a10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
 8004a14:	4718      	bx	r3
}
 8004a16:	bd10      	pop	{r4, pc}

08004a18 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004a18:	b508      	push	{r3, lr}
 8004a1a:	4603      	mov	r3, r0
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004a1c:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004a20:	b15a      	cbz	r2, 8004a3a <obqGetFullBufferI+0x22>

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004a22:	e9d0 2004 	ldrd	r2, r0, [r0, #16]
 8004a26:	4282      	cmp	r2, r0
 8004a28:	d101      	bne.n	8004a2e <obqGetFullBufferI+0x16>
 8004a2a:	68db      	ldr	r3, [r3, #12]
 8004a2c:	b91b      	cbnz	r3, 8004a36 <obqGetFullBufferI+0x1e>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8004a2e:	f850 3b04 	ldr.w	r3, [r0], #4
 8004a32:	600b      	str	r3, [r1, #0]

  return obqp->brdptr + sizeof (size_t);
}
 8004a34:	bd08      	pop	{r3, pc}
    return NULL;
 8004a36:	2000      	movs	r0, #0
 8004a38:	e7fc      	b.n	8004a34 <obqGetFullBufferI+0x1c>
  osalDbgCheckClassI();
 8004a3a:	f7ff ffbb 	bl	80049b4 <vTaskEndScheduler>
 8004a3e:	e7fe      	b.n	8004a3e <obqGetFullBufferI+0x26>

08004a40 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8004a40:	b510      	push	{r4, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004a42:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004a46:	b12b      	cbz	r3, 8004a54 <obqPostFullBufferS+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004a48:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 8004a4c:	b12b      	cbz	r3, 8004a5a <obqPostFullBufferS+0x1a>

  osalDbgCheckClassS();
 8004a4e:	f7ff ffb1 	bl	80049b4 <vTaskEndScheduler>
 8004a52:	e7fe      	b.n	8004a52 <obqPostFullBufferS+0x12>
 8004a54:	f7ff ffae 	bl	80049b4 <vTaskEndScheduler>
 8004a58:	e7fe      	b.n	8004a58 <obqPostFullBufferS+0x18>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8004a5a:	b119      	cbz	r1, 8004a64 <obqPostFullBufferS+0x24>
 8004a5c:	69c3      	ldr	r3, [r0, #28]
 8004a5e:	3b04      	subs	r3, #4
 8004a60:	4299      	cmp	r1, r3
 8004a62:	d902      	bls.n	8004a6a <obqPostFullBufferS+0x2a>
 8004a64:	f7ff ffa6 	bl	80049b4 <vTaskEndScheduler>
 8004a68:	e7fe      	b.n	8004a68 <obqPostFullBufferS+0x28>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8004a6a:	68c3      	ldr	r3, [r0, #12]
 8004a6c:	b913      	cbnz	r3, 8004a74 <obqPostFullBufferS+0x34>
 8004a6e:	f7ff ffa1 	bl	80049b4 <vTaskEndScheduler>
 8004a72:	e7fe      	b.n	8004a72 <obqPostFullBufferS+0x32>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8004a74:	6903      	ldr	r3, [r0, #16]
 8004a76:	6019      	str	r1, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8004a78:	68c2      	ldr	r2, [r0, #12]
 8004a7a:	3a01      	subs	r2, #1
 8004a7c:	60c2      	str	r2, [r0, #12]
  obqp->bwrptr += obqp->bsize;
 8004a7e:	69c2      	ldr	r2, [r0, #28]
 8004a80:	4413      	add	r3, r2
  if (obqp->bwrptr >= obqp->btop) {
 8004a82:	6982      	ldr	r2, [r0, #24]
  obqp->bwrptr += obqp->bsize;
 8004a84:	6103      	str	r3, [r0, #16]
  if (obqp->bwrptr >= obqp->btop) {
 8004a86:	4293      	cmp	r3, r2
    obqp->bwrptr = obqp->buffers;
 8004a88:	bf24      	itt	cs
 8004a8a:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
 8004a8c:	6103      	strcs	r3, [r0, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8004a8e:	2300      	movs	r3, #0
 8004a90:	6283      	str	r3, [r0, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8004a92:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004a94:	b113      	cbz	r3, 8004a9c <obqPostFullBufferS+0x5c>
    obqp->notify(obqp);
  }
}
 8004a96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    obqp->notify(obqp);
 8004a9a:	4718      	bx	r3
}
 8004a9c:	bd10      	pop	{r4, pc}
	...

08004aa0 <osalOsRescheduleS.lto_priv.1>:
{
 8004aa0:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004aa2:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004aa6:	b12b      	cbz	r3, 8004ab4 <osalOsRescheduleS.lto_priv.1+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004aa8:	f3ef 8205 	mrs	r2, IPSR
	if( ulCurrentInterrupt == 0 )
 8004aac:	b12a      	cbz	r2, 8004aba <osalOsRescheduleS.lto_priv.1+0x1a>
    osalDbgCheckClassS();
 8004aae:	f7ff ff81 	bl	80049b4 <vTaskEndScheduler>
 8004ab2:	e7fe      	b.n	8004ab2 <osalOsRescheduleS.lto_priv.1+0x12>
 8004ab4:	f7ff ff7e 	bl	80049b4 <vTaskEndScheduler>
 8004ab8:	e7fe      	b.n	8004ab8 <osalOsRescheduleS.lto_priv.1+0x18>
    UBaseType_t isIt = xYieldPending;
 8004aba:	4b04      	ldr	r3, [pc, #16]	; (8004acc <osalOsRescheduleS.lto_priv.1+0x2c>)
 8004abc:	6819      	ldr	r1, [r3, #0]
    xYieldPending = pdFALSE;
 8004abe:	601a      	str	r2, [r3, #0]
    if(uxYieldPending()) taskYIELD();
 8004ac0:	b119      	cbz	r1, 8004aca <osalOsRescheduleS.lto_priv.1+0x2a>
}
 8004ac2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004ac6:	f7ff b959 	b.w	8003d7c <Vector6C.part.0>
 8004aca:	bd08      	pop	{r3, pc}
 8004acc:	2000164c 	.word	0x2000164c

08004ad0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8004ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004ad2:	f3ef 8411 	mrs	r4, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004ad6:	b11c      	cbz	r4, 8004ae0 <usbStartReceiveI+0x10>
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004ad8:	b928      	cbnz	r0, 8004ae6 <usbStartReceiveI+0x16>
 8004ada:	f7ff ff6b 	bl	80049b4 <vTaskEndScheduler>
 8004ade:	e7fe      	b.n	8004ade <usbStartReceiveI+0xe>
  osalDbgCheckClassI();
 8004ae0:	f7ff ff68 	bl	80049b4 <vTaskEndScheduler>
 8004ae4:	e7fe      	b.n	8004ae4 <usbStartReceiveI+0x14>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004ae6:	2907      	cmp	r1, #7
 8004ae8:	d8f7      	bhi.n	8004ada <usbStartReceiveI+0xa>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8004aea:	2401      	movs	r4, #1
 8004aec:	8946      	ldrh	r6, [r0, #10]
 8004aee:	fa04 f501 	lsl.w	r5, r4, r1
 8004af2:	b2af      	uxth	r7, r5
 8004af4:	4035      	ands	r5, r6
 8004af6:	d002      	beq.n	8004afe <usbStartReceiveI+0x2e>
 8004af8:	f7ff ff5c 	bl	80049b4 <vTaskEndScheduler>
 8004afc:	e7fe      	b.n	8004afc <usbStartReceiveI+0x2c>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004afe:	433e      	orrs	r6, r7
 8004b00:	8146      	strh	r6, [r0, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8004b02:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8004b06:	68c6      	ldr	r6, [r0, #12]
 8004b08:	69b0      	ldr	r0, [r6, #24]
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8004b0a:	e9c0 3500 	strd	r3, r5, [r0]
  osp->rxbuf  = buf;
 8004b0e:	6082      	str	r2, [r0, #8]
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8004b10:	b1b3      	cbz	r3, 8004b40 <usbStartReceiveI+0x70>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8004b12:	8a72      	ldrh	r2, [r6, #18]
 8004b14:	3b01      	subs	r3, #1
 8004b16:	4413      	add	r3, r2
 8004b18:	fbb3 f3f2 	udiv	r3, r3, r2
 8004b1c:	b29b      	uxth	r3, r3
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8004b1e:	4a09      	ldr	r2, [pc, #36]	; (8004b44 <usbStartReceiveI+0x74>)
 8004b20:	8183      	strh	r3, [r0, #12]
 8004b22:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8004b26:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8004b2a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004b2e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8004b32:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004b36:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004b3a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8004b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    osp->rxpkts = 1;
 8004b40:	4623      	mov	r3, r4
 8004b42:	e7ec      	b.n	8004b1e <usbStartReceiveI+0x4e>
 8004b44:	40005c00 	.word	0x40005c00

08004b48 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8004b48:	b570      	push	{r4, r5, r6, lr}
 8004b4a:	460c      	mov	r4, r1
 8004b4c:	4611      	mov	r1, r2
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004b4e:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004b52:	b11a      	cbz	r2, 8004b5c <usbStartTransmitI+0x14>
  USBInEndpointState *isp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004b54:	b928      	cbnz	r0, 8004b62 <usbStartTransmitI+0x1a>
 8004b56:	f7ff ff2d 	bl	80049b4 <vTaskEndScheduler>
 8004b5a:	e7fe      	b.n	8004b5a <usbStartTransmitI+0x12>
  osalDbgCheckClassI();
 8004b5c:	f7ff ff2a 	bl	80049b4 <vTaskEndScheduler>
 8004b60:	e7fe      	b.n	8004b60 <usbStartTransmitI+0x18>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8004b62:	2c07      	cmp	r4, #7
 8004b64:	d8f7      	bhi.n	8004b56 <usbStartTransmitI+0xe>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8004b66:	2501      	movs	r5, #1
 8004b68:	8906      	ldrh	r6, [r0, #8]
 8004b6a:	40a5      	lsls	r5, r4
 8004b6c:	b2aa      	uxth	r2, r5
 8004b6e:	4035      	ands	r5, r6
 8004b70:	d002      	beq.n	8004b78 <usbStartTransmitI+0x30>
 8004b72:	f7ff ff1f 	bl	80049b4 <vTaskEndScheduler>
 8004b76:	e7fe      	b.n	8004b76 <usbStartTransmitI+0x2e>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004b78:	4316      	orrs	r6, r2
 8004b7a:	8106      	strh	r6, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8004b7c:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 8004b80:	68c2      	ldr	r2, [r0, #12]
 8004b82:	6950      	ldr	r0, [r2, #20]
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8004b84:	8a12      	ldrh	r2, [r2, #16]
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8004b86:	e9c0 3500 	strd	r3, r5, [r0]
 8004b8a:	429a      	cmp	r2, r3
 8004b8c:	bf28      	it	cs
 8004b8e:	461a      	movcs	r2, r3
  isp->txbuf  = buf;
 8004b90:	6081      	str	r1, [r0, #8]
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 8004b92:	60c2      	str	r2, [r0, #12]
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8004b94:	4620      	mov	r0, r4
 8004b96:	f7ff fae3 	bl	8004160 <usb_packet_write_from_buffer>

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8004b9a:	4a08      	ldr	r2, [pc, #32]	; (8004bbc <usbStartTransmitI+0x74>)
 8004b9c:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 8004ba0:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8004ba4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004ba8:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8004bac:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004bb0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004bb4:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8004bb8:	bd70      	pop	{r4, r5, r6, pc}
 8004bba:	bf00      	nop
 8004bbc:	40005c00 	.word	0x40005c00

08004bc0 <obnotify>:
static void obnotify(io_buffers_queue_t *bqp) {
 8004bc0:	b513      	push	{r0, r1, r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004bc2:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004bc4:	f8d4 3498 	ldr.w	r3, [r4, #1176]	; 0x498
 8004bc8:	681a      	ldr	r2, [r3, #0]
 8004bca:	7811      	ldrb	r1, [r2, #0]
 8004bcc:	2904      	cmp	r1, #4
 8004bce:	d116      	bne.n	8004bfe <obnotify+0x3e>
 8004bd0:	7d21      	ldrb	r1, [r4, #20]
 8004bd2:	2902      	cmp	r1, #2
 8004bd4:	d113      	bne.n	8004bfe <obnotify+0x3e>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004bd6:	7919      	ldrb	r1, [r3, #4]
 8004bd8:	2301      	movs	r3, #1
 8004bda:	8912      	ldrh	r2, [r2, #8]
 8004bdc:	408b      	lsls	r3, r1
 8004bde:	4213      	tst	r3, r2
 8004be0:	d10d      	bne.n	8004bfe <obnotify+0x3e>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8004be2:	a901      	add	r1, sp, #4
 8004be4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8004be8:	f7ff ff16 	bl	8004a18 <obqGetFullBufferI>
    if (buf != NULL) {
 8004bec:	4602      	mov	r2, r0
 8004bee:	b130      	cbz	r0, 8004bfe <obnotify+0x3e>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8004bf0:	f8d4 0498 	ldr.w	r0, [r4, #1176]	; 0x498
 8004bf4:	9b01      	ldr	r3, [sp, #4]
 8004bf6:	7901      	ldrb	r1, [r0, #4]
 8004bf8:	6800      	ldr	r0, [r0, #0]
 8004bfa:	f7ff ffa5 	bl	8004b48 <usbStartTransmitI>
}
 8004bfe:	b002      	add	sp, #8
 8004c00:	bd10      	pop	{r4, pc}
	...

08004c04 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8004c04:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheck(dmastp != NULL);
 8004c06:	b910      	cbnz	r0, 8004c0e <dmaStreamRelease+0xa>
 8004c08:	f7ff fed4 	bl	80049b4 <vTaskEndScheduler>
 8004c0c:	e7fe      	b.n	8004c0c <dmaStreamRelease+0x8>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
 8004c0e:	2501      	movs	r5, #1
 8004c10:	4a15      	ldr	r2, [pc, #84]	; (8004c68 <dmaStreamRelease+0x64>)
 8004c12:	7c46      	ldrb	r6, [r0, #17]
 8004c14:	6813      	ldr	r3, [r2, #0]
 8004c16:	fa05 f106 	lsl.w	r1, r5, r6
 8004c1a:	4219      	tst	r1, r3
 8004c1c:	d102      	bne.n	8004c24 <dmaStreamRelease+0x20>
 8004c1e:	f7ff fec9 	bl	80049b4 <vTaskEndScheduler>
 8004c22:	e7fe      	b.n	8004c22 <dmaStreamRelease+0x1e>
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004c24:	ea23 0301 	bic.w	r3, r3, r1

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004c28:	6881      	ldr	r1, [r0, #8]
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004c2a:	6013      	str	r3, [r2, #0]
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004c2c:	ea13 0401 	ands.w	r4, r3, r1
 8004c30:	d10b      	bne.n	8004c4a <dmaStreamRelease+0x46>
    nvicDisableVector(dmastp->vector);
 8004c32:	7c82      	ldrb	r2, [r0, #18]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8004c34:	f002 011f 	and.w	r1, r2, #31
 8004c38:	408d      	lsls	r5, r1
 8004c3a:	0950      	lsrs	r0, r2, #5
 8004c3c:	490b      	ldr	r1, [pc, #44]	; (8004c6c <dmaStreamRelease+0x68>)
 8004c3e:	3020      	adds	r0, #32
 8004c40:	f841 5020 	str.w	r5, [r1, r0, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8004c44:	4411      	add	r1, r2
 8004c46:	f881 4300 	strb.w	r4, [r1, #768]	; 0x300
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004c4a:	2100      	movs	r1, #0
 8004c4c:	4a08      	ldr	r2, [pc, #32]	; (8004c70 <dmaStreamRelease+0x6c>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8004c4e:	065b      	lsls	r3, r3, #25
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004c50:	f842 1036 	str.w	r1, [r2, r6, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8004c54:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8004c58:	6051      	str	r1, [r2, #4]
    rccDisableDMA1(false);
 8004c5a:	bf01      	itttt	eq
 8004c5c:	4a05      	ldreq	r2, [pc, #20]	; (8004c74 <dmaStreamRelease+0x70>)
 8004c5e:	6953      	ldreq	r3, [r2, #20]
 8004c60:	f023 0301 	biceq.w	r3, r3, #1
 8004c64:	6153      	streq	r3, [r2, #20]
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
    rccDisableDMA2(false);
  }
#endif
}
 8004c66:	bd70      	pop	{r4, r5, r6, pc}
 8004c68:	20001044 	.word	0x20001044
 8004c6c:	e000e100 	.word	0xe000e100
 8004c70:	20000fe8 	.word	0x20000fe8
 8004c74:	40021000 	.word	0x40021000

08004c78 <i2c_lld_serve_tx_end_irq>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004c78:	b508      	push	{r3, lr}
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004c7a:	070b      	lsls	r3, r1, #28
 8004c7c:	d502      	bpl.n	8004c84 <i2c_lld_serve_tx_end_irq+0xc>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8004c7e:	f7ff fe99 	bl	80049b4 <vTaskEndScheduler>
 8004c82:	e7fe      	b.n	8004c82 <i2c_lld_serve_tx_end_irq+0xa>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8004c84:	e9d0 311d 	ldrd	r3, r1, [r0, #116]	; 0x74
 8004c88:	6858      	ldr	r0, [r3, #4]
 8004c8a:	6802      	ldr	r2, [r0, #0]
 8004c8c:	f022 020f 	bic.w	r2, r2, #15
 8004c90:	6002      	str	r2, [r0, #0]
 8004c92:	7c18      	ldrb	r0, [r3, #16]
 8004c94:	681a      	ldr	r2, [r3, #0]
 8004c96:	230e      	movs	r3, #14
 8004c98:	4083      	lsls	r3, r0
 8004c9a:	6053      	str	r3, [r2, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8004c9c:	684b      	ldr	r3, [r1, #4]
 8004c9e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8004ca2:	604b      	str	r3, [r1, #4]
}
 8004ca4:	bd08      	pop	{r3, pc}

08004ca6 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8004ca6:	b508      	push	{r3, lr}

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004ca8:	070b      	lsls	r3, r1, #28
 8004caa:	d502      	bpl.n	8004cb2 <spi_lld_serve_tx_interrupt+0xc>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8004cac:	f7ff fe82 	bl	80049b4 <vTaskEndScheduler>
 8004cb0:	e7fe      	b.n	8004cb0 <spi_lld_serve_tx_interrupt+0xa>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 8004cb2:	bd08      	pop	{r3, pc}

08004cb4 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8004cb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8004cb6:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8004cba:	68de      	ldr	r6, [r3, #12]
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8004cbc:	6833      	ldr	r3, [r6, #0]
 8004cbe:	f003 0303 	and.w	r3, r3, #3
 8004cc2:	2b02      	cmp	r3, #2
 8004cc4:	d006      	beq.n	8004cd4 <usb_lld_init_endpoint+0x20>
 8004cc6:	2b03      	cmp	r3, #3
 8004cc8:	d022      	beq.n	8004d10 <usb_lld_init_endpoint+0x5c>
 8004cca:	2b01      	cmp	r3, #1
 8004ccc:	d123      	bne.n	8004d16 <usb_lld_init_endpoint+0x62>
    osalDbgAssert(false, "isochronous support disabled");
 8004cce:	f7ff fe71 	bl	80049b4 <vTaskEndScheduler>
 8004cd2:	e7fe      	b.n	8004cd2 <usb_lld_init_endpoint+0x1e>
    epr = EPR_EP_TYPE_BULK;
 8004cd4:	2200      	movs	r2, #0
  dp = USB_GET_DESCRIPTOR(ep);
 8004cd6:	4b33      	ldr	r3, [pc, #204]	; (8004da4 <usb_lld_init_endpoint+0xf0>)
 8004cd8:	ea4f 1c01 	mov.w	ip, r1, lsl #4
 8004cdc:	6d1c      	ldr	r4, [r3, #80]	; 0x50
  if (epcp->in_state != NULL) {
 8004cde:	6973      	ldr	r3, [r6, #20]
  dp = USB_GET_DESCRIPTOR(ep);
 8004ce0:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8004ce4:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
 8004ce8:	eb04 1501 	add.w	r5, r4, r1, lsl #4
  if (epcp->in_state != NULL) {
 8004cec:	b1d3      	cbz	r3, 8004d24 <usb_lld_init_endpoint+0x70>
    dp->TXCOUNT0 = 0;
 8004cee:	2300      	movs	r3, #0
 8004cf0:	606b      	str	r3, [r5, #4]
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8004cf2:	8a33      	ldrh	r3, [r6, #16]
  next = usbp->pmnext;
 8004cf4:	f8d0 7084 	ldr.w	r7, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8004cf8:	3301      	adds	r3, #1
 8004cfa:	f023 0301 	bic.w	r3, r3, #1
 8004cfe:	443b      	add	r3, r7
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d00:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  usbp->pmnext += (size + 1) & ~1;
 8004d04:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d08:	d908      	bls.n	8004d1c <usb_lld_init_endpoint+0x68>
 8004d0a:	f7ff fe53 	bl	80049b4 <vTaskEndScheduler>
 8004d0e:	e7fe      	b.n	8004d0e <usb_lld_init_endpoint+0x5a>
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8004d10:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8004d14:	e7df      	b.n	8004cd6 <usb_lld_init_endpoint+0x22>
    epr = EPR_EP_TYPE_CONTROL;
 8004d16:	f44f 7200 	mov.w	r2, #512	; 0x200
 8004d1a:	e7dc      	b.n	8004cd6 <usb_lld_init_endpoint+0x22>
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8004d1c:	f84c 7004 	str.w	r7, [ip, r4]
    epr |= EPR_STAT_TX_NAK;
 8004d20:	f042 0220 	orr.w	r2, r2, #32
  if (epcp->out_state != NULL) {
 8004d24:	69b3      	ldr	r3, [r6, #24]
 8004d26:	b32b      	cbz	r3, 8004d74 <usb_lld_init_endpoint+0xc0>
    if (epcp->out_maxsize > 62)
 8004d28:	8a74      	ldrh	r4, [r6, #18]
 8004d2a:	2c3e      	cmp	r4, #62	; 0x3e
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8004d2c:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
    if (epcp->out_maxsize > 62)
 8004d30:	d916      	bls.n	8004d60 <usb_lld_init_endpoint+0xac>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8004d32:	f043 031f 	orr.w	r3, r3, #31
 8004d36:	4e1c      	ldr	r6, [pc, #112]	; (8004da8 <usb_lld_init_endpoint+0xf4>)
 8004d38:	3301      	adds	r3, #1
 8004d3a:	115b      	asrs	r3, r3, #5
 8004d3c:	ea46 2383 	orr.w	r3, r6, r3, lsl #10
 8004d40:	b29b      	uxth	r3, r3
    dp->RXCOUNT0 = nblocks;
 8004d42:	60eb      	str	r3, [r5, #12]
  usbp->pmnext += (size + 1) & ~1;
 8004d44:	3401      	adds	r4, #1
  next = usbp->pmnext;
 8004d46:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 8004d4a:	f024 0401 	bic.w	r4, r4, #1
 8004d4e:	441c      	add	r4, r3
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d50:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  usbp->pmnext += (size + 1) & ~1;
 8004d54:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
  osalDbgAssert(usbp->pmnext <= STM32_USB_PMA_SIZE, "PMA overflow");
 8004d58:	d909      	bls.n	8004d6e <usb_lld_init_endpoint+0xba>
 8004d5a:	f7ff fe2b 	bl	80049b4 <vTaskEndScheduler>
 8004d5e:	e7fe      	b.n	8004d5e <usb_lld_init_endpoint+0xaa>
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 8004d60:	f043 0301 	orr.w	r3, r3, #1
 8004d64:	3301      	adds	r3, #1
 8004d66:	025b      	lsls	r3, r3, #9
 8004d68:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8004d6c:	e7e9      	b.n	8004d42 <usb_lld_init_endpoint+0x8e>
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8004d6e:	60ab      	str	r3, [r5, #8]
    epr |= EPR_STAT_RX_NAK;
 8004d70:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  EPR_SET(ep, epr | ep);
 8004d74:	f248 0480 	movw	r4, #32896	; 0x8080
  EPR_TOGGLE(ep, epr);
 8004d78:	f647 0370 	movw	r3, #30832	; 0x7870
  EPR_SET(ep, epr | ep);
 8004d7c:	ea42 0001 	orr.w	r0, r2, r1
 8004d80:	f420 4078 	bic.w	r0, r0, #63488	; 0xf800
 8004d84:	0089      	lsls	r1, r1, #2
 8004d86:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8004d8a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8004d8e:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 8004d92:	4320      	orrs	r0, r4
 8004d94:	6008      	str	r0, [r1, #0]
  EPR_TOGGLE(ep, epr);
 8004d96:	6808      	ldr	r0, [r1, #0]
 8004d98:	4013      	ands	r3, r2
 8004d9a:	4043      	eors	r3, r0
 8004d9c:	4323      	orrs	r3, r4
 8004d9e:	600b      	str	r3, [r1, #0]
}
 8004da0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004da2:	bf00      	nop
 8004da4:	40005c00 	.word	0x40005c00
 8004da8:	ffff8000 	.word	0xffff8000

08004dac <prvTaskExitError>:
{
 8004dac:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting == ~0UL );
 8004dae:	4b04      	ldr	r3, [pc, #16]	; (8004dc0 <prvTaskExitError+0x14>)
 8004db0:	681b      	ldr	r3, [r3, #0]
 8004db2:	3301      	adds	r3, #1
 8004db4:	d000      	beq.n	8004db8 <prvTaskExitError+0xc>
 8004db6:	e7fe      	b.n	8004db6 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 8004db8:	f7ff fdec 	bl	8004994 <vPortEnterCritical>
 8004dbc:	e7fe      	b.n	8004dbc <prvTaskExitError+0x10>
 8004dbe:	bf00      	nop
 8004dc0:	20001358 	.word	0x20001358

08004dc4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8004dc4:	4a04      	ldr	r2, [pc, #16]	; (8004dd8 <vPortExitCritical+0x14>)
 8004dc6:	6813      	ldr	r3, [r2, #0]
 8004dc8:	b903      	cbnz	r3, 8004dcc <vPortExitCritical+0x8>
 8004dca:	e7fe      	b.n	8004dca <vPortExitCritical+0x6>
	uxCriticalNesting--;
 8004dcc:	3b01      	subs	r3, #1
 8004dce:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004dd0:	b90b      	cbnz	r3, 8004dd6 <vPortExitCritical+0x12>
	__asm volatile( "msr basepri, %0" :: "r" ( ulNewMaskValue ));
 8004dd2:	f383 8811 	msr	BASEPRI, r3
	{
		vPortSetBASEPRI(0);
	}
}
 8004dd6:	4770      	bx	lr
 8004dd8:	20001358 	.word	0x20001358

08004ddc <osalSysUnlock.lto_priv.0>:
static inline void osalSysUnlockFromISR(void)
{
    taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
}

static inline void osalSysUnlock(void){
 8004ddc:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8004dde:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8004de2:	b12b      	cbz	r3, 8004df0 <osalSysUnlock.lto_priv.0+0x14>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004de4:	f3ef 8205 	mrs	r2, IPSR
	if( ulCurrentInterrupt == 0 )
 8004de8:	b12a      	cbz	r2, 8004df6 <osalSysUnlock.lto_priv.0+0x1a>
    osalDbgCheckClassS();
 8004dea:	f7ff fde3 	bl	80049b4 <vTaskEndScheduler>
 8004dee:	e7fe      	b.n	8004dee <osalSysUnlock.lto_priv.0+0x12>
 8004df0:	f7ff fde0 	bl	80049b4 <vTaskEndScheduler>
 8004df4:	e7fe      	b.n	8004df4 <osalSysUnlock.lto_priv.0+0x18>
    UBaseType_t isIt = xYieldPending;
 8004df6:	4b12      	ldr	r3, [pc, #72]	; (8004e40 <osalSysUnlock.lto_priv.0+0x64>)
 8004df8:	6819      	ldr	r1, [r3, #0]
    xYieldPending = pdFALSE;
 8004dfa:	601a      	str	r2, [r3, #0]
    if(uxYieldPending()) taskYIELD();
 8004dfc:	b1e1      	cbz	r1, 8004e38 <osalSysUnlock.lto_priv.0+0x5c>
 8004dfe:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004e02:	4a10      	ldr	r2, [pc, #64]	; (8004e44 <osalSysUnlock.lto_priv.0+0x68>)
 8004e04:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004e08:	6011      	str	r1, [r2, #0]
 8004e0a:	4a0f      	ldr	r2, [pc, #60]	; (8004e48 <osalSysUnlock.lto_priv.0+0x6c>)
 8004e0c:	6812      	ldr	r2, [r2, #0]
 8004e0e:	b14a      	cbz	r2, 8004e24 <osalSysUnlock.lto_priv.0+0x48>
 8004e10:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004e14:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004e18:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004e1c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004e20:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004e24:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004e28:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004e2c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004e30:	f3bf 8f4f 	dsb	sy
 8004e34:	f3bf 8f6f 	isb	sy
    osalOsRescheduleS();
    taskEXIT_CRITICAL();
}
 8004e38:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    taskEXIT_CRITICAL();
 8004e3c:	f7ff bfc2 	b.w	8004dc4 <vPortExitCritical>
 8004e40:	2000164c 	.word	0x2000164c
 8004e44:	2000134c 	.word	0x2000134c
 8004e48:	20001358 	.word	0x20001358

08004e4c <monitorKick>:
    xTaskCreate(taskPeriodicMon, "Monitor", stackSize, NULL, 1, &monThreadHandle );
}

void monitorKick(MonitorEntry* entry, bool active)
{
    if(entry->active == active) {
 8004e4c:	7c03      	ldrb	r3, [r0, #16]
{
 8004e4e:	b570      	push	{r4, r5, r6, lr}
    if(entry->active == active) {
 8004e50:	428b      	cmp	r3, r1
 8004e52:	d04f      	beq.n	8004ef4 <monitorKick+0xa8>
        return;
    }

    entry->active = active;

    if(monThreadHandle && active) {
 8004e54:	4b28      	ldr	r3, [pc, #160]	; (8004ef8 <monitorKick+0xac>)
    entry->active = active;
 8004e56:	7401      	strb	r1, [r0, #16]
    if(monThreadHandle && active) {
 8004e58:	681c      	ldr	r4, [r3, #0]
 8004e5a:	2c00      	cmp	r4, #0
 8004e5c:	d04a      	beq.n	8004ef4 <monitorKick+0xa8>
 8004e5e:	2900      	cmp	r1, #0
 8004e60:	d048      	beq.n	8004ef4 <monitorKick+0xa8>
		taskENTER_CRITICAL();
 8004e62:	f7ff fd97 	bl	8004994 <vPortEnterCritical>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8004e66:	2202      	movs	r2, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8004e68:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8004e6c:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
					pxTCB->ulNotifiedValue = ulValue;
 8004e70:	2201      	movs	r2, #1
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8004e72:	4293      	cmp	r3, r2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8004e74:	b2dd      	uxtb	r5, r3
					pxTCB->ulNotifiedValue = ulValue;
 8004e76:	6622      	str	r2, [r4, #96]	; 0x60
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8004e78:	d138      	bne.n	8004eec <monitorKick+0xa0>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8004e7a:	1d26      	adds	r6, r4, #4
 8004e7c:	4630      	mov	r0, r6
 8004e7e:	f7ff fc0a 	bl	8004696 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 8004e82:	2014      	movs	r0, #20
 8004e84:	4a1d      	ldr	r2, [pc, #116]	; (8004efc <monitorKick+0xb0>)
 8004e86:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004e88:	6811      	ldr	r1, [r2, #0]
 8004e8a:	409d      	lsls	r5, r3
 8004e8c:	430d      	orrs	r5, r1
 8004e8e:	6015      	str	r5, [r2, #0]
 8004e90:	4a1b      	ldr	r2, [pc, #108]	; (8004f00 <monitorKick+0xb4>)
 8004e92:	4631      	mov	r1, r6
 8004e94:	fb00 2003 	mla	r0, r0, r3, r2
 8004e98:	f7ff fbda 	bl	8004650 <vListInsertEnd>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8004e9c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004e9e:	b103      	cbz	r3, 8004ea2 <monitorKick+0x56>
 8004ea0:	e7fe      	b.n	8004ea0 <monitorKick+0x54>
					prvResetNextTaskUnblockTime();
 8004ea2:	f7ff fc2f 	bl	8004704 <prvResetNextTaskUnblockTime>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004ea6:	4b17      	ldr	r3, [pc, #92]	; (8004f04 <monitorKick+0xb8>)
 8004ea8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004eaa:	681b      	ldr	r3, [r3, #0]
 8004eac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004eae:	429a      	cmp	r2, r3
 8004eb0:	d91c      	bls.n	8004eec <monitorKick+0xa0>
					taskYIELD_IF_USING_PREEMPTION();
 8004eb2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004eb6:	4a14      	ldr	r2, [pc, #80]	; (8004f08 <monitorKick+0xbc>)
 8004eb8:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8004ebc:	6011      	str	r1, [r2, #0]
 8004ebe:	4a13      	ldr	r2, [pc, #76]	; (8004f0c <monitorKick+0xc0>)
 8004ec0:	6812      	ldr	r2, [r2, #0]
 8004ec2:	b14a      	cbz	r2, 8004ed8 <monitorKick+0x8c>
 8004ec4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004ec8:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8004ecc:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004ed0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8004ed4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8004ed8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004edc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004ee0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004ee4:	f3bf 8f4f 	dsb	sy
 8004ee8:	f3bf 8f6f 	isb	sy
        xTaskNotify(monThreadHandle, 1, eSetValueWithOverwrite);
    }
}
 8004eec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		taskEXIT_CRITICAL();
 8004ef0:	f7ff bf68 	b.w	8004dc4 <vPortExitCritical>
 8004ef4:	bd70      	pop	{r4, r5, r6, pc}
 8004ef6:	bf00      	nop
 8004ef8:	200011a4 	.word	0x200011a4
 8004efc:	20001374 	.word	0x20001374
 8004f00:	200011b8 	.word	0x200011b8
 8004f04:	200011a8 	.word	0x200011a8
 8004f08:	2000134c 	.word	0x2000134c
 8004f0c:	20001358 	.word	0x20001358

08004f10 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8004f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f14:	4604      	mov	r4, r0
	xYieldPending = pdTRUE;
 8004f16:	f04f 0801 	mov.w	r8, #1

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8004f1a:	f7ff fd3b 	bl	8004994 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8004f1e:	f890 5045 	ldrb.w	r5, [r0, #69]	; 0x45
 8004f22:	4f1b      	ldr	r7, [pc, #108]	; (8004f90 <prvUnlockQueue+0x80>)
 8004f24:	b26d      	sxtb	r5, r5
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004f26:	f100 0624 	add.w	r6, r0, #36	; 0x24
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004f2a:	2d00      	cmp	r5, #0
 8004f2c:	dc17      	bgt.n	8004f5e <prvUnlockQueue+0x4e>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8004f2e:	23ff      	movs	r3, #255	; 0xff
 8004f30:	f04f 0801 	mov.w	r8, #1
 8004f34:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004f38:	f7ff ff44 	bl	8004dc4 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004f3c:	f7ff fd2a 	bl	8004994 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004f40:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8004f44:	4f12      	ldr	r7, [pc, #72]	; (8004f90 <prvUnlockQueue+0x80>)
 8004f46:	b26d      	sxtb	r5, r5

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004f48:	f104 0610 	add.w	r6, r4, #16
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004f4c:	2d00      	cmp	r5, #0
 8004f4e:	dc12      	bgt.n	8004f76 <prvUnlockQueue+0x66>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004f50:	23ff      	movs	r3, #255	; 0xff
 8004f52:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8004f56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
 8004f5a:	f7ff bf33 	b.w	8004dc4 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004f5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004f60:	2b00      	cmp	r3, #0
 8004f62:	d0e4      	beq.n	8004f2e <prvUnlockQueue+0x1e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004f64:	4630      	mov	r0, r6
 8004f66:	f7ff fc69 	bl	800483c <xTaskRemoveFromEventList>
 8004f6a:	b108      	cbz	r0, 8004f70 <prvUnlockQueue+0x60>
 8004f6c:	f8c7 8000 	str.w	r8, [r7]
 8004f70:	3d01      	subs	r5, #1
 8004f72:	b26d      	sxtb	r5, r5
 8004f74:	e7d9      	b.n	8004f2a <prvUnlockQueue+0x1a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004f76:	6923      	ldr	r3, [r4, #16]
 8004f78:	2b00      	cmp	r3, #0
 8004f7a:	d0e9      	beq.n	8004f50 <prvUnlockQueue+0x40>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004f7c:	4630      	mov	r0, r6
 8004f7e:	f7ff fc5d 	bl	800483c <xTaskRemoveFromEventList>
 8004f82:	b108      	cbz	r0, 8004f88 <prvUnlockQueue+0x78>
 8004f84:	f8c7 8000 	str.w	r8, [r7]
 8004f88:	3d01      	subs	r5, #1
 8004f8a:	b26d      	sxtb	r5, r5
 8004f8c:	e7de      	b.n	8004f4c <prvUnlockQueue+0x3c>
 8004f8e:	bf00      	nop
 8004f90:	2000164c 	.word	0x2000164c

08004f94 <prvAddNewTaskToReadyList>:
{
 8004f94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	taskENTER_CRITICAL();
 8004f96:	f7ff fcfd 	bl	8004994 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8004f9a:	4a49      	ldr	r2, [pc, #292]	; (80050c0 <prvAddNewTaskToReadyList+0x12c>)
		if( pxCurrentTCB == NULL )
 8004f9c:	4f49      	ldr	r7, [pc, #292]	; (80050c4 <prvAddNewTaskToReadyList+0x130>)
		uxCurrentNumberOfTasks++;
 8004f9e:	6813      	ldr	r3, [r2, #0]
{
 8004fa0:	4604      	mov	r4, r0
		uxCurrentNumberOfTasks++;
 8004fa2:	3301      	adds	r3, #1
 8004fa4:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8004fa6:	683b      	ldr	r3, [r7, #0]
 8004fa8:	4847      	ldr	r0, [pc, #284]	; (80050c8 <prvAddNewTaskToReadyList+0x134>)
 8004faa:	2b00      	cmp	r3, #0
 8004fac:	d17d      	bne.n	80050aa <prvAddNewTaskToReadyList+0x116>
			pxCurrentTCB = pxNewTCB;
 8004fae:	603c      	str	r4, [r7, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004fb0:	6812      	ldr	r2, [r2, #0]
 8004fb2:	2a01      	cmp	r2, #1
 8004fb4:	d13f      	bne.n	8005036 <prvAddNewTaskToReadyList+0xa2>
 8004fb6:	4602      	mov	r2, r0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004fb8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004fbc:	f04f 0c14 	mov.w	ip, #20
 8004fc0:	461d      	mov	r5, r3
 8004fc2:	f102 0108 	add.w	r1, r2, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004fc6:	e9c2 1601 	strd	r1, r6, [r2, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fca:	e9c2 1103 	strd	r1, r1, [r2, #12]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004fce:	fb0c f103 	mul.w	r1, ip, r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004fd2:	3301      	adds	r3, #1
 8004fd4:	2b05      	cmp	r3, #5
 8004fd6:	5045      	str	r5, [r0, r1]
 8004fd8:	f102 0214 	add.w	r2, r2, #20
 8004fdc:	d1f1      	bne.n	8004fc2 <prvAddNewTaskToReadyList+0x2e>
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fde:	4a3b      	ldr	r2, [pc, #236]	; (80050cc <prvAddNewTaskToReadyList+0x138>)
 8004fe0:	f102 0308 	add.w	r3, r2, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004fe4:	e9c2 3601 	strd	r3, r6, [r2, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fe8:	e9c2 3303 	strd	r3, r3, [r2, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004fec:	4b38      	ldr	r3, [pc, #224]	; (80050d0 <prvAddNewTaskToReadyList+0x13c>)
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004fee:	6015      	str	r5, [r2, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004ff0:	f103 0108 	add.w	r1, r3, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8004ff4:	e9c3 1601 	strd	r1, r6, [r3, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004ff8:	e9c3 1103 	strd	r1, r1, [r3, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004ffc:	4935      	ldr	r1, [pc, #212]	; (80050d4 <prvAddNewTaskToReadyList+0x140>)
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8004ffe:	601d      	str	r5, [r3, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005000:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005004:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005006:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800500a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800500e:	4932      	ldr	r1, [pc, #200]	; (80050d8 <prvAddNewTaskToReadyList+0x144>)
 8005010:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005014:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005016:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800501a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800501e:	492f      	ldr	r1, [pc, #188]	; (80050dc <prvAddNewTaskToReadyList+0x148>)
 8005020:	f101 0c08 	add.w	ip, r1, #8
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8005024:	600d      	str	r5, [r1, #0]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005026:	e9c1 c601 	strd	ip, r6, [r1, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800502a:	e9c1 cc03 	strd	ip, ip, [r1, #12]
	pxDelayedTaskList = &xDelayedTaskList1;
 800502e:	492c      	ldr	r1, [pc, #176]	; (80050e0 <prvAddNewTaskToReadyList+0x14c>)
 8005030:	600a      	str	r2, [r1, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8005032:	4a2c      	ldr	r2, [pc, #176]	; (80050e4 <prvAddNewTaskToReadyList+0x150>)
 8005034:	6013      	str	r3, [r2, #0]
		uxTaskNumber++;
 8005036:	4a2c      	ldr	r2, [pc, #176]	; (80050e8 <prvAddNewTaskToReadyList+0x154>)
		prvAddTaskToReadyList( pxNewTCB );
 8005038:	492c      	ldr	r1, [pc, #176]	; (80050ec <prvAddNewTaskToReadyList+0x158>)
		uxTaskNumber++;
 800503a:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800503c:	680d      	ldr	r5, [r1, #0]
		uxTaskNumber++;
 800503e:	3301      	adds	r3, #1
 8005040:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8005042:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8005044:	2301      	movs	r3, #1
 8005046:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005048:	4093      	lsls	r3, r2
 800504a:	432b      	orrs	r3, r5
 800504c:	600b      	str	r3, [r1, #0]
 800504e:	2314      	movs	r3, #20
 8005050:	1d21      	adds	r1, r4, #4
 8005052:	fb03 0002 	mla	r0, r3, r2, r0
 8005056:	f7ff fafb 	bl	8004650 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800505a:	f7ff feb3 	bl	8004dc4 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800505e:	4b24      	ldr	r3, [pc, #144]	; (80050f0 <prvAddNewTaskToReadyList+0x15c>)
 8005060:	681b      	ldr	r3, [r3, #0]
 8005062:	b30b      	cbz	r3, 80050a8 <prvAddNewTaskToReadyList+0x114>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8005064:	683b      	ldr	r3, [r7, #0]
 8005066:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005068:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800506a:	429a      	cmp	r2, r3
 800506c:	d21c      	bcs.n	80050a8 <prvAddNewTaskToReadyList+0x114>
			taskYIELD_IF_USING_PREEMPTION();
 800506e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005072:	4a20      	ldr	r2, [pc, #128]	; (80050f4 <prvAddNewTaskToReadyList+0x160>)
 8005074:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005078:	6011      	str	r1, [r2, #0]
 800507a:	4a1f      	ldr	r2, [pc, #124]	; (80050f8 <prvAddNewTaskToReadyList+0x164>)
 800507c:	6812      	ldr	r2, [r2, #0]
 800507e:	b14a      	cbz	r2, 8005094 <prvAddNewTaskToReadyList+0x100>
 8005080:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005084:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8005088:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800508c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005090:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8005094:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005098:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800509c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80050a0:	f3bf 8f4f 	dsb	sy
 80050a4:	f3bf 8f6f 	isb	sy
}
 80050a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xSchedulerRunning == pdFALSE )
 80050aa:	4b11      	ldr	r3, [pc, #68]	; (80050f0 <prvAddNewTaskToReadyList+0x15c>)
 80050ac:	681b      	ldr	r3, [r3, #0]
 80050ae:	2b00      	cmp	r3, #0
 80050b0:	d1c1      	bne.n	8005036 <prvAddNewTaskToReadyList+0xa2>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80050b2:	683b      	ldr	r3, [r7, #0]
 80050b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80050b6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80050b8:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 80050ba:	bf98      	it	ls
 80050bc:	603c      	strls	r4, [r7, #0]
 80050be:	e7ba      	b.n	8005036 <prvAddNewTaskToReadyList+0xa2>
 80050c0:	2000135c 	.word	0x2000135c
 80050c4:	200011a8 	.word	0x200011a8
 80050c8:	200011b8 	.word	0x200011b8
 80050cc:	2000137c 	.word	0x2000137c
 80050d0:	20001390 	.word	0x20001390
 80050d4:	20001600 	.word	0x20001600
 80050d8:	20001634 	.word	0x20001634
 80050dc:	20001620 	.word	0x20001620
 80050e0:	200011ac 	.word	0x200011ac
 80050e4:	200011b4 	.word	0x200011b4
 80050e8:	20001370 	.word	0x20001370
 80050ec:	20001374 	.word	0x20001374
 80050f0:	20001614 	.word	0x20001614
 80050f4:	2000134c 	.word	0x2000134c
 80050f8:	20001358 	.word	0x20001358

080050fc <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 80050fc:	4837      	ldr	r0, [pc, #220]	; (80051dc <xTaskResumeAll+0xe0>)
{
 80050fe:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8005102:	6803      	ldr	r3, [r0, #0]
 8005104:	b903      	cbnz	r3, 8005108 <xTaskResumeAll+0xc>
 8005106:	e7fe      	b.n	8005106 <xTaskResumeAll+0xa>
	taskENTER_CRITICAL();
 8005108:	f7ff fc44 	bl	8004994 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800510c:	6803      	ldr	r3, [r0, #0]
 800510e:	3b01      	subs	r3, #1
 8005110:	6003      	str	r3, [r0, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005112:	6804      	ldr	r4, [r0, #0]
 8005114:	b124      	cbz	r4, 8005120 <xTaskResumeAll+0x24>
BaseType_t xAlreadyYielded = pdFALSE;
 8005116:	2000      	movs	r0, #0
	taskEXIT_CRITICAL();
 8005118:	f7ff fe54 	bl	8004dc4 <vPortExitCritical>
}
 800511c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8005120:	4b2f      	ldr	r3, [pc, #188]	; (80051e0 <xTaskResumeAll+0xe4>)
 8005122:	681b      	ldr	r3, [r3, #0]
 8005124:	2b00      	cmp	r3, #0
 8005126:	d0f6      	beq.n	8005116 <xTaskResumeAll+0x1a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8005128:	4d2e      	ldr	r5, [pc, #184]	; (80051e4 <xTaskResumeAll+0xe8>)
					prvAddTaskToReadyList( pxTCB );
 800512a:	4e2f      	ldr	r6, [pc, #188]	; (80051e8 <xTaskResumeAll+0xec>)
 800512c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80051ec <xTaskResumeAll+0xf0>
 8005130:	e01f      	b.n	8005172 <xTaskResumeAll+0x76>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005132:	68eb      	ldr	r3, [r5, #12]
					prvAddTaskToReadyList( pxTCB );
 8005134:	2701      	movs	r7, #1
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005136:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005138:	f104 0904 	add.w	r9, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800513c:	f104 0018 	add.w	r0, r4, #24
 8005140:	f7ff faa9 	bl	8004696 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005144:	4648      	mov	r0, r9
 8005146:	f7ff faa6 	bl	8004696 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800514a:	2014      	movs	r0, #20
 800514c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800514e:	6831      	ldr	r1, [r6, #0]
 8005150:	fa07 f302 	lsl.w	r3, r7, r2
 8005154:	430b      	orrs	r3, r1
 8005156:	fb00 8002 	mla	r0, r0, r2, r8
 800515a:	4649      	mov	r1, r9
 800515c:	6033      	str	r3, [r6, #0]
 800515e:	f7ff fa77 	bl	8004650 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005162:	4b23      	ldr	r3, [pc, #140]	; (80051f0 <xTaskResumeAll+0xf4>)
 8005164:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005166:	681b      	ldr	r3, [r3, #0]
 8005168:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800516a:	429a      	cmp	r2, r3
 800516c:	d301      	bcc.n	8005172 <xTaskResumeAll+0x76>
						xYieldPending = pdTRUE;
 800516e:	4b21      	ldr	r3, [pc, #132]	; (80051f4 <xTaskResumeAll+0xf8>)
 8005170:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8005172:	682b      	ldr	r3, [r5, #0]
 8005174:	2b00      	cmp	r3, #0
 8005176:	d1dc      	bne.n	8005132 <xTaskResumeAll+0x36>
				if( pxTCB != NULL )
 8005178:	b10c      	cbz	r4, 800517e <xTaskResumeAll+0x82>
					prvResetNextTaskUnblockTime();
 800517a:	f7ff fac3 	bl	8004704 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800517e:	4d1e      	ldr	r5, [pc, #120]	; (80051f8 <xTaskResumeAll+0xfc>)
 8005180:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8005182:	b144      	cbz	r4, 8005196 <xTaskResumeAll+0x9a>
								xYieldPending = pdTRUE;
 8005184:	2701      	movs	r7, #1
 8005186:	4e1b      	ldr	r6, [pc, #108]	; (80051f4 <xTaskResumeAll+0xf8>)
							if( xTaskIncrementTick() != pdFALSE )
 8005188:	f7ff face 	bl	8004728 <xTaskIncrementTick>
 800518c:	b100      	cbz	r0, 8005190 <xTaskResumeAll+0x94>
								xYieldPending = pdTRUE;
 800518e:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8005190:	3c01      	subs	r4, #1
 8005192:	d1f9      	bne.n	8005188 <xTaskResumeAll+0x8c>
						uxPendedTicks = 0;
 8005194:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8005196:	4b17      	ldr	r3, [pc, #92]	; (80051f4 <xTaskResumeAll+0xf8>)
 8005198:	681b      	ldr	r3, [r3, #0]
 800519a:	2b00      	cmp	r3, #0
 800519c:	d0bb      	beq.n	8005116 <xTaskResumeAll+0x1a>
					taskYIELD_IF_USING_PREEMPTION();
 800519e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80051a2:	4a16      	ldr	r2, [pc, #88]	; (80051fc <xTaskResumeAll+0x100>)
 80051a4:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80051a8:	6011      	str	r1, [r2, #0]
 80051aa:	4a15      	ldr	r2, [pc, #84]	; (8005200 <xTaskResumeAll+0x104>)
 80051ac:	6812      	ldr	r2, [r2, #0]
 80051ae:	b14a      	cbz	r2, 80051c4 <xTaskResumeAll+0xc8>
 80051b0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80051b4:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80051b8:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80051bc:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80051c0:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80051c4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80051c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80051cc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80051d0:	f3bf 8f4f 	dsb	sy
 80051d4:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 80051d8:	2001      	movs	r0, #1
 80051da:	e79d      	b.n	8005118 <xTaskResumeAll+0x1c>
 80051dc:	2000136c 	.word	0x2000136c
 80051e0:	2000135c 	.word	0x2000135c
 80051e4:	20001600 	.word	0x20001600
 80051e8:	20001374 	.word	0x20001374
 80051ec:	200011b8 	.word	0x200011b8
 80051f0:	200011a8 	.word	0x200011a8
 80051f4:	2000164c 	.word	0x2000164c
 80051f8:	20001364 	.word	0x20001364
 80051fc:	2000134c 	.word	0x2000134c
 8005200:	20001358 	.word	0x20001358

08005204 <pvPortMalloc>:
{
 8005204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005208:	4604      	mov	r4, r0
		if( pxEnd == NULL )
 800520a:	4839      	ldr	r0, [pc, #228]	; (80052f0 <pvPortMalloc+0xec>)
	vTaskSuspendAll();
 800520c:	f7ff fa54 	bl	80046b8 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8005210:	6803      	ldr	r3, [r0, #0]
 8005212:	4d38      	ldr	r5, [pc, #224]	; (80052f4 <pvPortMalloc+0xf0>)
 8005214:	bb0b      	cbnz	r3, 800525a <pvPortMalloc+0x56>
size_t xTotalHeapSize = __heap_end__ - __heap_base__;
 8005216:	4938      	ldr	r1, [pc, #224]	; (80052f8 <pvPortMalloc+0xf4>)
 8005218:	4b38      	ldr	r3, [pc, #224]	; (80052fc <pvPortMalloc+0xf8>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800521a:	074e      	lsls	r6, r1, #29
	uxAddress = ( size_t ) __heap_base__;	
 800521c:	460a      	mov	r2, r1
size_t xTotalHeapSize = __heap_end__ - __heap_base__;
 800521e:	eba3 0301 	sub.w	r3, r3, r1
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8005222:	d005      	beq.n	8005230 <pvPortMalloc+0x2c>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005224:	3107      	adds	r1, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005226:	f021 0107 	bic.w	r1, r1, #7
 800522a:	4413      	add	r3, r2
 800522c:	460a      	mov	r2, r1
		xTotalHeapSize -= uxAddress - ( size_t ) __heap_base__;
 800522e:	1a5b      	subs	r3, r3, r1
	xStart.xBlockSize = ( size_t ) 0;
 8005230:	2100      	movs	r1, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8005232:	4413      	add	r3, r2
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005234:	4e32      	ldr	r6, [pc, #200]	; (8005300 <pvPortMalloc+0xfc>)
	uxAddress -= xHeapStructSize;
 8005236:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005238:	f023 0307 	bic.w	r3, r3, #7
	xStart.xBlockSize = ( size_t ) 0;
 800523c:	6071      	str	r1, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800523e:	6032      	str	r2, [r6, #0]
	pxEnd->pxNextFreeBlock = NULL;
 8005240:	e9c3 1100 	strd	r1, r1, [r3]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005244:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005246:	e9c2 3100 	strd	r3, r1, [r2]
	pxEnd = ( void * ) uxAddress;
 800524a:	6003      	str	r3, [r0, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800524c:	4b2d      	ldr	r3, [pc, #180]	; (8005304 <pvPortMalloc+0x100>)
 800524e:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005250:	4b2d      	ldr	r3, [pc, #180]	; (8005308 <pvPortMalloc+0x104>)
 8005252:	6019      	str	r1, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005254:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8005258:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800525a:	682f      	ldr	r7, [r5, #0]
 800525c:	4227      	tst	r7, r4
 800525e:	d142      	bne.n	80052e6 <pvPortMalloc+0xe2>
			if( xWantedSize > 0 )
 8005260:	2c00      	cmp	r4, #0
 8005262:	d03b      	beq.n	80052dc <pvPortMalloc+0xd8>
				xWantedSize += xHeapStructSize;
 8005264:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8005268:	0764      	lsls	r4, r4, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800526a:	bf1c      	itt	ne
 800526c:	f023 0307 	bicne.w	r3, r3, #7
 8005270:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8005272:	2b00      	cmp	r3, #0
 8005274:	d037      	beq.n	80052e6 <pvPortMalloc+0xe2>
 8005276:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8005308 <pvPortMalloc+0x104>
 800527a:	f8d8 6000 	ldr.w	r6, [r8]
 800527e:	429e      	cmp	r6, r3
 8005280:	d331      	bcc.n	80052e6 <pvPortMalloc+0xe2>
				pxBlock = xStart.pxNextFreeBlock;
 8005282:	4a1f      	ldr	r2, [pc, #124]	; (8005300 <pvPortMalloc+0xfc>)
 8005284:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005286:	f8d5 c004 	ldr.w	ip, [r5, #4]
 800528a:	459c      	cmp	ip, r3
 800528c:	d201      	bcs.n	8005292 <pvPortMalloc+0x8e>
 800528e:	6829      	ldr	r1, [r5, #0]
 8005290:	b979      	cbnz	r1, 80052b2 <pvPortMalloc+0xae>
				if( pxBlock != pxEnd )
 8005292:	6801      	ldr	r1, [r0, #0]
 8005294:	42a9      	cmp	r1, r5
 8005296:	d026      	beq.n	80052e6 <pvPortMalloc+0xe2>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8005298:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800529a:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800529c:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800529e:	ebac 0203 	sub.w	r2, ip, r3
 80052a2:	2a10      	cmp	r2, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80052a4:	f104 0408 	add.w	r4, r4, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80052a8:	d90a      	bls.n	80052c0 <pvPortMalloc+0xbc>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80052aa:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80052ac:	0741      	lsls	r1, r0, #29
 80052ae:	d003      	beq.n	80052b8 <pvPortMalloc+0xb4>
 80052b0:	e7fe      	b.n	80052b0 <pvPortMalloc+0xac>
 80052b2:	462a      	mov	r2, r5
 80052b4:	460d      	mov	r5, r1
 80052b6:	e7e6      	b.n	8005286 <pvPortMalloc+0x82>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80052b8:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80052ba:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80052bc:	f7ff f9a4 	bl	8004608 <prvInsertBlockIntoFreeList>
					pxBlock->pxNextFreeBlock = NULL;
 80052c0:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052c2:	4910      	ldr	r1, [pc, #64]	; (8005304 <pvPortMalloc+0x100>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052c4:	686a      	ldr	r2, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052c6:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052c8:	1ab6      	subs	r6, r6, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80052ca:	4286      	cmp	r6, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80052cc:	ea47 0702 	orr.w	r7, r7, r2
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80052d0:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80052d4:	bf38      	it	cc
 80052d6:	600e      	strcc	r6, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80052d8:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80052da:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80052dc:	f7ff ff0e 	bl	80050fc <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80052e0:	0763      	lsls	r3, r4, #29
 80052e2:	d002      	beq.n	80052ea <pvPortMalloc+0xe6>
 80052e4:	e7fe      	b.n	80052e4 <pvPortMalloc+0xe0>
void *pvReturn = NULL;
 80052e6:	2400      	movs	r4, #0
 80052e8:	e7f8      	b.n	80052dc <pvPortMalloc+0xd8>
}
 80052ea:	4620      	mov	r0, r4
 80052ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80052f0:	200011b0 	.word	0x200011b0
 80052f4:	20001378 	.word	0x20001378
 80052f8:	20001650 	.word	0x20001650
 80052fc:	20005000 	.word	0x20005000
 8005300:	20001618 	.word	0x20001618
 8005304:	200015f4 	.word	0x200015f4
 8005308:	200013a4 	.word	0x200013a4

0800530c <vPortFree>:
{
 800530c:	b508      	push	{r3, lr}
	if( pv != NULL )
 800530e:	b1e8      	cbz	r0, 800534c <vPortFree+0x40>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005310:	4a0f      	ldr	r2, [pc, #60]	; (8005350 <vPortFree+0x44>)
 8005312:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8005316:	6812      	ldr	r2, [r2, #0]
 8005318:	4213      	tst	r3, r2
 800531a:	d100      	bne.n	800531e <vPortFree+0x12>
 800531c:	e7fe      	b.n	800531c <vPortFree+0x10>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800531e:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8005322:	b101      	cbz	r1, 8005326 <vPortFree+0x1a>
 8005324:	e7fe      	b.n	8005324 <vPortFree+0x18>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8005326:	ea23 0302 	bic.w	r3, r3, r2
 800532a:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 800532e:	f7ff f9c3 	bl	80046b8 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8005332:	4a08      	ldr	r2, [pc, #32]	; (8005354 <vPortFree+0x48>)
 8005334:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8005338:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800533a:	3808      	subs	r0, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 800533c:	440b      	add	r3, r1
 800533e:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8005340:	f7ff f962 	bl	8004608 <prvInsertBlockIntoFreeList>
}
 8005344:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
				( void ) xTaskResumeAll();
 8005348:	f7ff bed8 	b.w	80050fc <xTaskResumeAll>
}
 800534c:	bd08      	pop	{r3, pc}
 800534e:	bf00      	nop
 8005350:	20001378 	.word	0x20001378
 8005354:	200013a4 	.word	0x200013a4

08005358 <prvDeleteTCB>:
	{
 8005358:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800535a:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
	{
 800535e:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8005360:	b93b      	cbnz	r3, 8005372 <prvDeleteTCB+0x1a>
				vPortFree( pxTCB->pxStack );
 8005362:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8005364:	f7ff ffd2 	bl	800530c <vPortFree>
				vPortFree( pxTCB );
 8005368:	4620      	mov	r0, r4
	}
 800536a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
 800536e:	f7ff bfcd 	b.w	800530c <vPortFree>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8005372:	2b01      	cmp	r3, #1
 8005374:	d0f9      	beq.n	800536a <prvDeleteTCB+0x12>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8005376:	2b02      	cmp	r3, #2
 8005378:	d000      	beq.n	800537c <prvDeleteTCB+0x24>
 800537a:	e7fe      	b.n	800537a <prvDeleteTCB+0x22>
	}
 800537c:	bd10      	pop	{r4, pc}
	...

08005380 <vTaskDelay>:
	{
 8005380:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8005382:	b998      	cbnz	r0, 80053ac <vTaskDelay+0x2c>
			portYIELD_WITHIN_API();
 8005384:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005388:	4a14      	ldr	r2, [pc, #80]	; (80053dc <vTaskDelay+0x5c>)
 800538a:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800538e:	6011      	str	r1, [r2, #0]
 8005390:	4a13      	ldr	r2, [pc, #76]	; (80053e0 <vTaskDelay+0x60>)
 8005392:	6812      	ldr	r2, [r2, #0]
 8005394:	b9ba      	cbnz	r2, 80053c6 <vTaskDelay+0x46>
 8005396:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800539a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800539e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80053a2:	f3bf 8f4f 	dsb	sy
 80053a6:	f3bf 8f6f 	isb	sy
	}
 80053aa:	e00b      	b.n	80053c4 <vTaskDelay+0x44>
			configASSERT( uxSchedulerSuspended == 0 );
 80053ac:	4b0d      	ldr	r3, [pc, #52]	; (80053e4 <vTaskDelay+0x64>)
 80053ae:	6819      	ldr	r1, [r3, #0]
 80053b0:	b101      	cbz	r1, 80053b4 <vTaskDelay+0x34>
 80053b2:	e7fe      	b.n	80053b2 <vTaskDelay+0x32>
			vTaskSuspendAll();
 80053b4:	f7ff f980 	bl	80046b8 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80053b8:	f7ff fa7c 	bl	80048b4 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80053bc:	f7ff fe9e 	bl	80050fc <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80053c0:	2800      	cmp	r0, #0
 80053c2:	d0df      	beq.n	8005384 <vTaskDelay+0x4>
	}
 80053c4:	bd08      	pop	{r3, pc}
			portYIELD_WITHIN_API();
 80053c6:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80053ca:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80053ce:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80053d2:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80053d6:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80053da:	e7dc      	b.n	8005396 <vTaskDelay+0x16>
 80053dc:	2000134c 	.word	0x2000134c
 80053e0:	20001358 	.word	0x20001358
 80053e4:	2000136c 	.word	0x2000136c

080053e8 <xTaskCheckForTimeOut>:
{
 80053e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80053ea:	460c      	mov	r4, r1
	taskENTER_CRITICAL();
 80053ec:	f7ff fad2 	bl	8004994 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 80053f0:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
 80053f2:	4d0f      	ldr	r5, [pc, #60]	; (8005430 <xTaskCheckForTimeOut+0x48>)
			if( *pxTicksToWait == portMAX_DELAY )
 80053f4:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 80053f6:	6829      	ldr	r1, [r5, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 80053f8:	d012      	beq.n	8005420 <xTaskCheckForTimeOut+0x38>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80053fa:	4e0e      	ldr	r6, [pc, #56]	; (8005434 <xTaskCheckForTimeOut+0x4c>)
 80053fc:	f8d0 c000 	ldr.w	ip, [r0]
 8005400:	6837      	ldr	r7, [r6, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8005402:	6842      	ldr	r2, [r0, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005404:	45bc      	cmp	ip, r7
 8005406:	d001      	beq.n	800540c <xTaskCheckForTimeOut+0x24>
 8005408:	428a      	cmp	r2, r1
 800540a:	d90f      	bls.n	800542c <xTaskCheckForTimeOut+0x44>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800540c:	1a8f      	subs	r7, r1, r2
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800540e:	42bb      	cmp	r3, r7
 8005410:	d90a      	bls.n	8005428 <xTaskCheckForTimeOut+0x40>
			*pxTicksToWait -= xElapsedTime;
 8005412:	1a5b      	subs	r3, r3, r1
 8005414:	4413      	add	r3, r2
 8005416:	6023      	str	r3, [r4, #0]
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005418:	6833      	ldr	r3, [r6, #0]
 800541a:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800541c:	682b      	ldr	r3, [r5, #0]
 800541e:	6043      	str	r3, [r0, #4]
				xReturn = pdFALSE;
 8005420:	2000      	movs	r0, #0
	taskEXIT_CRITICAL();
 8005422:	f7ff fccf 	bl	8004dc4 <vPortExitCritical>
}
 8005426:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			*pxTicksToWait = 0;
 8005428:	2300      	movs	r3, #0
 800542a:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 800542c:	2001      	movs	r0, #1
 800542e:	e7f8      	b.n	8005422 <xTaskCheckForTimeOut+0x3a>
 8005430:	20001648 	.word	0x20001648
 8005434:	200015fc 	.word	0x200015fc

08005438 <xQueueSemaphoreTake>:
{
 8005438:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( ( pxQueue ) );
 800543c:	4604      	mov	r4, r0
{
 800543e:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8005440:	b900      	cbnz	r0, 8005444 <xQueueSemaphoreTake+0xc>
 8005442:	e7fe      	b.n	8005442 <xQueueSemaphoreTake+0xa>
	configASSERT( pxQueue->uxItemSize == 0 );
 8005444:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8005446:	b105      	cbz	r5, 800544a <xQueueSemaphoreTake+0x12>
 8005448:	e7fe      	b.n	8005448 <xQueueSemaphoreTake+0x10>
 800544a:	4628      	mov	r0, r5
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800544c:	4f98      	ldr	r7, [pc, #608]	; (80056b0 <xQueueSemaphoreTake+0x278>)
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 800544e:	4e99      	ldr	r6, [pc, #612]	; (80056b4 <xQueueSemaphoreTake+0x27c>)
 8005450:	e073      	b.n	800553a <xQueueSemaphoreTake+0x102>
				if( xTicksToWait == ( TickType_t ) 0 )
 8005452:	9b01      	ldr	r3, [sp, #4]
 8005454:	b91b      	cbnz	r3, 800545e <xQueueSemaphoreTake+0x26>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8005456:	2d00      	cmp	r5, #0
 8005458:	f000 8162 	beq.w	8005720 <xQueueSemaphoreTake+0x2e8>
 800545c:	e7fe      	b.n	800545c <xQueueSemaphoreTake+0x24>
				else if( xEntryTimeSet == pdFALSE )
 800545e:	b920      	cbnz	r0, 800546a <xQueueSemaphoreTake+0x32>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005460:	683b      	ldr	r3, [r7, #0]
 8005462:	9302      	str	r3, [sp, #8]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8005464:	4b94      	ldr	r3, [pc, #592]	; (80056b8 <xQueueSemaphoreTake+0x280>)
 8005466:	681b      	ldr	r3, [r3, #0]
 8005468:	9303      	str	r3, [sp, #12]
		taskEXIT_CRITICAL();
 800546a:	f7ff fcab 	bl	8004dc4 <vPortExitCritical>
		vTaskSuspendAll();
 800546e:	f7ff f923 	bl	80046b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005472:	f7ff fa8f 	bl	8004994 <vPortEnterCritical>
 8005476:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800547a:	a901      	add	r1, sp, #4
		prvLockQueue( pxQueue );
 800547c:	2bff      	cmp	r3, #255	; 0xff
 800547e:	bf04      	itt	eq
 8005480:	2300      	moveq	r3, #0
 8005482:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8005486:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800548a:	a802      	add	r0, sp, #8
		prvLockQueue( pxQueue );
 800548c:	2bff      	cmp	r3, #255	; 0xff
 800548e:	bf04      	itt	eq
 8005490:	2300      	moveq	r3, #0
 8005492:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8005496:	f7ff fc95 	bl	8004dc4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800549a:	f7ff ffa5 	bl	80053e8 <xTaskCheckForTimeOut>
 800549e:	2800      	cmp	r0, #0
 80054a0:	f040 80da 	bne.w	8005658 <xQueueSemaphoreTake+0x220>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80054a4:	f7ff fa76 	bl	8004994 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80054a8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80054aa:	2b00      	cmp	r3, #0
 80054ac:	d13d      	bne.n	800552a <xQueueSemaphoreTake+0xf2>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80054ae:	f7ff fc89 	bl	8004dc4 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80054b2:	6823      	ldr	r3, [r4, #0]
 80054b4:	f8df 8204 	ldr.w	r8, [pc, #516]	; 80056bc <xQueueSemaphoreTake+0x284>
 80054b8:	2b00      	cmp	r3, #0
 80054ba:	f040 8083 	bne.w	80055c4 <xQueueSemaphoreTake+0x18c>
						taskENTER_CRITICAL();
 80054be:	f7ff fa69 	bl	8004994 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80054c2:	6865      	ldr	r5, [r4, #4]
		if( pxMutexHolder != NULL )
 80054c4:	2d00      	cmp	r5, #0
 80054c6:	d07a      	beq.n	80055be <xQueueSemaphoreTake+0x186>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80054c8:	f8d8 2000 	ldr.w	r2, [r8]
 80054cc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80054ce:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80054d0:	4293      	cmp	r3, r2
 80054d2:	f080 80b8 	bcs.w	8005646 <xQueueSemaphoreTake+0x20e>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054d6:	f04f 0914 	mov.w	r9, #20
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80054da:	69aa      	ldr	r2, [r5, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054dc:	fb09 6303 	mla	r3, r9, r3, r6
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80054e0:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80054e2:	bfa1      	itttt	ge
 80054e4:	f8d8 2000 	ldrge.w	r2, [r8]
 80054e8:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 80054ea:	f1c2 0205 	rsbge	r2, r2, #5
 80054ee:	61aa      	strge	r2, [r5, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80054f0:	696a      	ldr	r2, [r5, #20]
 80054f2:	429a      	cmp	r2, r3
 80054f4:	d15e      	bne.n	80055b4 <xQueueSemaphoreTake+0x17c>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80054f6:	f105 0a04 	add.w	sl, r5, #4
 80054fa:	4650      	mov	r0, sl
 80054fc:	f7ff f8cb 	bl	8004696 <uxListRemove>
 8005500:	4b6f      	ldr	r3, [pc, #444]	; (80056c0 <xQueueSemaphoreTake+0x288>)
 8005502:	2800      	cmp	r0, #0
 8005504:	f000 8090 	beq.w	8005628 <xQueueSemaphoreTake+0x1f0>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005508:	f8d8 2000 	ldr.w	r2, [r8]
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800550c:	6818      	ldr	r0, [r3, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800550e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005510:	62ea      	str	r2, [r5, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8005512:	2501      	movs	r5, #1
 8005514:	fa05 f102 	lsl.w	r1, r5, r2
 8005518:	4301      	orrs	r1, r0
 800551a:	2014      	movs	r0, #20
 800551c:	6019      	str	r1, [r3, #0]
 800551e:	fb00 6002 	mla	r0, r0, r2, r6
 8005522:	4651      	mov	r1, sl
 8005524:	f7ff f894 	bl	8004650 <vListInsertEnd>
 8005528:	e048      	b.n	80055bc <xQueueSemaphoreTake+0x184>
				prvUnlockQueue( pxQueue );
 800552a:	4620      	mov	r0, r4
	taskEXIT_CRITICAL();
 800552c:	f7ff fc4a 	bl	8004dc4 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8005530:	f7ff fcee 	bl	8004f10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8005534:	f7ff fde2 	bl	80050fc <xTaskResumeAll>
{
 8005538:	2001      	movs	r0, #1
		taskENTER_CRITICAL();
 800553a:	f7ff fa2b 	bl	8004994 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 800553e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8005540:	2b00      	cmp	r3, #0
 8005542:	d086      	beq.n	8005452 <xQueueSemaphoreTake+0x1a>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8005544:	3b01      	subs	r3, #1
 8005546:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005548:	6823      	ldr	r3, [r4, #0]
 800554a:	b943      	cbnz	r3, 800555e <xQueueSemaphoreTake+0x126>
		if( pxCurrentTCB != NULL )
 800554c:	4b5b      	ldr	r3, [pc, #364]	; (80056bc <xQueueSemaphoreTake+0x284>)
 800554e:	681a      	ldr	r2, [r3, #0]
 8005550:	b11a      	cbz	r2, 800555a <xQueueSemaphoreTake+0x122>
			( pxCurrentTCB->uxMutexesHeld )++;
 8005552:	6819      	ldr	r1, [r3, #0]
 8005554:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8005556:	3201      	adds	r2, #1
 8005558:	650a      	str	r2, [r1, #80]	; 0x50
		return pxCurrentTCB;
 800555a:	681b      	ldr	r3, [r3, #0]
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 800555c:	6063      	str	r3, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800555e:	6923      	ldr	r3, [r4, #16]
 8005560:	b30b      	cbz	r3, 80055a6 <xQueueSemaphoreTake+0x16e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005562:	f104 0010 	add.w	r0, r4, #16
 8005566:	f7ff f969 	bl	800483c <xTaskRemoveFromEventList>
 800556a:	b1e0      	cbz	r0, 80055a6 <xQueueSemaphoreTake+0x16e>
						queueYIELD_IF_USING_PREEMPTION();
 800556c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005570:	4a54      	ldr	r2, [pc, #336]	; (80056c4 <xQueueSemaphoreTake+0x28c>)
 8005572:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005576:	6011      	str	r1, [r2, #0]
 8005578:	4a53      	ldr	r2, [pc, #332]	; (80056c8 <xQueueSemaphoreTake+0x290>)
 800557a:	6812      	ldr	r2, [r2, #0]
 800557c:	b14a      	cbz	r2, 8005592 <xQueueSemaphoreTake+0x15a>
 800557e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005582:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8005586:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800558a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800558e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8005592:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005596:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800559a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800559e:	f3bf 8f4f 	dsb	sy
 80055a2:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80055a6:	f7ff fc0d 	bl	8004dc4 <vPortExitCritical>
				return pdPASS;
 80055aa:	2501      	movs	r5, #1
}
 80055ac:	4628      	mov	r0, r5
 80055ae:	b004      	add	sp, #16
 80055b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80055b4:	f8d8 3000 	ldr.w	r3, [r8]
 80055b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80055ba:	62eb      	str	r3, [r5, #44]	; 0x2c
				xReturn = pdTRUE;
 80055bc:	2001      	movs	r0, #1
						taskEXIT_CRITICAL();
 80055be:	f7ff fc01 	bl	8004dc4 <vPortExitCritical>
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80055c2:	4605      	mov	r5, r0
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80055c4:	f8d8 1000 	ldr.w	r1, [r8]
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80055c8:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80055cc:	3118      	adds	r1, #24
 80055ce:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80055d2:	f7ff f849 	bl	8004668 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80055d6:	2101      	movs	r1, #1
 80055d8:	4648      	mov	r0, r9
 80055da:	f7ff f96b 	bl	80048b4 <prvAddCurrentTaskToDelayedList>
				prvUnlockQueue( pxQueue );
 80055de:	4620      	mov	r0, r4
 80055e0:	f7ff fc96 	bl	8004f10 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80055e4:	f7ff fd8a 	bl	80050fc <xTaskResumeAll>
 80055e8:	2800      	cmp	r0, #0
 80055ea:	d1a5      	bne.n	8005538 <xQueueSemaphoreTake+0x100>
					portYIELD_WITHIN_API();
 80055ec:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80055f0:	4a34      	ldr	r2, [pc, #208]	; (80056c4 <xQueueSemaphoreTake+0x28c>)
 80055f2:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80055f6:	6011      	str	r1, [r2, #0]
 80055f8:	4a33      	ldr	r2, [pc, #204]	; (80056c8 <xQueueSemaphoreTake+0x290>)
 80055fa:	6812      	ldr	r2, [r2, #0]
 80055fc:	b14a      	cbz	r2, 8005612 <xQueueSemaphoreTake+0x1da>
 80055fe:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8005602:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8005606:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800560a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800560e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8005612:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005616:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800561a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800561e:	f3bf 8f4f 	dsb	sy
 8005622:	f3bf 8f6f 	isb	sy
 8005626:	e787      	b.n	8005538 <xQueueSemaphoreTake+0x100>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 8005628:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800562a:	fb09 f900 	mul.w	r9, r9, r0
 800562e:	f856 2009 	ldr.w	r2, [r6, r9]
 8005632:	2a00      	cmp	r2, #0
 8005634:	f47f af68 	bne.w	8005508 <xQueueSemaphoreTake+0xd0>
 8005638:	2101      	movs	r1, #1
 800563a:	681a      	ldr	r2, [r3, #0]
 800563c:	4081      	lsls	r1, r0
 800563e:	ea22 0201 	bic.w	r2, r2, r1
 8005642:	601a      	str	r2, [r3, #0]
 8005644:	e760      	b.n	8005508 <xQueueSemaphoreTake+0xd0>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8005646:	f8d8 3000 	ldr.w	r3, [r8]
 800564a:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
 800564c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800564e:	4298      	cmp	r0, r3
 8005650:	bf2c      	ite	cs
 8005652:	2000      	movcs	r0, #0
 8005654:	2001      	movcc	r0, #1
 8005656:	e7b2      	b.n	80055be <xQueueSemaphoreTake+0x186>
			prvUnlockQueue( pxQueue );
 8005658:	4620      	mov	r0, r4
 800565a:	f7ff fc59 	bl	8004f10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800565e:	f7ff fd4d 	bl	80050fc <xTaskResumeAll>
	taskENTER_CRITICAL();
 8005662:	f7ff f997 	bl	8004994 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8005666:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005668:	b113      	cbz	r3, 8005670 <xQueueSemaphoreTake+0x238>
	taskEXIT_CRITICAL();
 800566a:	f7ff fbab 	bl	8004dc4 <vPortExitCritical>
 800566e:	e763      	b.n	8005538 <xQueueSemaphoreTake+0x100>
 8005670:	f7ff fba8 	bl	8004dc4 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 8005674:	2d00      	cmp	r5, #0
 8005676:	d099      	beq.n	80055ac <xQueueSemaphoreTake+0x174>
						taskENTER_CRITICAL();
 8005678:	f7ff f98c 	bl	8004994 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 800567c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800567e:	b11b      	cbz	r3, 8005688 <xQueueSemaphoreTake+0x250>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8005680:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005682:	681b      	ldr	r3, [r3, #0]
 8005684:	f1c3 0305 	rsb	r3, r3, #5
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
 8005688:	6864      	ldr	r4, [r4, #4]
		if( pxMutexHolder != NULL )
 800568a:	2c00      	cmp	r4, #0
 800568c:	d048      	beq.n	8005720 <xQueueSemaphoreTake+0x2e8>
			configASSERT( pxTCB->uxMutexesHeld );
 800568e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005690:	b901      	cbnz	r1, 8005694 <xQueueSemaphoreTake+0x25c>
 8005692:	e7fe      	b.n	8005692 <xQueueSemaphoreTake+0x25a>
 8005694:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8005696:	4293      	cmp	r3, r2
 8005698:	bf38      	it	cc
 800569a:	4613      	movcc	r3, r2
			if( pxTCB->uxPriority != uxPriorityToUse )
 800569c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800569e:	4293      	cmp	r3, r2
 80056a0:	d03e      	beq.n	8005720 <xQueueSemaphoreTake+0x2e8>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80056a2:	2901      	cmp	r1, #1
 80056a4:	d13c      	bne.n	8005720 <xQueueSemaphoreTake+0x2e8>
					configASSERT( pxTCB != pxCurrentTCB );
 80056a6:	4905      	ldr	r1, [pc, #20]	; (80056bc <xQueueSemaphoreTake+0x284>)
 80056a8:	6809      	ldr	r1, [r1, #0]
 80056aa:	428c      	cmp	r4, r1
 80056ac:	d10e      	bne.n	80056cc <xQueueSemaphoreTake+0x294>
 80056ae:	e7fe      	b.n	80056ae <xQueueSemaphoreTake+0x276>
 80056b0:	200015fc 	.word	0x200015fc
 80056b4:	200011b8 	.word	0x200011b8
 80056b8:	20001648 	.word	0x20001648
 80056bc:	200011a8 	.word	0x200011a8
 80056c0:	20001374 	.word	0x20001374
 80056c4:	2000134c 	.word	0x2000134c
 80056c8:	20001358 	.word	0x20001358
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056cc:	2614      	movs	r6, #20
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80056ce:	69a1      	ldr	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056d0:	4f15      	ldr	r7, [pc, #84]	; (8005728 <xQueueSemaphoreTake+0x2f0>)
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80056d2:	2900      	cmp	r1, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056d4:	fb06 7202 	mla	r2, r6, r2, r7
					pxTCB->uxPriority = uxPriorityToUse;
 80056d8:	62e3      	str	r3, [r4, #44]	; 0x2c
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80056da:	bfa4      	itt	ge
 80056dc:	f1c3 0305 	rsbge	r3, r3, #5
 80056e0:	61a3      	strge	r3, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80056e2:	6963      	ldr	r3, [r4, #20]
 80056e4:	4293      	cmp	r3, r2
 80056e6:	d11b      	bne.n	8005720 <xQueueSemaphoreTake+0x2e8>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80056e8:	f104 0804 	add.w	r8, r4, #4
 80056ec:	4640      	mov	r0, r8
 80056ee:	f7fe ffd2 	bl	8004696 <uxListRemove>
 80056f2:	4d0e      	ldr	r5, [pc, #56]	; (800572c <xQueueSemaphoreTake+0x2f4>)
 80056f4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80056f6:	b940      	cbnz	r0, 800570a <xQueueSemaphoreTake+0x2d2>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80056f8:	4356      	muls	r6, r2
 80056fa:	59bb      	ldr	r3, [r7, r6]
 80056fc:	b92b      	cbnz	r3, 800570a <xQueueSemaphoreTake+0x2d2>
 80056fe:	2101      	movs	r1, #1
 8005700:	682b      	ldr	r3, [r5, #0]
 8005702:	4091      	lsls	r1, r2
 8005704:	ea23 0301 	bic.w	r3, r3, r1
 8005708:	602b      	str	r3, [r5, #0]
						prvAddTaskToReadyList( pxTCB );
 800570a:	2301      	movs	r3, #1
 800570c:	2014      	movs	r0, #20
 800570e:	6829      	ldr	r1, [r5, #0]
 8005710:	4093      	lsls	r3, r2
 8005712:	430b      	orrs	r3, r1
 8005714:	fb00 7002 	mla	r0, r0, r2, r7
 8005718:	4641      	mov	r1, r8
 800571a:	602b      	str	r3, [r5, #0]
 800571c:	f7fe ff98 	bl	8004650 <vListInsertEnd>
					taskEXIT_CRITICAL();
 8005720:	f7ff fb50 	bl	8004dc4 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8005724:	2500      	movs	r5, #0
 8005726:	e741      	b.n	80055ac <xQueueSemaphoreTake+0x174>
 8005728:	200011b8 	.word	0x200011b8
 800572c:	20001374 	.word	0x20001374

08005730 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
 8005730:	b508      	push	{r3, lr}

  osalDbgCheck(i2cp != NULL);
 8005732:	b910      	cbnz	r0, 800573a <i2cAcquireBus+0xa>
 8005734:	f7ff f93e 	bl	80049b4 <vTaskEndScheduler>
 8005738:	e7fe      	b.n	8005738 <i2cAcquireBus+0x8>
}

static inline void osalMutexLock(mutex_t* mutex)
{
    osalDbgCheck(mutex != NULL);
    xSemaphoreTake(mutex->handle, portMAX_DELAY);
 800573a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

  osalMutexLock(&i2cp->mutex);
}
 800573e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005742:	68c0      	ldr	r0, [r0, #12]
 8005744:	f7ff be78 	b.w	8005438 <xQueueSemaphoreTake>

08005748 <prvListTasksWithinSingleList>:
	{
 8005748:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 800574c:	f8d1 a000 	ldr.w	sl, [r1]
	{
 8005750:	4604      	mov	r4, r0
 8005752:	460d      	mov	r5, r1
 8005754:	4617      	mov	r7, r2
		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 8005756:	f1ba 0f00 	cmp.w	sl, #0
 800575a:	d040      	beq.n	80057de <prvListTasksWithinSingleList+0x96>
	UBaseType_t uxTask = 0;
 800575c:	f04f 0a00 	mov.w	sl, #0
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8005760:	684b      	ldr	r3, [r1, #4]
 8005762:	f101 0808 	add.w	r8, r1, #8
 8005766:	685b      	ldr	r3, [r3, #4]
 8005768:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8005808 <prvListTasksWithinSingleList+0xc0>
 800576c:	4543      	cmp	r3, r8
 800576e:	604b      	str	r3, [r1, #4]
 8005770:	bf04      	itt	eq
 8005772:	68cb      	ldreq	r3, [r1, #12]
 8005774:	604b      	streq	r3, [r1, #4]
 8005776:	684b      	ldr	r3, [r1, #4]
 8005778:	68db      	ldr	r3, [r3, #12]
 800577a:	9301      	str	r3, [sp, #4]
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 800577c:	686a      	ldr	r2, [r5, #4]
 800577e:	6852      	ldr	r2, [r2, #4]
 8005780:	4590      	cmp	r8, r2
 8005782:	606a      	str	r2, [r5, #4]
 8005784:	bf04      	itt	eq
 8005786:	f8d8 2004 	ldreq.w	r2, [r8, #4]
 800578a:	606a      	streq	r2, [r5, #4]
 800578c:	686a      	ldr	r2, [r5, #4]
 800578e:	f8d2 b00c 	ldr.w	fp, [r2, #12]
		pxTCB = prvGetTCBFromHandle( xTask );
 8005792:	f1bb 0f00 	cmp.w	fp, #0
 8005796:	d126      	bne.n	80057e6 <prvListTasksWithinSingleList+0x9e>
 8005798:	f8d9 6000 	ldr.w	r6, [r9]
			pxTaskStatus->ulRunTimeCounter = 0;
 800579c:	2300      	movs	r3, #0
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 800579e:	f106 0034 	add.w	r0, r6, #52	; 0x34
 80057a2:	6060      	str	r0, [r4, #4]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80057a4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 80057a6:	6026      	str	r6, [r4, #0]
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80057a8:	6120      	str	r0, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 80057aa:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80057ac:	61e0      	str	r0, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 80057ae:	6c70      	ldr	r0, [r6, #68]	; 0x44
 80057b0:	60a0      	str	r0, [r4, #8]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 80057b2:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
			pxTaskStatus->ulRunTimeCounter = 0;
 80057b4:	61a3      	str	r3, [r4, #24]
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 80057b6:	6160      	str	r0, [r4, #20]
			if( pxTCB == pxCurrentTCB )
 80057b8:	f8d9 0000 	ldr.w	r0, [r9]
 80057bc:	4286      	cmp	r6, r0
 80057be:	d114      	bne.n	80057ea <prvListTasksWithinSingleList+0xa2>
				pxTaskStatus->eCurrentState = eRunning;
 80057c0:	7323      	strb	r3, [r4, #12]
	uint32_t ulCount = 0U;
 80057c2:	2000      	movs	r0, #0
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 80057c4:	6b33      	ldr	r3, [r6, #48]	; 0x30
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80057c6:	5c1e      	ldrb	r6, [r3, r0]
 80057c8:	2ea5      	cmp	r6, #165	; 0xa5
 80057ca:	d01b      	beq.n	8005804 <prvListTasksWithinSingleList+0xbc>
			} while( pxNextTCB != pxFirstTCB );
 80057cc:	9b01      	ldr	r3, [sp, #4]
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 80057ce:	0880      	lsrs	r0, r0, #2
			} while( pxNextTCB != pxFirstTCB );
 80057d0:	455b      	cmp	r3, fp
		return ( uint16_t ) ulCount;
 80057d2:	8420      	strh	r0, [r4, #32]
				uxTask++;
 80057d4:	f10a 0a01 	add.w	sl, sl, #1
			} while( pxNextTCB != pxFirstTCB );
 80057d8:	f104 0424 	add.w	r4, r4, #36	; 0x24
 80057dc:	d1ce      	bne.n	800577c <prvListTasksWithinSingleList+0x34>
	}
 80057de:	4650      	mov	r0, sl
 80057e0:	b003      	add	sp, #12
 80057e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80057e6:	465e      	mov	r6, fp
 80057e8:	e7d8      	b.n	800579c <prvListTasksWithinSingleList+0x54>
					if( eState == eSuspended )
 80057ea:	2f03      	cmp	r7, #3
				pxTaskStatus->eCurrentState = eState;
 80057ec:	7327      	strb	r7, [r4, #12]
					if( eState == eSuspended )
 80057ee:	d1e8      	bne.n	80057c2 <prvListTasksWithinSingleList+0x7a>
						vTaskSuspendAll();
 80057f0:	f7fe ff62 	bl	80046b8 <vTaskSuspendAll>
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80057f4:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 80057f6:	b110      	cbz	r0, 80057fe <prvListTasksWithinSingleList+0xb6>
								pxTaskStatus->eCurrentState = eBlocked;
 80057f8:	f04f 0302 	mov.w	r3, #2
 80057fc:	7323      	strb	r3, [r4, #12]
						( void ) xTaskResumeAll();
 80057fe:	f7ff fc7d 	bl	80050fc <xTaskResumeAll>
 8005802:	e7de      	b.n	80057c2 <prvListTasksWithinSingleList+0x7a>
			ulCount++;
 8005804:	3001      	adds	r0, #1
 8005806:	e7de      	b.n	80057c6 <prvListTasksWithinSingleList+0x7e>
 8005808:	200011a8 	.word	0x200011a8

0800580c <ulPortEnterCriticalFromISR>:
	__asm volatile
 800580c:	f3ef 8011 	mrs	r0, BASEPRI
 8005810:	f04f 03bf 	mov.w	r3, #191	; 0xbf
 8005814:	f383 8811 	msr	BASEPRI, r3
 8005818:	f3bf 8f6f 	isb	sy
 800581c:	f3bf 8f4f 	dsb	sy

uint32_t ulPortEnterCriticalFromISR( void )
{
	uint32_t ulBasePri = ulPortRaiseBASEPRI();
	
	uxCriticalNesting++;
 8005820:	4a02      	ldr	r2, [pc, #8]	; (800582c <ulPortEnterCriticalFromISR+0x20>)
 8005822:	6813      	ldr	r3, [r2, #0]
 8005824:	3301      	adds	r3, #1
 8005826:	6013      	str	r3, [r2, #0]
	
	return ulBasePri;
}
 8005828:	4770      	bx	lr
 800582a:	bf00      	nop
 800582c:	20001358 	.word	0x20001358

08005830 <osalSysLockFromISR.lto_priv.0>:
{
 8005830:	b508      	push	{r3, lr}
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8005832:	f7ff ffeb 	bl	800580c <ulPortEnterCriticalFromISR>
 8005836:	4b01      	ldr	r3, [pc, #4]	; (800583c <osalSysLockFromISR.lto_priv.0+0xc>)
 8005838:	6018      	str	r0, [r3, #0]
}
 800583a:	bd08      	pop	{r3, pc}
 800583c:	20001368 	.word	0x20001368

08005840 <vPortExitCriticalFromISR>:

/*-----------------------------------------------------------*/
void vPortExitCriticalFromISR( uint32_t ulBasePri )
{
	configASSERT( uxCriticalNesting );
 8005840:	4a04      	ldr	r2, [pc, #16]	; (8005854 <vPortExitCriticalFromISR+0x14>)
 8005842:	6813      	ldr	r3, [r2, #0]
 8005844:	b903      	cbnz	r3, 8005848 <vPortExitCriticalFromISR+0x8>
 8005846:	e7fe      	b.n	8005846 <vPortExitCriticalFromISR+0x6>
	uxCriticalNesting--;
 8005848:	3b01      	subs	r3, #1
 800584a:	6013      	str	r3, [r2, #0]
	__asm volatile( "msr basepri, %0" :: "r" ( ulNewMaskValue ));
 800584c:	f380 8811 	msr	BASEPRI, r0
	
	vPortSetBASEPRI(ulBasePri);
}
 8005850:	4770      	bx	lr
 8005852:	bf00      	nop
 8005854:	20001358 	.word	0x20001358

08005858 <osalSysUnlockFromISR.lto_priv.0>:
    taskEXIT_CRITICAL_FROM_ISR(uxSavedInterruptStatus);
 8005858:	4b01      	ldr	r3, [pc, #4]	; (8005860 <osalSysUnlockFromISR.lto_priv.0+0x8>)
 800585a:	6818      	ldr	r0, [r3, #0]
 800585c:	f7ff bff0 	b.w	8005840 <vPortExitCriticalFromISR>
 8005860:	20001368 	.word	0x20001368

08005864 <sof_handler>:
/*
 * Handles the USB driver global events.
 */
uint32_t sofCounter;
static void sof_handler(USBDriver *usbp)
{
 8005864:	b513      	push	{r0, r1, r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8005866:	4c29      	ldr	r4, [pc, #164]	; (800590c <sof_handler+0xa8>)

    (void)usbp;

    osalSysLockFromISR();
 8005868:	f7ff ffe2 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 800586c:	f8d4 1498 	ldr.w	r1, [r4, #1176]	; 0x498
 8005870:	6808      	ldr	r0, [r1, #0]
 8005872:	7803      	ldrb	r3, [r0, #0]
 8005874:	2b04      	cmp	r3, #4
 8005876:	d139      	bne.n	80058ec <sof_handler+0x88>
 8005878:	7d23      	ldrb	r3, [r4, #20]
 800587a:	2b02      	cmp	r3, #2
 800587c:	d136      	bne.n	80058ec <sof_handler+0x88>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800587e:	2301      	movs	r3, #1
 8005880:	790a      	ldrb	r2, [r1, #4]
 8005882:	4093      	lsls	r3, r2
 8005884:	8902      	ldrh	r2, [r0, #8]
 8005886:	4213      	tst	r3, r2
 8005888:	d130      	bne.n	80058ec <sof_handler+0x88>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800588a:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800588e:	b31b      	cbz	r3, 80058d8 <sof_handler+0x74>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8005890:	e9d4 3218 	ldrd	r3, r2, [r4, #96]	; 0x60
 8005894:	4293      	cmp	r3, r2
 8005896:	d132      	bne.n	80058fe <sof_handler+0x9a>
 8005898:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800589a:	2a00      	cmp	r2, #0
 800589c:	d02f      	beq.n	80058fe <sof_handler+0x9a>
 800589e:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 80058a0:	2a00      	cmp	r2, #0
 80058a2:	d02c      	beq.n	80058fe <sof_handler+0x9a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80058a4:	3a04      	subs	r2, #4

    if (size > 0U) {
 80058a6:	1ad2      	subs	r2, r2, r3
 80058a8:	d029      	beq.n	80058fe <sof_handler+0x9a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80058aa:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80058ac:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80058ae:	4818      	ldr	r0, [pc, #96]	; (8005910 <sof_handler+0xac>)
 80058b0:	3a01      	subs	r2, #1
 80058b2:	65e2      	str	r2, [r4, #92]	; 0x5c
      obqp->bwrptr += obqp->bsize;
 80058b4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80058b6:	a901      	add	r1, sp, #4
 80058b8:	4413      	add	r3, r2
      if (obqp->bwrptr >= obqp->btop) {
 80058ba:	6ea2      	ldr	r2, [r4, #104]	; 0x68
      obqp->bwrptr += obqp->bsize;
 80058bc:	6623      	str	r3, [r4, #96]	; 0x60
      if (obqp->bwrptr >= obqp->btop) {
 80058be:	4293      	cmp	r3, r2
        obqp->bwrptr = obqp->buffers;
 80058c0:	bf24      	itt	cs
 80058c2:	6f63      	ldrcs	r3, [r4, #116]	; 0x74
 80058c4:	6623      	strcs	r3, [r4, #96]	; 0x60
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80058c6:	2300      	movs	r3, #0
 80058c8:	67a3      	str	r3, [r4, #120]	; 0x78
 80058ca:	f7ff f8a5 	bl	8004a18 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
 80058ce:	4602      	mov	r2, r0
 80058d0:	b928      	cbnz	r0, 80058de <sof_handler+0x7a>
 80058d2:	f7ff f86f 	bl	80049b4 <vTaskEndScheduler>
 80058d6:	e7fe      	b.n	80058d6 <sof_handler+0x72>
  osalDbgCheckClassI();
 80058d8:	f7ff f86c 	bl	80049b4 <vTaskEndScheduler>
 80058dc:	e7fe      	b.n	80058dc <sof_handler+0x78>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80058de:	f8d4 0498 	ldr.w	r0, [r4, #1176]	; 0x498
 80058e2:	9b01      	ldr	r3, [sp, #4]
 80058e4:	7901      	ldrb	r1, [r0, #4]
 80058e6:	6800      	ldr	r0, [r0, #0]
 80058e8:	f7ff f92e 	bl	8004b48 <usbStartTransmitI>
    sduSOFHookI(&SDU1);
    sofCounter++;
 80058ec:	4a09      	ldr	r2, [pc, #36]	; (8005914 <sof_handler+0xb0>)
 80058ee:	6813      	ldr	r3, [r2, #0]
 80058f0:	3301      	adds	r3, #1
 80058f2:	6013      	str	r3, [r2, #0]
    osalSysUnlockFromISR();
}
 80058f4:	b002      	add	sp, #8
 80058f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 80058fa:	f7ff bfad 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
    if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, false);
 80058fe:	688b      	ldr	r3, [r1, #8]
 8005900:	2b00      	cmp	r3, #0
 8005902:	d0f3      	beq.n	80058ec <sof_handler+0x88>
 8005904:	2100      	movs	r1, #0
 8005906:	4798      	blx	r3
 8005908:	e7f0      	b.n	80058ec <sof_handler+0x88>
 800590a:	bf00      	nop
 800590c:	20000a44 	.word	0x20000a44
 8005910:	20000a94 	.word	0x20000a94
 8005914:	200012c8 	.word	0x200012c8

08005918 <_usb_ep0setup>:
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005918:	2300      	movs	r3, #0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800591a:	b570      	push	{r4, r5, r6, lr}
 800591c:	4604      	mov	r4, r0
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800591e:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  udp = USB_GET_DESCRIPTOR(ep);
 8005922:	4bb1      	ldr	r3, [pc, #708]	; (8005be8 <_usb_ep0setup+0x2d0>)
  usbReadSetup(usbp, ep, usbp->setup);
 8005924:	f100 0274 	add.w	r2, r0, #116	; 0x74
 8005928:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800592a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800592e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8005932:	eb03 1301 	add.w	r3, r3, r1, lsl #4
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8005936:	689b      	ldr	r3, [r3, #8]
 8005938:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800593c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8005940:	005b      	lsls	r3, r3, #1
 8005942:	f103 0110 	add.w	r1, r3, #16
 8005946:	4618      	mov	r0, r3
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8005948:	3304      	adds	r3, #4
 800594a:	6800      	ldr	r0, [r0, #0]
  for (n = 0; n < 4; n++) {
 800594c:	428b      	cmp	r3, r1
    *(uint16_t *)buf = (uint16_t)*pmap++;
 800594e:	f822 0b02 	strh.w	r0, [r2], #2
  for (n = 0; n < 4; n++) {
 8005952:	d1f8      	bne.n	8005946 <_usb_ep0setup+0x2e>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8005954:	6863      	ldr	r3, [r4, #4]
 8005956:	689b      	ldr	r3, [r3, #8]
 8005958:	bb1b      	cbnz	r3, 80059a2 <_usb_ep0setup+0x8a>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800595a:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800595e:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 8005962:	d040      	beq.n	80059e6 <_usb_ep0setup+0xce>
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005964:	f248 0080 	movw	r0, #32896	; 0x8080
 8005968:	499f      	ldr	r1, [pc, #636]	; (8005be8 <_usb_ep0setup+0x2d0>)
 800596a:	680b      	ldr	r3, [r1, #0]
 800596c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005970:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005974:	f083 0210 	eor.w	r2, r3, #16
 8005978:	4302      	orrs	r2, r0
 800597a:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 800597c:	680b      	ldr	r3, [r1, #0]
 800597e:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005982:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005986:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800598a:	4303      	orrs	r3, r0
 800598c:	600b      	str	r3, [r1, #0]
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800598e:	6863      	ldr	r3, [r4, #4]
 8005990:	681b      	ldr	r3, [r3, #0]
 8005992:	b113      	cbz	r3, 800599a <_usb_ep0setup+0x82>
 8005994:	2106      	movs	r1, #6
 8005996:	4620      	mov	r0, r4
 8005998:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800599a:	2306      	movs	r3, #6
 800599c:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 80059a0:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
 80059a2:	4620      	mov	r0, r4
 80059a4:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 80059a6:	2800      	cmp	r0, #0
 80059a8:	d0d7      	beq.n	800595a <_usb_ep0setup+0x42>
  max = (size_t)get_hword(&usbp->setup[6]);
 80059aa:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
  if (usbp->ep0n > max) {
 80059ae:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80059b0:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 80059b2:	bf88      	it	hi
 80059b4:	66e3      	strhi	r3, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80059b6:	f994 3074 	ldrsb.w	r3, [r4, #116]	; 0x74
    if (usbp->ep0n != 0U) {
 80059ba:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80059bc:	2b00      	cmp	r3, #0
 80059be:	f280 815a 	bge.w	8005c76 <_usb_ep0setup+0x35e>
    if (usbp->ep0n != 0U) {
 80059c2:	2900      	cmp	r1, #0
 80059c4:	f000 814b 	beq.w	8005c5e <_usb_ep0setup+0x346>
      usbp->ep0state = USB_EP0_TX;
 80059c8:	2301      	movs	r3, #1
 80059ca:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 80059ce:	f7ff ff2f 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80059d2:	e9d4 231a 	ldrd	r2, r3, [r4, #104]	; 0x68
 80059d6:	2100      	movs	r1, #0
 80059d8:	4620      	mov	r0, r4
 80059da:	f7ff f8b5 	bl	8004b48 <usbStartTransmitI>
}
 80059de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      osalSysUnlockFromISR();
 80059e2:	f7ff bf39 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
           ((uint32_t)usbp->setup[1] << 8U))) {
 80059e6:	f894 2075 	ldrb.w	r2, [r4, #117]	; 0x75
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80059ea:	f003 037f 	and.w	r3, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 80059ee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80059f2:	f240 3202 	movw	r2, #770	; 0x302
 80059f6:	4293      	cmp	r3, r2
 80059f8:	f000 810d 	beq.w	8005c16 <_usb_ep0setup+0x2fe>
 80059fc:	d821      	bhi.n	8005a42 <_usb_ep0setup+0x12a>
 80059fe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005a02:	d048      	beq.n	8005a96 <_usb_ep0setup+0x17e>
 8005a04:	d80d      	bhi.n	8005a22 <_usb_ep0setup+0x10a>
 8005a06:	2b01      	cmp	r3, #1
 8005a08:	d03f      	beq.n	8005a8a <_usb_ep0setup+0x172>
 8005a0a:	2b02      	cmp	r3, #2
 8005a0c:	f000 80ad 	beq.w	8005b6a <_usb_ep0setup+0x252>
 8005a10:	2b00      	cmp	r3, #0
 8005a12:	d1a7      	bne.n	8005964 <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8005a14:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8005a18:	66a2      	str	r2, [r4, #104]	; 0x68
 8005a1a:	2202      	movs	r2, #2
 8005a1c:	66e2      	str	r2, [r4, #108]	; 0x6c
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8005a1e:	6723      	str	r3, [r4, #112]	; 0x70
    return true;
 8005a20:	e7c3      	b.n	80059aa <_usb_ep0setup+0x92>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a22:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8005a26:	f000 80ba 	beq.w	8005b9e <_usb_ep0setup+0x286>
 8005a2a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005a2e:	d199      	bne.n	8005964 <_usb_ep0setup+0x4c>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005a30:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005a34:	2b01      	cmp	r3, #1
 8005a36:	d195      	bne.n	8005964 <_usb_ep0setup+0x4c>
      usbp->status |= 2U;
 8005a38:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 8005a3c:	f043 0302 	orr.w	r3, r3, #2
 8005a40:	e032      	b.n	8005aa8 <_usb_ep0setup+0x190>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a42:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005a46:	d039      	beq.n	8005abc <_usb_ep0setup+0x1a4>
 8005a48:	d817      	bhi.n	8005a7a <_usb_ep0setup+0x162>
 8005a4a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8005a4e:	d031      	beq.n	8005ab4 <_usb_ep0setup+0x19c>
 8005a50:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8005a54:	d186      	bne.n	8005964 <_usb_ep0setup+0x4c>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8005a56:	6863      	ldr	r3, [r4, #4]
 8005a58:	4620      	mov	r0, r4
 8005a5a:	685e      	ldr	r6, [r3, #4]
 8005a5c:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8005a60:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
 8005a64:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 8005a68:	47b0      	blx	r6
    if (dp == NULL) {
 8005a6a:	2800      	cmp	r0, #0
 8005a6c:	f43f af7a 	beq.w	8005964 <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8005a70:	6843      	ldr	r3, [r0, #4]
 8005a72:	66a3      	str	r3, [r4, #104]	; 0x68
 8005a74:	6803      	ldr	r3, [r0, #0]
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005a76:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005a78:	e01a      	b.n	8005ab0 <_usb_ep0setup+0x198>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005a7a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8005a7e:	d022      	beq.n	8005ac6 <_usb_ep0setup+0x1ae>
 8005a80:	f640 4202 	movw	r2, #3074	; 0xc02
 8005a84:	4293      	cmp	r3, r2
 8005a86:	f47f af6d 	bne.w	8005964 <_usb_ep0setup+0x4c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8005a8a:	4b58      	ldr	r3, [pc, #352]	; (8005bec <_usb_ep0setup+0x2d4>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8005a8c:	66a3      	str	r3, [r4, #104]	; 0x68
 8005a8e:	2302      	movs	r3, #2
 8005a90:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005a92:	2300      	movs	r3, #0
 8005a94:	e7c3      	b.n	8005a1e <_usb_ep0setup+0x106>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005a96:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005a9a:	2b01      	cmp	r3, #1
 8005a9c:	f47f af62 	bne.w	8005964 <_usb_ep0setup+0x4c>
      usbp->status &= ~2U;
 8005aa0:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 8005aa4:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8005aa8:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
      usbp->status |= 2U;
 8005aac:	f8a4 307c 	strh.w	r3, [r4, #124]	; 0x7c
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005ab0:	6725      	str	r5, [r4, #112]	; 0x70
    return true;
 8005ab2:	e77a      	b.n	80059aa <_usb_ep0setup+0x92>
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8005ab4:	e9c4 551a 	strd	r5, r5, [r4, #104]	; 0x68
 8005ab8:	4b4d      	ldr	r3, [pc, #308]	; (8005bf0 <_usb_ep0setup+0x2d8>)
 8005aba:	e7b0      	b.n	8005a1e <_usb_ep0setup+0x106>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8005abc:	f104 037f 	add.w	r3, r4, #127	; 0x7f
 8005ac0:	66a3      	str	r3, [r4, #104]	; 0x68
 8005ac2:	2301      	movs	r3, #1
 8005ac4:	e7d7      	b.n	8005a76 <_usb_ep0setup+0x15e>
    if (usbp->configuration != usbp->setup[2]) {
 8005ac6:	f894 207f 	ldrb.w	r2, [r4, #127]	; 0x7f
 8005aca:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005ace:	429a      	cmp	r2, r3
 8005ad0:	d047      	beq.n	8005b62 <_usb_ep0setup+0x24a>
      if (usbp->state == USB_ACTIVE) {
 8005ad2:	7823      	ldrb	r3, [r4, #0]
 8005ad4:	2b04      	cmp	r3, #4
 8005ad6:	d137      	bne.n	8005b48 <_usb_ep0setup+0x230>
        osalSysLockFromISR ();
 8005ad8:	f7ff feaa 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8005adc:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8005ae0:	b913      	cbnz	r3, 8005ae8 <_usb_ep0setup+0x1d0>
  osalDbgCheckClassI();
 8005ae2:	f7fe ff67 	bl	80049b4 <vTaskEndScheduler>
 8005ae6:	e7fe      	b.n	8005ae6 <_usb_ep0setup+0x1ce>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8005ae8:	7823      	ldrb	r3, [r4, #0]
 8005aea:	2b04      	cmp	r3, #4
 8005aec:	d002      	beq.n	8005af4 <_usb_ep0setup+0x1dc>
 8005aee:	f7fe ff61 	bl	80049b4 <vTaskEndScheduler>
 8005af2:	e7fe      	b.n	8005af2 <_usb_ep0setup+0x1da>
  usbp->transmitting &= 1U;
 8005af4:	68a3      	ldr	r3, [r4, #8]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005af6:	2201      	movs	r2, #1
 8005af8:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
 8005afc:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8005afe:	2300      	movs	r3, #0
 8005b00:	e9c4 3304 	strd	r3, r3, [r4, #16]
 8005b04:	e9c4 3306 	strd	r3, r3, [r4, #24]
 8005b08:	e9c4 3308 	strd	r3, r3, [r4, #32]
 8005b0c:	62a3      	str	r3, [r4, #40]	; 0x28
  usbp->pmnext = 64;
 8005b0e:	2340      	movs	r3, #64	; 0x40
    EPR_TOGGLE(i, 0);
 8005b10:	f248 0080 	movw	r0, #32896	; 0x8080
  usbp->pmnext = 64;
 8005b14:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    EPR_TOGGLE(i, 0);
 8005b18:	0093      	lsls	r3, r2, #2
 8005b1a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005b1e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8005b22:	6819      	ldr	r1, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b24:	3201      	adds	r2, #1
    EPR_TOGGLE(i, 0);
 8005b26:	4301      	orrs	r1, r0
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b28:	2a08      	cmp	r2, #8
    EPR_TOGGLE(i, 0);
 8005b2a:	6019      	str	r1, [r3, #0]
    EPR_SET(i, 0);
 8005b2c:	6018      	str	r0, [r3, #0]
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005b2e:	d1f3      	bne.n	8005b18 <_usb_ep0setup+0x200>
        osalSysUnlockFromISR ();
 8005b30:	f7ff fe92 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
        usbp->configuration = 0U;
 8005b34:	2300      	movs	r3, #0
        usbp->state = USB_SELECTED;
 8005b36:	2103      	movs	r1, #3
        usbp->configuration = 0U;
 8005b38:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8005b3c:	6863      	ldr	r3, [r4, #4]
        usbp->state = USB_SELECTED;
 8005b3e:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8005b40:	681b      	ldr	r3, [r3, #0]
 8005b42:	b10b      	cbz	r3, 8005b48 <_usb_ep0setup+0x230>
 8005b44:	4620      	mov	r0, r4
 8005b46:	4798      	blx	r3
      if (usbp->setup[2] != 0U) {
 8005b48:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005b4c:	b14b      	cbz	r3, 8005b62 <_usb_ep0setup+0x24a>
        usbp->configuration = usbp->setup[2];
 8005b4e:	f884 307f 	strb.w	r3, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
 8005b52:	2304      	movs	r3, #4
 8005b54:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8005b56:	6863      	ldr	r3, [r4, #4]
 8005b58:	681b      	ldr	r3, [r3, #0]
 8005b5a:	b113      	cbz	r3, 8005b62 <_usb_ep0setup+0x24a>
 8005b5c:	2102      	movs	r1, #2
 8005b5e:	4620      	mov	r0, r4
 8005b60:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8005b62:	2300      	movs	r3, #0
 8005b64:	e9c4 331a 	strd	r3, r3, [r4, #104]	; 0x68
 8005b68:	e759      	b.n	8005a1e <_usb_ep0setup+0x106>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8005b6a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8005b6e:	f003 020f 	and.w	r2, r3, #15
 8005b72:	f013 0f80 	tst.w	r3, #128	; 0x80
 8005b76:	4b1c      	ldr	r3, [pc, #112]	; (8005be8 <_usb_ep0setup+0x2d0>)
 8005b78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005b7c:	d008      	beq.n	8005b90 <_usb_ep0setup+0x278>
 8005b7e:	f013 0330 	ands.w	r3, r3, #48	; 0x30
 8005b82:	f43f aeef 	beq.w	8005964 <_usb_ep0setup+0x4c>
 8005b86:	2b10      	cmp	r3, #16
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005b88:	bf14      	ite	ne
 8005b8a:	4b1a      	ldrne	r3, [pc, #104]	; (8005bf4 <_usb_ep0setup+0x2dc>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8005b8c:	4b1a      	ldreq	r3, [pc, #104]	; (8005bf8 <_usb_ep0setup+0x2e0>)
 8005b8e:	e77d      	b.n	8005a8c <_usb_ep0setup+0x174>
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8005b90:	f413 5340 	ands.w	r3, r3, #12288	; 0x3000
 8005b94:	f43f aee6 	beq.w	8005964 <_usb_ep0setup+0x4c>
 8005b98:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005b9c:	e7f4      	b.n	8005b88 <_usb_ep0setup+0x270>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8005b9e:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005ba2:	2b00      	cmp	r3, #0
 8005ba4:	f47f aede 	bne.w	8005964 <_usb_ep0setup+0x4c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005ba8:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8005bac:	f012 030f 	ands.w	r3, r2, #15
 8005bb0:	d0d7      	beq.n	8005b62 <_usb_ep0setup+0x24a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005bb2:	009b      	lsls	r3, r3, #2
 8005bb4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005bb8:	f012 0f80 	tst.w	r2, #128	; 0x80
 8005bbc:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8005bc0:	681a      	ldr	r2, [r3, #0]
 8005bc2:	d01b      	beq.n	8005bfc <_usb_ep0setup+0x2e4>
 8005bc4:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8005bc8:	2a30      	cmp	r2, #48	; 0x30
 8005bca:	d0ca      	beq.n	8005b62 <_usb_ep0setup+0x24a>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8005bcc:	681a      	ldr	r2, [r3, #0]
 8005bce:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8005bd2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005bd6:	f082 0220 	eor.w	r2, r2, #32
 8005bda:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8005bde:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005be2:	601a      	str	r2, [r3, #0]
 8005be4:	e7bd      	b.n	8005b62 <_usb_ep0setup+0x24a>
 8005be6:	bf00      	nop
 8005be8:	40005c00 	.word	0x40005c00
 8005bec:	0800cd54 	.word	0x0800cd54
 8005bf0:	08003e05 	.word	0x08003e05
 8005bf4:	0800c8e0 	.word	0x0800c8e0
 8005bf8:	0800ca58 	.word	0x0800ca58
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8005bfc:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8005c00:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 8005c04:	d0ad      	beq.n	8005b62 <_usb_ep0setup+0x24a>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8005c06:	681a      	ldr	r2, [r3, #0]
 8005c08:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 8005c0c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005c10:	f442 4220 	orr.w	r2, r2, #40960	; 0xa000
 8005c14:	e7e3      	b.n	8005bde <_usb_ep0setup+0x2c6>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8005c16:	f894 3076 	ldrb.w	r3, [r4, #118]	; 0x76
 8005c1a:	2b00      	cmp	r3, #0
 8005c1c:	f47f aea2 	bne.w	8005964 <_usb_ep0setup+0x4c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005c20:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 8005c24:	f013 010f 	ands.w	r1, r3, #15
 8005c28:	d09b      	beq.n	8005b62 <_usb_ep0setup+0x24a>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005c2a:	4a1b      	ldr	r2, [pc, #108]	; (8005c98 <_usb_ep0setup+0x380>)
 8005c2c:	f013 0f80 	tst.w	r3, #128	; 0x80
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c30:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8005c34:	bf15      	itete	ne
 8005c36:	f423 43f0 	bicne.w	r3, r3, #30720	; 0x7800
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c3a:	f423 4390 	biceq.w	r3, r3, #18432	; 0x4800
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c3e:	f023 0340 	bicne.w	r3, r3, #64	; 0x40
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c42:	f023 0370 	biceq.w	r3, r3, #112	; 0x70
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005c46:	bf14      	ite	ne
 8005c48:	f083 0310 	eorne.w	r3, r3, #16
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005c4c:	f483 5380 	eoreq.w	r3, r3, #4096	; 0x1000
 8005c50:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005c54:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005c58:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8005c5c:	e781      	b.n	8005b62 <_usb_ep0setup+0x24a>
      usbp->ep0state = USB_EP0_WAITING_STS;
 8005c5e:	2303      	movs	r3, #3
 8005c60:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c64:	f7ff fde4 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8005c68:	460b      	mov	r3, r1
 8005c6a:	460a      	mov	r2, r1
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005c6c:	2100      	movs	r1, #0
 8005c6e:	4620      	mov	r0, r4
 8005c70:	f7fe ff2e 	bl	8004ad0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8005c74:	e6b3      	b.n	80059de <_usb_ep0setup+0xc6>
    if (usbp->ep0n != 0U) {
 8005c76:	b139      	cbz	r1, 8005c88 <_usb_ep0setup+0x370>
      usbp->ep0state = USB_EP0_RX;
 8005c78:	2304      	movs	r3, #4
 8005c7a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c7e:	f7ff fdd7 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005c82:	e9d4 231a 	ldrd	r2, r3, [r4, #104]	; 0x68
 8005c86:	e7f1      	b.n	8005c6c <_usb_ep0setup+0x354>
      usbp->ep0state = USB_EP0_SENDING_STS;
 8005c88:	2305      	movs	r3, #5
 8005c8a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      osalSysLockFromISR();
 8005c8e:	f7ff fdcf 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005c92:	460b      	mov	r3, r1
 8005c94:	460a      	mov	r2, r1
 8005c96:	e69e      	b.n	80059d6 <_usb_ep0setup+0xbe>
 8005c98:	40005c00 	.word	0x40005c00

08005c9c <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005c9c:	b510      	push	{r4, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8005c9e:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005ca2:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8005ca4:	2b06      	cmp	r3, #6
 8005ca6:	d852      	bhi.n	8005d4e <_usb_ep0in+0xb2>
 8005ca8:	e8df f003 	tbb	[pc, r3]
 8005cac:	311d0431 	.word	0x311d0431
 8005cb0:	2c31      	.short	0x2c31
 8005cb2:	34          	.byte	0x34
 8005cb3:	00          	.byte	0x00
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8005cb4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    max = (size_t)get_hword(&usbp->setup[6]);
 8005cb6:	f8b0 207a 	ldrh.w	r2, [r0, #122]	; 0x7a
    if ((usbp->ep0n < max) &&
 8005cba:	4293      	cmp	r3, r2
 8005cbc:	d213      	bcs.n	8005ce6 <_usb_ep0in+0x4a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8005cbe:	68c2      	ldr	r2, [r0, #12]
 8005cc0:	8a11      	ldrh	r1, [r2, #16]
 8005cc2:	fbb3 f2f1 	udiv	r2, r3, r1
 8005cc6:	fb01 3112 	mls	r1, r1, r2, r3
    if ((usbp->ep0n < max) &&
 8005cca:	b961      	cbnz	r1, 8005ce6 <_usb_ep0in+0x4a>
      osalSysLockFromISR();
 8005ccc:	f7ff fdb0 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8005cd0:	460b      	mov	r3, r1
 8005cd2:	460a      	mov	r2, r1
 8005cd4:	4620      	mov	r0, r4
 8005cd6:	f7fe ff37 	bl	8004b48 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8005cda:	f7ff fdbd 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8005cde:	2302      	movs	r3, #2
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
 8005ce0:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005ce4:	bd10      	pop	{r4, pc}
    usbp->ep0state = USB_EP0_WAITING_STS;
 8005ce6:	2303      	movs	r3, #3
 8005ce8:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    osalSysLockFromISR();
 8005cec:	f7ff fda0 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8005cf0:	2300      	movs	r3, #0
 8005cf2:	4620      	mov	r0, r4
 8005cf4:	461a      	mov	r2, r3
 8005cf6:	4619      	mov	r1, r3
 8005cf8:	f7fe feea 	bl	8004ad0 <usbStartReceiveI>
}
 8005cfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 8005d00:	f7ff bdaa 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
    if (usbp->ep0endcb != NULL) {
 8005d04:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005d06:	b103      	cbz	r3, 8005d0a <_usb_ep0in+0x6e>
      usbp->ep0endcb(usbp);
 8005d08:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005d0a:	2300      	movs	r3, #0
 8005d0c:	e7e8      	b.n	8005ce0 <_usb_ep0in+0x44>
    osalDbgAssert(false, "EP0 state machine error");
 8005d0e:	f7fe fe51 	bl	80049b4 <vTaskEndScheduler>
 8005d12:	e7fe      	b.n	8005d12 <_usb_ep0in+0x76>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005d14:	f248 0080 	movw	r0, #32896	; 0x8080
 8005d18:	490e      	ldr	r1, [pc, #56]	; (8005d54 <_usb_ep0in+0xb8>)
 8005d1a:	680b      	ldr	r3, [r1, #0]
 8005d1c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005d20:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005d24:	f083 0210 	eor.w	r2, r3, #16
 8005d28:	4302      	orrs	r2, r0
 8005d2a:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005d2c:	680b      	ldr	r3, [r1, #0]
 8005d2e:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005d32:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005d36:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8005d3a:	4303      	orrs	r3, r0
 8005d3c:	600b      	str	r3, [r1, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005d3e:	6863      	ldr	r3, [r4, #4]
 8005d40:	681b      	ldr	r3, [r3, #0]
 8005d42:	b113      	cbz	r3, 8005d4a <_usb_ep0in+0xae>
 8005d44:	2106      	movs	r1, #6
 8005d46:	4620      	mov	r0, r4
 8005d48:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005d4a:	2306      	movs	r3, #6
 8005d4c:	e7c8      	b.n	8005ce0 <_usb_ep0in+0x44>
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005d4e:	f7fe fe31 	bl	80049b4 <vTaskEndScheduler>
 8005d52:	e7fe      	b.n	8005d52 <_usb_ep0in+0xb6>
 8005d54:	40005c00 	.word	0x40005c00

08005d58 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8005d58:	b510      	push	{r4, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8005d5a:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8005d5e:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8005d60:	2b06      	cmp	r3, #6
 8005d62:	d83f      	bhi.n	8005de4 <_usb_ep0out+0x8c>
 8005d64:	e8df f003 	tbb	[pc, r3]
 8005d68:	131e1e1e 	.word	0x131e1e1e
 8005d6c:	1e04      	.short	0x1e04
 8005d6e:	21          	.byte	0x21
 8005d6f:	00          	.byte	0x00
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8005d70:	2305      	movs	r3, #5
 8005d72:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8005d76:	f7ff fd5b 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8005d7a:	2300      	movs	r3, #0
 8005d7c:	4620      	mov	r0, r4
 8005d7e:	461a      	mov	r2, r3
 8005d80:	4619      	mov	r1, r3
 8005d82:	f7fe fee1 	bl	8004b48 <usbStartTransmitI>
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysUnlockFromISR();
 8005d8a:	f7ff bd65 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8005d8e:	68c3      	ldr	r3, [r0, #12]
 8005d90:	699b      	ldr	r3, [r3, #24]
 8005d92:	685b      	ldr	r3, [r3, #4]
 8005d94:	b92b      	cbnz	r3, 8005da2 <_usb_ep0out+0x4a>
    if (usbp->ep0endcb != NULL) {
 8005d96:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005d98:	b103      	cbz	r3, 8005d9c <_usb_ep0out+0x44>
      usbp->ep0endcb(usbp);
 8005d9a:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005d9c:	2300      	movs	r3, #0
    usbp->ep0state = USB_EP0_ERROR;
 8005d9e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
}
 8005da2:	bd10      	pop	{r4, pc}
    osalDbgAssert(false, "EP0 state machine error");
 8005da4:	f7fe fe06 	bl	80049b4 <vTaskEndScheduler>
 8005da8:	e7fe      	b.n	8005da8 <_usb_ep0out+0x50>
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8005daa:	f248 0080 	movw	r0, #32896	; 0x8080
 8005dae:	490f      	ldr	r1, [pc, #60]	; (8005dec <_usb_ep0out+0x94>)
 8005db0:	680b      	ldr	r3, [r1, #0]
 8005db2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005db6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005dba:	f083 0210 	eor.w	r2, r3, #16
 8005dbe:	4302      	orrs	r2, r0
 8005dc0:	600a      	str	r2, [r1, #0]
  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8005dc2:	680b      	ldr	r3, [r1, #0]
 8005dc4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005dc8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005dcc:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8005dd0:	4303      	orrs	r3, r0
 8005dd2:	600b      	str	r3, [r1, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005dd4:	6863      	ldr	r3, [r4, #4]
 8005dd6:	681b      	ldr	r3, [r3, #0]
 8005dd8:	b113      	cbz	r3, 8005de0 <_usb_ep0out+0x88>
 8005dda:	2106      	movs	r1, #6
 8005ddc:	4620      	mov	r0, r4
 8005dde:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005de0:	2306      	movs	r3, #6
 8005de2:	e7dc      	b.n	8005d9e <_usb_ep0out+0x46>
    osalDbgAssert(false, "EP0 state machine invalid state");
 8005de4:	f7fe fde6 	bl	80049b4 <vTaskEndScheduler>
 8005de8:	e7fe      	b.n	8005de8 <_usb_ep0out+0x90>
 8005dea:	bf00      	nop
 8005dec:	40005c00 	.word	0x40005c00

08005df0 <sofNeededCallback>:
static void sofNeededCallback(USBDriver *usbp, bool enable)
{
    (void) usbp;
    static bool sofEnabled = true;

    if(!allowDisableSOF && !enable) return;
 8005df0:	4b0c      	ldr	r3, [pc, #48]	; (8005e24 <sofNeededCallback+0x34>)
{
 8005df2:	b510      	push	{r4, lr}
    if(!allowDisableSOF && !enable) return;
 8005df4:	781b      	ldrb	r3, [r3, #0]
 8005df6:	b903      	cbnz	r3, 8005dfa <sofNeededCallback+0xa>
 8005df8:	b199      	cbz	r1, 8005e22 <sofNeededCallback+0x32>
    if(sofEnabled == enable) return;
 8005dfa:	4c0b      	ldr	r4, [pc, #44]	; (8005e28 <sofNeededCallback+0x38>)
 8005dfc:	7823      	ldrb	r3, [r4, #0]
 8005dfe:	428b      	cmp	r3, r1
 8005e00:	d00f      	beq.n	8005e22 <sofNeededCallback+0x32>

    syssts_t basepri = osalSysGetStatusAndLockX();
 8005e02:	f7ff fd03 	bl	800580c <ulPortEnterCriticalFromISR>

    if(enable) {
 8005e06:	4b09      	ldr	r3, [pc, #36]	; (8005e2c <sofNeededCallback+0x3c>)
        STM32_USB->CNTR |= CNTR_SOFM;
 8005e08:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if(enable) {
 8005e0a:	b139      	cbz	r1, 8005e1c <sofNeededCallback+0x2c>
        STM32_USB->CNTR |= CNTR_SOFM;
 8005e0c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    } else {
        STM32_USB->CNTR &=~ CNTR_SOFM;
 8005e10:	641a      	str	r2, [r3, #64]	; 0x40
    }

    sofEnabled = enable;
 8005e12:	7021      	strb	r1, [r4, #0]

    osalSysRestoreStatusX(basepri);
}
 8005e14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    osalSysRestoreStatusX(basepri);
 8005e18:	f7ff bd12 	b.w	8005840 <vPortExitCriticalFromISR>
        STM32_USB->CNTR &=~ CNTR_SOFM;
 8005e1c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8005e20:	e7f6      	b.n	8005e10 <sofNeededCallback+0x20>
}
 8005e22:	bd10      	pop	{r4, pc}
 8005e24:	20000800 	.word	0x20000800
 8005e28:	20000911 	.word	0x20000911
 8005e2c:	40005c00 	.word	0x40005c00

08005e30 <gpioCPUGetPinMode>:
{
 8005e30:	b538      	push	{r3, r4, r5, lr}
 8005e32:	4604      	mov	r4, r0
    syssts_t sts = osalSysGetStatusAndLockX();
 8005e34:	f7ff fcea 	bl	800580c <ulPortEnterCriticalFromISR>
    cr = (uint64_t)(((ioportid_t)driver->driver)->CRH) << 32;
 8005e38:	6823      	ldr	r3, [r4, #0]
    uint8_t config = (cr >> (4*pin)) & 0xF;
 8005e3a:	0089      	lsls	r1, r1, #2
    cr = (uint64_t)(((ioportid_t)driver->driver)->CRH) << 32;
 8005e3c:	685d      	ldr	r5, [r3, #4]
    cr |= ((ioportid_t)driver->driver)->CRL;
 8005e3e:	681c      	ldr	r4, [r3, #0]
    osalSysRestoreStatusX(sts);
 8005e40:	f7ff fcfe 	bl	8005840 <vPortExitCriticalFromISR>
    uint8_t config = (cr >> (4*pin)) & 0xF;
 8005e44:	f1c1 0220 	rsb	r2, r1, #32
 8005e48:	f1a1 0320 	sub.w	r3, r1, #32
 8005e4c:	fa05 f202 	lsl.w	r2, r5, r2
 8005e50:	fa24 f101 	lsr.w	r1, r4, r1
 8005e54:	fa25 f303 	lsr.w	r3, r5, r3
 8005e58:	4311      	orrs	r1, r2
 8005e5a:	4319      	orrs	r1, r3
}
 8005e5c:	4b02      	ldr	r3, [pc, #8]	; (8005e68 <gpioCPUGetPinMode+0x38>)
    return cfgToMode[config];
 8005e5e:	f001 010f 	and.w	r1, r1, #15
}
 8005e62:	5c58      	ldrb	r0, [r3, r1]
 8005e64:	bd38      	pop	{r3, r4, r5, pc}
 8005e66:	bf00      	nop
 8005e68:	0800c8fc 	.word	0x0800c8fc
 8005e6c:	00000000 	.word	0x00000000

08005e70 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8005e70:	4b18      	ldr	r3, [pc, #96]	; (8005ed4 <pxCurrentTCBConst+0x4>)
 8005e72:	681b      	ldr	r3, [r3, #0]
 8005e74:	4818      	ldr	r0, [pc, #96]	; (8005ed8 <pxCurrentTCBConst+0x8>)
 8005e76:	461a      	mov	r2, r3
 8005e78:	6002      	str	r2, [r0, #0]
 8005e7a:	f3ef 8009 	mrs	r0, PSP
 8005e7e:	f3bf 8f6f 	isb	sy
 8005e82:	4b13      	ldr	r3, [pc, #76]	; (8005ed0 <pxCurrentTCBConst>)
 8005e84:	681a      	ldr	r2, [r3, #0]
 8005e86:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005e8a:	4c14      	ldr	r4, [pc, #80]	; (8005edc <pxCurrentTCBConst+0xc>)
 8005e8c:	6824      	ldr	r4, [r4, #0]
 8005e8e:	f3ef 8111 	mrs	r1, BASEPRI
 8005e92:	e920 0012 	stmdb	r0!, {r1, r4}
 8005e96:	6010      	str	r0, [r2, #0]
 8005e98:	e92d 4008 	stmdb	sp!, {r3, lr}
 8005e9c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8005ea0:	f380 8811 	msr	BASEPRI, r0
 8005ea4:	f005 fbca 	bl	800b63c <vTaskSwitchContext>
 8005ea8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005eac:	6819      	ldr	r1, [r3, #0]
 8005eae:	6808      	ldr	r0, [r1, #0]
 8005eb0:	c812      	ldmia	r0!, {r1, r4}
 8005eb2:	f381 8811 	msr	BASEPRI, r1
 8005eb6:	4909      	ldr	r1, [pc, #36]	; (8005edc <pxCurrentTCBConst+0xc>)
 8005eb8:	600c      	str	r4, [r1, #0]
 8005eba:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005ebe:	f380 8809 	msr	PSP, r0
 8005ec2:	f3bf 8f6f 	isb	sy
 8005ec6:	4770      	bx	lr
 8005ec8:	f3af 8000 	nop.w
 8005ecc:	f3af 8000 	nop.w

08005ed0 <pxCurrentTCBConst>:
 8005ed0:	200011a8 	.word	0x200011a8
	"                                       \n"
	"       .align 4                        \n"
	"pxCurrentTCBConst: .word pxCurrentTCB  \n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY),"r"(ulSyspri2Value)
	);
}
 8005ed4:	2000134c 	.word	0x2000134c
 8005ed8:	e000ed20 	.word	0xe000ed20
 8005edc:	20001358 	.word	0x20001358

08005ee0 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8005ee0:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
 8005ee2:	f7fe fd57 	bl	8004994 <vPortEnterCritical>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8005ee6:	f7fe fc1f 	bl	8004728 <xTaskIncrementTick>
 8005eea:	b148      	cbz	r0, 8005f00 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
            ulSyspri2Value = portNVIC_SYSPRI2_REG;
 8005eec:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005ef0:	4a05      	ldr	r2, [pc, #20]	; (8005f08 <xPortSysTickHandler+0x28>)
 8005ef2:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8005ef6:	6011      	str	r1, [r2, #0]
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005ef8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005efc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
		}
	}
	portENABLE_INTERRUPTS();
}
 8005f00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	portENABLE_INTERRUPTS();
 8005f04:	f7fe bf5e 	b.w	8004dc4 <vPortExitCritical>
 8005f08:	2000134c 	.word	0x2000134c

08005f0c <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8005f0c:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8005f10:	2b0f      	cmp	r3, #15
 8005f12:	d906      	bls.n	8005f22 <vPortValidateInterruptPriority+0x16>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8005f14:	4a09      	ldr	r2, [pc, #36]	; (8005f3c <vPortValidateInterruptPriority+0x30>)
 8005f16:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005f18:	4a09      	ldr	r2, [pc, #36]	; (8005f40 <vPortValidateInterruptPriority+0x34>)
 8005f1a:	7812      	ldrb	r2, [r2, #0]
 8005f1c:	429a      	cmp	r2, r3
 8005f1e:	d900      	bls.n	8005f22 <vPortValidateInterruptPriority+0x16>
 8005f20:	e7fe      	b.n	8005f20 <vPortValidateInterruptPriority+0x14>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005f22:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005f26:	4a07      	ldr	r2, [pc, #28]	; (8005f44 <vPortValidateInterruptPriority+0x38>)
 8005f28:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 8005f2c:	6812      	ldr	r2, [r2, #0]
 8005f2e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005f32:	4293      	cmp	r3, r2
 8005f34:	d900      	bls.n	8005f38 <vPortValidateInterruptPriority+0x2c>
 8005f36:	e7fe      	b.n	8005f36 <vPortValidateInterruptPriority+0x2a>
	}
 8005f38:	4770      	bx	lr
 8005f3a:	bf00      	nop
 8005f3c:	e000e3f0 	.word	0xe000e3f0
 8005f40:	20001340 	.word	0x20001340
 8005f44:	20001344 	.word	0x20001344

08005f48 <vPortBusyDelay>:
	/* In my case, each loop takes 8 cycles. This depends on many things, such
	 * as the number of flash wait states. You need to adjust this if you need
	 * an accurate polled delay (rarely needed) */
	cycles /= configPORT_BUSY_DELAY_SCALE;
	
	__asm volatile
 8005f48:	2300      	movs	r3, #0
	cycles /= configPORT_BUSY_DELAY_SCALE;
 8005f4a:	08c0      	lsrs	r0, r0, #3

08005f4c <loop9420>:
	__asm volatile
 8005f4c:	4283      	cmp	r3, r0
 8005f4e:	d001      	beq.n	8005f54 <done9420>
 8005f50:	3301      	adds	r3, #1
 8005f52:	e7fb      	b.n	8005f4c <loop9420>

08005f54 <done9420>:
		"       adds %0, 1           \n"
		"       b loop%=             \n"
		"done%=:                     \n"
		:"+r"(i): "r"(cycles)
	);
}
 8005f54:	4770      	bx	lr
	...

08005f58 <packetQueueReadByte.constprop.0>:

#include "packetqueue.h"

static uint8_t packetQueueReadByte(PacketQueue_t* queue)
{
    uint8_t retVal = queue->buffer[queue->readPtr];
 8005f58:	4b05      	ldr	r3, [pc, #20]	; (8005f70 <packetQueueReadByte.constprop.0+0x18>)
 8005f5a:	689a      	ldr	r2, [r3, #8]
 8005f5c:	6819      	ldr	r1, [r3, #0]
 8005f5e:	5c88      	ldrb	r0, [r1, r2]

    queue->readPtr++;
    if(queue->readPtr >= queue->bufferSize) {
 8005f60:	6859      	ldr	r1, [r3, #4]
    queue->readPtr++;
 8005f62:	3201      	adds	r2, #1
    if(queue->readPtr >= queue->bufferSize) {
 8005f64:	428a      	cmp	r2, r1
    queue->readPtr++;
 8005f66:	609a      	str	r2, [r3, #8]
        queue->readPtr = 0;
 8005f68:	bf24      	itt	cs
 8005f6a:	2200      	movcs	r2, #0
 8005f6c:	609a      	strcs	r2, [r3, #8]
    }

    return retVal;
}
 8005f6e:	4770      	bx	lr
 8005f70:	20001310 	.word	0x20001310

08005f74 <packetQueueWriteByte.constprop.0>:

static void packetQueueWriteByte(PacketQueue_t* queue, uint8_t byte)
 8005f74:	b570      	push	{r4, r5, r6, lr}
{
    if(queue->pktCount && queue->writePtr == queue->readPtr) {
 8005f76:	4c15      	ldr	r4, [pc, #84]	; (8005fcc <packetQueueWriteByte.constprop.0+0x58>)
static void packetQueueWriteByte(PacketQueue_t* queue, uint8_t byte)
 8005f78:	4605      	mov	r5, r0
    if(queue->pktCount && queue->writePtr == queue->readPtr) {
 8005f7a:	8aa3      	ldrh	r3, [r4, #20]
 8005f7c:	b1cb      	cbz	r3, 8005fb2 <packetQueueWriteByte.constprop.0+0x3e>
 8005f7e:	68a2      	ldr	r2, [r4, #8]
 8005f80:	6923      	ldr	r3, [r4, #16]
 8005f82:	429a      	cmp	r2, r3
 8005f84:	d115      	bne.n	8005fb2 <packetQueueWriteByte.constprop.0+0x3e>
        /* We are about to overwrite a packet, so discard it */
        uint16_t dropPktLen = (packetQueueReadByte(queue) << 8) |
 8005f86:	f7ff ffe7 	bl	8005f58 <packetQueueReadByte.constprop.0>
 8005f8a:	4606      	mov	r6, r0
                              (packetQueueReadByte(queue));
 8005f8c:	f7ff ffe4 	bl	8005f58 <packetQueueReadByte.constprop.0>
        uint16_t dropPktLen = (packetQueueReadByte(queue) << 8) |
 8005f90:	ea40 2306 	orr.w	r3, r0, r6, lsl #8
        queue->readPtr += dropPktLen;
 8005f94:	68a0      	ldr	r0, [r4, #8]
        if(queue->readPtr >= queue->bufferSize) {
 8005f96:	6862      	ldr	r2, [r4, #4]
        queue->readPtr += dropPktLen;
 8005f98:	b29b      	uxth	r3, r3
 8005f9a:	4403      	add	r3, r0
        if(queue->readPtr >= queue->bufferSize) {
 8005f9c:	4293      	cmp	r3, r2
        queue->readPtr += dropPktLen;
 8005f9e:	60a3      	str	r3, [r4, #8]
            queue->readPtr -= queue->bufferSize;
 8005fa0:	bf24      	itt	cs
 8005fa2:	1a9b      	subcs	r3, r3, r2
 8005fa4:	60a3      	strcs	r3, [r4, #8]
        }
        queue->pktCount--;
 8005fa6:	8aa3      	ldrh	r3, [r4, #20]
 8005fa8:	3b01      	subs	r3, #1
 8005faa:	82a3      	strh	r3, [r4, #20]
        queue->numDropped++;
 8005fac:	6a23      	ldr	r3, [r4, #32]
 8005fae:	3301      	adds	r3, #1
 8005fb0:	6223      	str	r3, [r4, #32]
    }

    queue->buffer[queue->writePtr] = byte;
 8005fb2:	6923      	ldr	r3, [r4, #16]
 8005fb4:	6822      	ldr	r2, [r4, #0]
 8005fb6:	54d5      	strb	r5, [r2, r3]

    queue->writePtr++;
 8005fb8:	6923      	ldr	r3, [r4, #16]
    if(queue->writePtr >= queue->bufferSize) {
 8005fba:	6862      	ldr	r2, [r4, #4]
    queue->writePtr++;
 8005fbc:	3301      	adds	r3, #1
    if(queue->writePtr >= queue->bufferSize) {
 8005fbe:	4293      	cmp	r3, r2
    queue->writePtr++;
 8005fc0:	6123      	str	r3, [r4, #16]
        queue->writePtr = 0;
 8005fc2:	bf24      	itt	cs
 8005fc4:	2300      	movcs	r3, #0
 8005fc6:	6123      	strcs	r3, [r4, #16]
    }
}
 8005fc8:	bd70      	pop	{r4, r5, r6, pc}
 8005fca:	bf00      	nop
 8005fcc:	20001310 	.word	0x20001310

08005fd0 <packetQueuePutBytes.constprop.0>:
    packetQueueWriteByte(queue, 0x00);
    packetQueueWriteByte(queue, 0x00);
    queue->pktLen = 0;
}

void packetQueuePutBytes(PacketQueue_t* queue, const uint8_t* payload, uint16_t size)
 8005fd0:	b570      	push	{r4, r5, r6, lr}
 8005fd2:	4606      	mov	r6, r0
 8005fd4:	460c      	mov	r4, r1
{
    for(uint32_t i=0; i<size; i++) {
 8005fd6:	2500      	movs	r5, #0
 8005fd8:	42a5      	cmp	r5, r4
 8005fda:	d304      	bcc.n	8005fe6 <packetQueuePutBytes.constprop.0+0x16>
        packetQueueWriteByte(queue, payload[i]);
    }

    queue->pktLen += size;
 8005fdc:	4b04      	ldr	r3, [pc, #16]	; (8005ff0 <packetQueuePutBytes.constprop.0+0x20>)
 8005fde:	6999      	ldr	r1, [r3, #24]
 8005fe0:	4421      	add	r1, r4
 8005fe2:	6199      	str	r1, [r3, #24]
}
 8005fe4:	bd70      	pop	{r4, r5, r6, pc}
        packetQueueWriteByte(queue, payload[i]);
 8005fe6:	5d70      	ldrb	r0, [r6, r5]
 8005fe8:	f7ff ffc4 	bl	8005f74 <packetQueueWriteByte.constprop.0>
    for(uint32_t i=0; i<size; i++) {
 8005fec:	3501      	adds	r5, #1
 8005fee:	e7f3      	b.n	8005fd8 <packetQueuePutBytes.constprop.0+0x8>
 8005ff0:	20001310 	.word	0x20001310

08005ff4 <syslogWrite>:
    packetQueueReset(&syslogQueue);
    xSemaphoreGive(syslogSemaphore);
}

static size_t syslogWrite(void *instance, const uint8_t *bp, size_t n)
{
 8005ff4:	b510      	push	{r4, lr}
 8005ff6:	4614      	mov	r4, r2
 8005ff8:	4608      	mov	r0, r1
    (void)instance;

    packetQueuePutBytes(&syslogQueue, bp, n);
 8005ffa:	b291      	uxth	r1, r2
 8005ffc:	f7ff ffe8 	bl	8005fd0 <packetQueuePutBytes.constprop.0>

    return n;
}
 8006000:	4620      	mov	r0, r4
 8006002:	bd10      	pop	{r4, pc}

08006004 <syslogPut>:

static msg_t syslogPut(void *instance, uint8_t b)
{
 8006004:	b507      	push	{r0, r1, r2, lr}
 8006006:	f88d 1007 	strb.w	r1, [sp, #7]
    (void)instance;

    packetQueuePutBytes(&syslogQueue, &b, 1);
 800600a:	f10d 0007 	add.w	r0, sp, #7
 800600e:	2101      	movs	r1, #1
 8006010:	f7ff ffde 	bl	8005fd0 <packetQueuePutBytes.constprop.0>

    return MSG_OK;
}
 8006014:	2000      	movs	r0, #0
 8006016:	b003      	add	sp, #12
 8006018:	f85d fb04 	ldr.w	pc, [sp], #4

0800601c <packetQueueEndWritePacket.constprop.0>:

void packetQueueEndWritePacket(PacketQueue_t* queue)
{
    /* Did we write more bytes than the ENTIRE queue? */
    if(queue->pktLen >= queue->bufferSize-2) {
 800601c:	4b13      	ldr	r3, [pc, #76]	; (800606c <packetQueueEndWritePacket.constprop.0+0x50>)
 800601e:	685a      	ldr	r2, [r3, #4]
 8006020:	6999      	ldr	r1, [r3, #24]
 8006022:	3a02      	subs	r2, #2
 8006024:	4291      	cmp	r1, r2
 8006026:	d309      	bcc.n	800603c <packetQueueEndWritePacket.constprop.0+0x20>
        queue->numDropped+=queue->pktCount+1;
 8006028:	6a1a      	ldr	r2, [r3, #32]
 800602a:	8a99      	ldrh	r1, [r3, #20]
 800602c:	3201      	adds	r2, #1
 800602e:	440a      	add	r2, r1
 8006030:	621a      	str	r2, [r3, #32]
        queue->pktCount = 0;
 8006032:	2200      	movs	r2, #0
 8006034:	829a      	strh	r2, [r3, #20]
        queue->readPtr = 0;
 8006036:	609a      	str	r2, [r3, #8]
        queue->writePtr = 0;
 8006038:	611a      	str	r2, [r3, #16]
        return;
 800603a:	4770      	bx	lr
    }

    /* Packet too long? */
    if(queue->pktLen > 0xffff) {
 800603c:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
        queue->writePtr = queue->lenHeaderStart;
 8006040:	69da      	ldr	r2, [r3, #28]
    if(queue->pktLen > 0xffff) {
 8006042:	d304      	bcc.n	800604e <packetQueueEndWritePacket.constprop.0+0x32>
        queue->writePtr = queue->lenHeaderStart;
 8006044:	611a      	str	r2, [r3, #16]
        queue->numDropped++;
 8006046:	6a1a      	ldr	r2, [r3, #32]
 8006048:	3201      	adds	r2, #1
 800604a:	621a      	str	r2, [r3, #32]
        return;
 800604c:	4770      	bx	lr
    }

    uint32_t hdrIndex = queue->lenHeaderStart;
    queue->buffer[hdrIndex] = queue->pktLen >> 8;
 800604e:	6818      	ldr	r0, [r3, #0]
 8006050:	0a09      	lsrs	r1, r1, #8
 8006052:	5481      	strb	r1, [r0, r2]
    hdrIndex++;
    if(hdrIndex >= queue->bufferSize) {
 8006054:	6859      	ldr	r1, [r3, #4]
    hdrIndex++;
 8006056:	3201      	adds	r2, #1
        hdrIndex = 0;
 8006058:	428a      	cmp	r2, r1
 800605a:	bf28      	it	cs
 800605c:	2200      	movcs	r2, #0
    }
    queue->buffer[hdrIndex] = queue->pktLen & 0xff;
 800605e:	6998      	ldr	r0, [r3, #24]
 8006060:	6819      	ldr	r1, [r3, #0]
 8006062:	5488      	strb	r0, [r1, r2]
    queue->pktCount++;
 8006064:	8a9a      	ldrh	r2, [r3, #20]
 8006066:	3201      	adds	r2, #1
 8006068:	829a      	strh	r2, [r3, #20]
}
 800606a:	4770      	bx	lr
 800606c:	20001310 	.word	0x20001310

08006070 <vTaskDelete.constprop.0>:
	void vTaskDelete( TaskHandle_t xTaskToDelete )
 8006070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8006072:	4d2f      	ldr	r5, [pc, #188]	; (8006130 <vTaskDelete.constprop.0+0xc0>)
		taskENTER_CRITICAL();
 8006074:	f7fe fc8e 	bl	8004994 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8006078:	682c      	ldr	r4, [r5, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800607a:	1d26      	adds	r6, r4, #4
 800607c:	4630      	mov	r0, r6
 800607e:	f7fe fb0a 	bl	8004696 <uxListRemove>
 8006082:	b960      	cbnz	r0, 800609e <vTaskDelete.constprop.0+0x2e>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8006084:	2014      	movs	r0, #20
 8006086:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8006088:	4b2a      	ldr	r3, [pc, #168]	; (8006134 <vTaskDelete.constprop.0+0xc4>)
 800608a:	4378      	muls	r0, r7
 800608c:	581b      	ldr	r3, [r3, r0]
 800608e:	b933      	cbnz	r3, 800609e <vTaskDelete.constprop.0+0x2e>
 8006090:	2201      	movs	r2, #1
 8006092:	4929      	ldr	r1, [pc, #164]	; (8006138 <vTaskDelete.constprop.0+0xc8>)
 8006094:	40ba      	lsls	r2, r7
 8006096:	680b      	ldr	r3, [r1, #0]
 8006098:	ea23 0302 	bic.w	r3, r3, r2
 800609c:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800609e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80060a0:	b11b      	cbz	r3, 80060aa <vTaskDelete.constprop.0+0x3a>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80060a2:	f104 0018 	add.w	r0, r4, #24
 80060a6:	f7fe faf6 	bl	8004696 <uxListRemove>
			uxTaskNumber++;
 80060aa:	4a24      	ldr	r2, [pc, #144]	; (800613c <vTaskDelete.constprop.0+0xcc>)
 80060ac:	6813      	ldr	r3, [r2, #0]
 80060ae:	3301      	adds	r3, #1
 80060b0:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 80060b2:	682b      	ldr	r3, [r5, #0]
 80060b4:	429c      	cmp	r4, r3
 80060b6:	d113      	bne.n	80060e0 <vTaskDelete.constprop.0+0x70>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 80060b8:	4631      	mov	r1, r6
 80060ba:	4821      	ldr	r0, [pc, #132]	; (8006140 <vTaskDelete.constprop.0+0xd0>)
 80060bc:	f7fe fac8 	bl	8004650 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 80060c0:	4a20      	ldr	r2, [pc, #128]	; (8006144 <vTaskDelete.constprop.0+0xd4>)
 80060c2:	6813      	ldr	r3, [r2, #0]
 80060c4:	3301      	adds	r3, #1
 80060c6:	6013      	str	r3, [r2, #0]
		taskEXIT_CRITICAL();
 80060c8:	f7fe fe7c 	bl	8004dc4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 80060cc:	4b1e      	ldr	r3, [pc, #120]	; (8006148 <vTaskDelete.constprop.0+0xd8>)
 80060ce:	681b      	ldr	r3, [r3, #0]
 80060d0:	b36b      	cbz	r3, 800612e <vTaskDelete.constprop.0+0xbe>
			if( pxTCB == pxCurrentTCB )
 80060d2:	682b      	ldr	r3, [r5, #0]
 80060d4:	429c      	cmp	r4, r3
 80060d6:	d12a      	bne.n	800612e <vTaskDelete.constprop.0+0xbe>
				configASSERT( uxSchedulerSuspended == 0 );
 80060d8:	4b1c      	ldr	r3, [pc, #112]	; (800614c <vTaskDelete.constprop.0+0xdc>)
 80060da:	681b      	ldr	r3, [r3, #0]
 80060dc:	b153      	cbz	r3, 80060f4 <vTaskDelete.constprop.0+0x84>
 80060de:	e7fe      	b.n	80060de <vTaskDelete.constprop.0+0x6e>
				--uxCurrentNumberOfTasks;
 80060e0:	4a1b      	ldr	r2, [pc, #108]	; (8006150 <vTaskDelete.constprop.0+0xe0>)
				prvDeleteTCB( pxTCB );
 80060e2:	4620      	mov	r0, r4
				--uxCurrentNumberOfTasks;
 80060e4:	6813      	ldr	r3, [r2, #0]
 80060e6:	3b01      	subs	r3, #1
 80060e8:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 80060ea:	f7ff f935 	bl	8005358 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 80060ee:	f7fe fb09 	bl	8004704 <prvResetNextTaskUnblockTime>
 80060f2:	e7e9      	b.n	80060c8 <vTaskDelete.constprop.0+0x58>
				portYIELD_WITHIN_API();
 80060f4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80060f8:	4a16      	ldr	r2, [pc, #88]	; (8006154 <vTaskDelete.constprop.0+0xe4>)
 80060fa:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80060fe:	6011      	str	r1, [r2, #0]
 8006100:	4a15      	ldr	r2, [pc, #84]	; (8006158 <vTaskDelete.constprop.0+0xe8>)
 8006102:	6812      	ldr	r2, [r2, #0]
 8006104:	b14a      	cbz	r2, 800611a <vTaskDelete.constprop.0+0xaa>
 8006106:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800610a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800610e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006112:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8006116:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800611a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800611e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006122:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8006126:	f3bf 8f4f 	dsb	sy
 800612a:	f3bf 8f6f 	isb	sy
	}
 800612e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006130:	200011a8 	.word	0x200011a8
 8006134:	200011b8 	.word	0x200011b8
 8006138:	20001374 	.word	0x20001374
 800613c:	20001370 	.word	0x20001370
 8006140:	20001634 	.word	0x20001634
 8006144:	20001360 	.word	0x20001360
 8006148:	20001614 	.word	0x20001614
 800614c:	2000136c 	.word	0x2000136c
 8006150:	2000135c 	.word	0x2000135c
 8006154:	2000134c 	.word	0x2000134c
 8006158:	20001358 	.word	0x20001358

0800615c <runInThreadBody>:
{
 800615c:	b508      	push	{r3, lr}
    func();
 800615e:	4780      	blx	r0
}
 8006160:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vTaskDelete(NULL);
 8006164:	f7ff bf84 	b.w	8006070 <vTaskDelete.constprop.0>

08006168 <_usb_reset.constprop.0>:
void _usb_reset(USBDriver *usbp) {
 8006168:	b570      	push	{r4, r5, r6, lr}
  usbp->status        = 0;
 800616a:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 800616c:	2302      	movs	r3, #2
 800616e:	4c16      	ldr	r4, [pc, #88]	; (80061c8 <_usb_reset.constprop.0+0x60>)
    usbp->epc[i] = NULL;
 8006170:	2220      	movs	r2, #32
 8006172:	4629      	mov	r1, r5
 8006174:	f104 000c 	add.w	r0, r4, #12
  usbp->state         = USB_READY;
 8006178:	7023      	strb	r3, [r4, #0]
  usbp->status        = 0;
 800617a:	67e5      	str	r5, [r4, #124]	; 0x7c
  usbp->transmitting  = 0;
 800617c:	60a5      	str	r5, [r4, #8]
    usbp->epc[i] = NULL;
 800617e:	f005 fb45 	bl	800b80c <memset>
  STM32_USB->DADDR  = DADDR_EF;
 8006182:	2280      	movs	r2, #128	; 0x80
  STM32_USB->BTABLE = BTABLE_ADDR;
 8006184:	4b11      	ldr	r3, [pc, #68]	; (80061cc <_usb_reset.constprop.0+0x64>)
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006186:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64
 800618a:	651d      	str	r5, [r3, #80]	; 0x50
  STM32_USB->ISTR   = 0;
 800618c:	645d      	str	r5, [r3, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 800618e:	64da      	str	r2, [r3, #76]	; 0x4c
  if (usbp->config->sof_cb != NULL)
 8006190:	6862      	ldr	r2, [r4, #4]
  usb_lld_init_endpoint(usbp, 0);
 8006192:	4629      	mov	r1, r5
  if (usbp->config->sof_cb != NULL)
 8006194:	68d2      	ldr	r2, [r2, #12]
  usb_lld_init_endpoint(usbp, 0);
 8006196:	4620      	mov	r0, r4
    cntr |= CNTR_SOFM;
 8006198:	42aa      	cmp	r2, r5
 800619a:	bf0c      	ite	eq
 800619c:	f44f 421c 	moveq.w	r2, #39936	; 0x9c00
 80061a0:	f44f 421e 	movne.w	r2, #40448	; 0x9e00
  STM32_USB->CNTR = cntr;
 80061a4:	641a      	str	r2, [r3, #64]	; 0x40
  usbp->pmnext = 64;
 80061a6:	2340      	movs	r3, #64	; 0x40
 80061a8:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  usbp->epc[0] = &ep0config;
 80061ac:	4b08      	ldr	r3, [pc, #32]	; (80061d0 <_usb_reset.constprop.0+0x68>)
 80061ae:	60e3      	str	r3, [r4, #12]
  usb_lld_init_endpoint(usbp, 0);
 80061b0:	f7fe fd80 	bl	8004cb4 <usb_lld_init_endpoint>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80061b4:	6863      	ldr	r3, [r4, #4]
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	b123      	cbz	r3, 80061c4 <_usb_reset.constprop.0+0x5c>
 80061ba:	4629      	mov	r1, r5
 80061bc:	4620      	mov	r0, r4
}
 80061be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80061c2:	4718      	bx	r3
}
 80061c4:	bd70      	pop	{r4, r5, r6, pc}
 80061c6:	bf00      	nop
 80061c8:	20000f54 	.word	0x20000f54
 80061cc:	40005c00 	.word	0x40005c00
 80061d0:	0800c9b0 	.word	0x0800c9b0

080061d4 <Vector90>:
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 80061d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  istr = STM32_USB->ISTR;
 80061d8:	4d92      	ldr	r5, [pc, #584]	; (8006424 <Vector90+0x250>)
 80061da:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  if (istr & ISTR_RESET) {
 80061dc:	0566      	lsls	r6, r4, #21
 80061de:	d504      	bpl.n	80061ea <Vector90+0x16>
    STM32_USB->ISTR = ~ISTR_RESET;
 80061e0:	f46f 6380 	mvn.w	r3, #1024	; 0x400
 80061e4:	646b      	str	r3, [r5, #68]	; 0x44
    _usb_reset(usbp);
 80061e6:	f7ff ffbf 	bl	8006168 <_usb_reset.constprop.0>
  if (istr & ISTR_SUSP) {
 80061ea:	0520      	lsls	r0, r4, #20
 80061ec:	d511      	bpl.n	8006212 <Vector90+0x3e>
    STM32_USB->CNTR |= CNTR_FSUSP;
 80061ee:	6c2b      	ldr	r3, [r5, #64]	; 0x40
  usbp->saved_state = usbp->state;
 80061f0:	488d      	ldr	r0, [pc, #564]	; (8006428 <Vector90+0x254>)
 80061f2:	f043 0308 	orr.w	r3, r3, #8
 80061f6:	642b      	str	r3, [r5, #64]	; 0x40
    STM32_USB->ISTR = ~ISTR_SUSP;
 80061f8:	f46f 6300 	mvn.w	r3, #2048	; 0x800
 80061fc:	646b      	str	r3, [r5, #68]	; 0x44
 80061fe:	7803      	ldrb	r3, [r0, #0]
 8006200:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 8006204:	2305      	movs	r3, #5
 8006206:	7003      	strb	r3, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006208:	6843      	ldr	r3, [r0, #4]
 800620a:	681b      	ldr	r3, [r3, #0]
 800620c:	b10b      	cbz	r3, 8006212 <Vector90+0x3e>
 800620e:	2104      	movs	r1, #4
 8006210:	4798      	blx	r3
  if (istr & ISTR_WKUP) {
 8006212:	04e1      	lsls	r1, r4, #19
 8006214:	d514      	bpl.n	8006240 <Vector90+0x6c>
    uint32_t fnr = STM32_USB->FNR;
 8006216:	4b83      	ldr	r3, [pc, #524]	; (8006424 <Vector90+0x250>)
 8006218:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 800621a:	0412      	lsls	r2, r2, #16
 800621c:	d40c      	bmi.n	8006238 <Vector90+0x64>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 800621e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  usbp->state = usbp->saved_state;
 8006220:	4881      	ldr	r0, [pc, #516]	; (8006428 <Vector90+0x254>)
 8006222:	f022 0208 	bic.w	r2, r2, #8
 8006226:	641a      	str	r2, [r3, #64]	; 0x40
 8006228:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800622c:	7003      	strb	r3, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800622e:	6843      	ldr	r3, [r0, #4]
 8006230:	681b      	ldr	r3, [r3, #0]
 8006232:	b10b      	cbz	r3, 8006238 <Vector90+0x64>
 8006234:	2105      	movs	r1, #5
 8006236:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_WKUP;
 8006238:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800623c:	4b79      	ldr	r3, [pc, #484]	; (8006424 <Vector90+0x250>)
 800623e:	645a      	str	r2, [r3, #68]	; 0x44
  if (istr & ISTR_SOF) {
 8006240:	05a3      	lsls	r3, r4, #22
 8006242:	d508      	bpl.n	8006256 <Vector90+0x82>
    _usb_isr_invoke_sof_cb(usbp);
 8006244:	4878      	ldr	r0, [pc, #480]	; (8006428 <Vector90+0x254>)
 8006246:	6843      	ldr	r3, [r0, #4]
 8006248:	68db      	ldr	r3, [r3, #12]
 800624a:	b103      	cbz	r3, 800624e <Vector90+0x7a>
 800624c:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 800624e:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8006252:	4b74      	ldr	r3, [pc, #464]	; (8006424 <Vector90+0x250>)
 8006254:	645a      	str	r2, [r3, #68]	; 0x44
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8006256:	4e74      	ldr	r6, [pc, #464]	; (8006428 <Vector90+0x254>)
    EPR_CLEAR_CTR_TX(ep);
 8006258:	4d74      	ldr	r5, [pc, #464]	; (800642c <Vector90+0x258>)
  while (istr & ISTR_CTR) {
 800625a:	f414 4100 	ands.w	r1, r4, #32768	; 0x8000
 800625e:	d122      	bne.n	80062a6 <Vector90+0xd2>
    UBaseType_t isIt = xYieldPending;
 8006260:	4b73      	ldr	r3, [pc, #460]	; (8006430 <Vector90+0x25c>)
 8006262:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8006264:	6019      	str	r1, [r3, #0]
  OSAL_IRQ_EPILOGUE();
 8006266:	b1e2      	cbz	r2, 80062a2 <Vector90+0xce>
 8006268:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800626c:	4a71      	ldr	r2, [pc, #452]	; (8006434 <Vector90+0x260>)
 800626e:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8006272:	6011      	str	r1, [r2, #0]
 8006274:	4a70      	ldr	r2, [pc, #448]	; (8006438 <Vector90+0x264>)
 8006276:	6812      	ldr	r2, [r2, #0]
 8006278:	b14a      	cbz	r2, 800628e <Vector90+0xba>
 800627a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800627e:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8006282:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006286:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800628a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800628e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8006292:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006296:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800629a:	f3bf 8f4f 	dsb	sy
 800629e:	f3bf 8f6f 	isb	sy
}
 80062a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 80062a6:	f004 040f 	and.w	r4, r4, #15
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
 80062aa:	00a7      	lsls	r7, r4, #2
 80062ac:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80062b0:	f507 47b8 	add.w	r7, r7, #23552	; 0x5c00
  uint32_t epr = STM32_USB->EPR[ep];
 80062b4:	f8d7 a000 	ldr.w	sl, [r7]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80062b8:	f104 0902 	add.w	r9, r4, #2
 80062bc:	eb06 0389 	add.w	r3, r6, r9, lsl #2
  if (epr & EPR_CTR_TX) {
 80062c0:	f01a 0f80 	tst.w	sl, #128	; 0x80
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80062c4:	f8d3 8004 	ldr.w	r8, [r3, #4]
  if (epr & EPR_CTR_TX) {
 80062c8:	d025      	beq.n	8006316 <Vector90+0x142>
    EPR_CLEAR_CTR_TX(ep);
 80062ca:	683a      	ldr	r2, [r7, #0]
    USBInEndpointState *isp = epcp->in_state;
 80062cc:	f8d8 3014 	ldr.w	r3, [r8, #20]
    EPR_CLEAR_CTR_TX(ep);
 80062d0:	402a      	ands	r2, r5
 80062d2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80062d6:	603a      	str	r2, [r7, #0]
    isp->txcnt += isp->txlast;
 80062d8:	68d9      	ldr	r1, [r3, #12]
 80062da:	685a      	ldr	r2, [r3, #4]
    n = isp->txsize - isp->txcnt;
 80062dc:	6818      	ldr	r0, [r3, #0]
    isp->txcnt += isp->txlast;
 80062de:	440a      	add	r2, r1
    if (n > 0) {
 80062e0:	1a80      	subs	r0, r0, r2
    isp->txcnt += isp->txlast;
 80062e2:	605a      	str	r2, [r3, #4]
    if (n > 0) {
 80062e4:	d02c      	beq.n	8006340 <Vector90+0x16c>
      if (n > epcp->in_maxsize)
 80062e6:	f8b8 2010 	ldrh.w	r2, [r8, #16]
 80062ea:	4282      	cmp	r2, r0
 80062ec:	bf28      	it	cs
 80062ee:	4602      	movcs	r2, r0
      isp->txbuf += isp->txlast;
 80062f0:	6898      	ldr	r0, [r3, #8]
 80062f2:	4401      	add	r1, r0
      isp->txlast = n;
 80062f4:	e9c3 1202 	strd	r1, r2, [r3, #8]
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 80062f8:	4620      	mov	r0, r4
 80062fa:	f7fd ff31 	bl	8004160 <usb_packet_write_from_buffer>
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 80062fe:	683b      	ldr	r3, [r7, #0]
 8006300:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8006304:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006308:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800630c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8006310:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006314:	603b      	str	r3, [r7, #0]
  if (epr & EPR_CTR_RX) {
 8006316:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
 800631a:	d06a      	beq.n	80063f2 <Vector90+0x21e>
    EPR_CLEAR_CTR_RX(ep);
 800631c:	683b      	ldr	r3, [r7, #0]
    if (epr & EPR_SETUP) {
 800631e:	f41a 6f00 	tst.w	sl, #2048	; 0x800
    EPR_CLEAR_CTR_RX(ep);
 8006322:	ea03 0305 	and.w	r3, r3, r5
 8006326:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800632a:	603b      	str	r3, [r7, #0]
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 800632c:	b2e1      	uxtb	r1, r4
    if (epr & EPR_SETUP) {
 800632e:	d016      	beq.n	800635e <Vector90+0x18a>
      _usb_isr_invoke_setup_cb(usbp, ep);
 8006330:	eb06 0989 	add.w	r9, r6, r9, lsl #2
 8006334:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8006338:	685b      	ldr	r3, [r3, #4]
        _usb_isr_invoke_out_cb(usbp, ep);
 800633a:	4630      	mov	r0, r6
 800633c:	4798      	blx	r3
 800633e:	e058      	b.n	80063f2 <Vector90+0x21e>
      _usb_isr_invoke_in_cb(usbp, ep);
 8006340:	2301      	movs	r3, #1
 8006342:	fa03 f204 	lsl.w	r2, r3, r4
 8006346:	8933      	ldrh	r3, [r6, #8]
 8006348:	ea23 0302 	bic.w	r3, r3, r2
 800634c:	8133      	strh	r3, [r6, #8]
 800634e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8006352:	2b00      	cmp	r3, #0
 8006354:	d0df      	beq.n	8006316 <Vector90+0x142>
 8006356:	4621      	mov	r1, r4
 8006358:	4630      	mov	r0, r6
 800635a:	4798      	blx	r3
 800635c:	e7db      	b.n	8006316 <Vector90+0x142>
      USBOutEndpointState *osp = epcp->out_state;
 800635e:	f8d8 2018 	ldr.w	r2, [r8, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006362:	4b30      	ldr	r3, [pc, #192]	; (8006424 <Vector90+0x250>)
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 8006364:	f8d2 c008 	ldr.w	ip, [r2, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006368:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800636a:	46e1      	mov	r9, ip
 800636c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8006370:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8006374:	eb03 1004 	add.w	r0, r3, r4, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006378:	6883      	ldr	r3, [r0, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800637a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800637e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8006382:	f3ce 0009 	ubfx	r0, lr, #0, #10
 8006386:	f3ce 0e48 	ubfx	lr, lr, #1, #9
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800638a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
  while (i >= 2) {
 800638e:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
 8006392:	eb0a 0a43 	add.w	sl, sl, r3, lsl #1
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006396:	005b      	lsls	r3, r3, #1
  while (i >= 2) {
 8006398:	4553      	cmp	r3, sl
 800639a:	f109 0902 	add.w	r9, r9, #2
 800639e:	d12b      	bne.n	80063f8 <Vector90+0x224>
  if (i >= 1) {
 80063a0:	f06f 0901 	mvn.w	r9, #1
 80063a4:	fb09 090e 	mla	r9, r9, lr, r0
 80063a8:	f1b9 0f00 	cmp.w	r9, #0
 80063ac:	d002      	beq.n	80063b4 <Vector90+0x1e0>
    *buf = (uint8_t)*pmap;
 80063ae:	681b      	ldr	r3, [r3, #0]
 80063b0:	f80c 301e 	strb.w	r3, [ip, lr, lsl #1]
      osp->rxbuf += n;
 80063b4:	6893      	ldr	r3, [r2, #8]
 80063b6:	4403      	add	r3, r0
 80063b8:	6093      	str	r3, [r2, #8]
      osp->rxcnt  += n;
 80063ba:	6853      	ldr	r3, [r2, #4]
 80063bc:	4403      	add	r3, r0
 80063be:	6053      	str	r3, [r2, #4]
      osp->rxsize -= n;
 80063c0:	6813      	ldr	r3, [r2, #0]
 80063c2:	1a1b      	subs	r3, r3, r0
 80063c4:	6013      	str	r3, [r2, #0]
      osp->rxpkts -= 1;
 80063c6:	8993      	ldrh	r3, [r2, #12]
 80063c8:	3b01      	subs	r3, #1
 80063ca:	b29b      	uxth	r3, r3
 80063cc:	8193      	strh	r3, [r2, #12]
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 80063ce:	f8b8 2012 	ldrh.w	r2, [r8, #18]
 80063d2:	4282      	cmp	r2, r0
 80063d4:	d800      	bhi.n	80063d8 <Vector90+0x204>
 80063d6:	b9c3      	cbnz	r3, 800640a <Vector90+0x236>
        _usb_isr_invoke_out_cb(usbp, ep);
 80063d8:	2301      	movs	r3, #1
 80063da:	fa03 f204 	lsl.w	r2, r3, r4
 80063de:	8973      	ldrh	r3, [r6, #10]
 80063e0:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 80063e4:	ea23 0302 	bic.w	r3, r3, r2
 80063e8:	8173      	strh	r3, [r6, #10]
 80063ea:	68e3      	ldr	r3, [r4, #12]
 80063ec:	68db      	ldr	r3, [r3, #12]
 80063ee:	2b00      	cmp	r3, #0
 80063f0:	d1a3      	bne.n	800633a <Vector90+0x166>
    istr = STM32_USB->ISTR;
 80063f2:	4b0c      	ldr	r3, [pc, #48]	; (8006424 <Vector90+0x250>)
 80063f4:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 80063f6:	e730      	b.n	800625a <Vector90+0x86>
    uint32_t w = *pmap++;
 80063f8:	f853 bb04 	ldr.w	fp, [r3], #4
    *buf++ = (uint8_t)w;
 80063fc:	f809 bc02 	strb.w	fp, [r9, #-2]
    *buf++ = (uint8_t)(w >> 8);
 8006400:	ea4f 2b1b 	mov.w	fp, fp, lsr #8
 8006404:	f809 bc01 	strb.w	fp, [r9, #-1]
    i -= 2;
 8006408:	e7c6      	b.n	8006398 <Vector90+0x1c4>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800640a:	683b      	ldr	r3, [r7, #0]
 800640c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8006410:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006414:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8006418:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800641c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006420:	603b      	str	r3, [r7, #0]
 8006422:	e7e6      	b.n	80063f2 <Vector90+0x21e>
 8006424:	40005c00 	.word	0x40005c00
 8006428:	20000f54 	.word	0x20000f54
 800642c:	ffff070f 	.word	0xffff070f
 8006430:	2000164c 	.word	0x2000164c
 8006434:	2000134c 	.word	0x2000134c
 8006438:	20001358 	.word	0x20001358

0800643c <dmaStreamAllocate.constprop.0>:
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 800643c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  osalDbgCheck(dmastp != NULL);
 800643e:	b910      	cbnz	r0, 8006446 <dmaStreamAllocate.constprop.0+0xa>
 8006440:	f7fe fab8 	bl	80049b4 <vTaskEndScheduler>
 8006444:	e7fe      	b.n	8006444 <dmaStreamAllocate.constprop.0+0x8>
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8006446:	2301      	movs	r3, #1
 8006448:	4e1f      	ldr	r6, [pc, #124]	; (80064c8 <dmaStreamAllocate.constprop.0+0x8c>)
 800644a:	7c47      	ldrb	r7, [r0, #17]
 800644c:	6835      	ldr	r5, [r6, #0]
 800644e:	fa03 f407 	lsl.w	r4, r3, r7
 8006452:	422c      	tst	r4, r5
 8006454:	d135      	bne.n	80064c2 <dmaStreamAllocate.constprop.0+0x86>
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8006456:	4b1d      	ldr	r3, [pc, #116]	; (80064cc <dmaStreamAllocate.constprop.0+0x90>)
 8006458:	f843 1037 	str.w	r1, [r3, r7, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 800645c:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 8006460:	605a      	str	r2, [r3, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8006462:	066b      	lsls	r3, r5, #25
    rccEnableDMA1(false);
 8006464:	bf08      	it	eq
 8006466:	4a1a      	ldreq	r2, [pc, #104]	; (80064d0 <dmaStreamAllocate.constprop.0+0x94>)
  dmaStreamDisable(dmastp);
 8006468:	6801      	ldr	r1, [r0, #0]
    rccEnableDMA1(false);
 800646a:	bf02      	ittt	eq
 800646c:	6953      	ldreq	r3, [r2, #20]
 800646e:	f043 0301 	orreq.w	r3, r3, #1
 8006472:	6153      	streq	r3, [r2, #20]
  dmaStreamDisable(dmastp);
 8006474:	6843      	ldr	r3, [r0, #4]
 8006476:	681a      	ldr	r2, [r3, #0]
 8006478:	f022 020f 	bic.w	r2, r2, #15
 800647c:	601a      	str	r2, [r3, #0]
 800647e:	220e      	movs	r2, #14
 8006480:	7c07      	ldrb	r7, [r0, #16]
 8006482:	40ba      	lsls	r2, r7
 8006484:	604a      	str	r2, [r1, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8006486:	2200      	movs	r2, #0
 8006488:	601a      	str	r2, [r3, #0]
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 800648a:	6883      	ldr	r3, [r0, #8]
 800648c:	421d      	tst	r5, r3
 800648e:	d114      	bne.n	80064ba <dmaStreamAllocate.constprop.0+0x7e>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006490:	21c0      	movs	r1, #192	; 0xc0
    nvicEnableVector(dmastp->vector, priority);
 8006492:	7c83      	ldrb	r3, [r0, #18]
 8006494:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
 8006498:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 800649c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80064a0:	2201      	movs	r2, #1
 80064a2:	f003 011f 	and.w	r1, r3, #31
 80064a6:	095b      	lsrs	r3, r3, #5
 80064a8:	009b      	lsls	r3, r3, #2
 80064aa:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80064ae:	408a      	lsls	r2, r1
 80064b0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80064b4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80064b8:	601a      	str	r2, [r3, #0]
  return false;
 80064ba:	2000      	movs	r0, #0
  dma_streams_mask |= (1U << dmastp->selfindex);
 80064bc:	432c      	orrs	r4, r5
 80064be:	6034      	str	r4, [r6, #0]
}
 80064c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return true;
 80064c2:	4618      	mov	r0, r3
 80064c4:	e7fc      	b.n	80064c0 <dmaStreamAllocate.constprop.0+0x84>
 80064c6:	bf00      	nop
 80064c8:	20001044 	.word	0x20001044
 80064cc:	20000fe8 	.word	0x20000fe8
 80064d0:	40021000 	.word	0x40021000

080064d4 <xTaskNotifyWait.constprop.0>:
	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
 80064d4:	b570      	push	{r4, r5, r6, lr}
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 80064d6:	4c27      	ldr	r4, [pc, #156]	; (8006574 <xTaskNotifyWait.constprop.0+0xa0>)
	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
 80064d8:	4606      	mov	r6, r0
 80064da:	460d      	mov	r5, r1
 80064dc:	4610      	mov	r0, r2
		taskENTER_CRITICAL();
 80064de:	f7fe fa59 	bl	8004994 <vPortEnterCritical>
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 80064e2:	6823      	ldr	r3, [r4, #0]
 80064e4:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80064e8:	2b02      	cmp	r3, #2
 80064ea:	d028      	beq.n	800653e <xTaskNotifyWait.constprop.0+0x6a>
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 80064ec:	2101      	movs	r1, #1
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 80064ee:	6822      	ldr	r2, [r4, #0]
 80064f0:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80064f2:	ea23 0306 	bic.w	r3, r3, r6
 80064f6:	6613      	str	r3, [r2, #96]	; 0x60
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 80064f8:	6823      	ldr	r3, [r4, #0]
 80064fa:	f883 1064 	strb.w	r1, [r3, #100]	; 0x64
				if( xTicksToWait > ( TickType_t ) 0 )
 80064fe:	b1f0      	cbz	r0, 800653e <xTaskNotifyWait.constprop.0+0x6a>
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8006500:	f7fe f9d8 	bl	80048b4 <prvAddCurrentTaskToDelayedList>
					portYIELD_WITHIN_API();
 8006504:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8006508:	4a1b      	ldr	r2, [pc, #108]	; (8006578 <xTaskNotifyWait.constprop.0+0xa4>)
 800650a:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800650e:	6011      	str	r1, [r2, #0]
 8006510:	4a1a      	ldr	r2, [pc, #104]	; (800657c <xTaskNotifyWait.constprop.0+0xa8>)
 8006512:	6812      	ldr	r2, [r2, #0]
 8006514:	b14a      	cbz	r2, 800652a <xTaskNotifyWait.constprop.0+0x56>
 8006516:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800651a:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800651e:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8006522:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8006526:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800652a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800652e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006532:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8006536:	f3bf 8f4f 	dsb	sy
 800653a:	f3bf 8f6f 	isb	sy
		taskEXIT_CRITICAL();
 800653e:	f7fe fc41 	bl	8004dc4 <vPortExitCritical>
		taskENTER_CRITICAL();
 8006542:	f7fe fa27 	bl	8004994 <vPortEnterCritical>
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 8006546:	6823      	ldr	r3, [r4, #0]
 8006548:	2000      	movs	r0, #0
 800654a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800654c:	602b      	str	r3, [r5, #0]
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 800654e:	6823      	ldr	r3, [r4, #0]
 8006550:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8006554:	2b02      	cmp	r3, #2
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8006556:	bf04      	itt	eq
 8006558:	6823      	ldreq	r3, [r4, #0]
 800655a:	6e1a      	ldreq	r2, [r3, #96]	; 0x60
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800655c:	f04f 0200 	mov.w	r2, #0
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 8006560:	bf08      	it	eq
 8006562:	6618      	streq	r0, [r3, #96]	; 0x60
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8006564:	6823      	ldr	r3, [r4, #0]
				xReturn = pdTRUE;
 8006566:	bf08      	it	eq
 8006568:	2001      	moveq	r0, #1
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800656a:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
		taskEXIT_CRITICAL();
 800656e:	f7fe fc29 	bl	8004dc4 <vPortExitCritical>
	}
 8006572:	bd70      	pop	{r4, r5, r6, pc}
 8006574:	200011a8 	.word	0x200011a8
 8006578:	2000134c 	.word	0x2000134c
 800657c:	20001358 	.word	0x20001358

08006580 <taskPeriodicMon>:
{
 8006580:	b507      	push	{r0, r1, r2, lr}
        MonitorEntry* entry = monThreadFirst;
 8006582:	4e0d      	ldr	r6, [pc, #52]	; (80065b8 <taskPeriodicMon+0x38>)
        bool workToCome = false;
 8006584:	2500      	movs	r5, #0
        MonitorEntry* entry = monThreadFirst;
 8006586:	6834      	ldr	r4, [r6, #0]
        while(entry) {
 8006588:	b95c      	cbnz	r4, 80065a2 <taskPeriodicMon+0x22>
        if(!workToCome) {
 800658a:	b92d      	cbnz	r5, 8006598 <taskPeriodicMon+0x18>
            xTaskNotifyWait(0, ULONG_MAX, (uint32_t*)&ulInterruptStatus, portMAX_DELAY);
 800658c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8006590:	4628      	mov	r0, r5
 8006592:	a901      	add	r1, sp, #4
 8006594:	f7ff ff9e 	bl	80064d4 <xTaskNotifyWait.constprop.0>
        osalThreadSleepSeconds(10);
 8006598:	f242 7010 	movw	r0, #10000	; 0x2710
 800659c:	f7fe fef0 	bl	8005380 <vTaskDelay>
    for(;;) {
 80065a0:	e7f0      	b.n	8006584 <taskPeriodicMon+0x4>
            if(entry->active) {
 80065a2:	7c23      	ldrb	r3, [r4, #16]
 80065a4:	b12b      	cbz	r3, 80065b2 <taskPeriodicMon+0x32>
                if(entry->callback) {
 80065a6:	6823      	ldr	r3, [r4, #0]
 80065a8:	b11b      	cbz	r3, 80065b2 <taskPeriodicMon+0x32>
                    entry->active = entry->callback(entry->param);
 80065aa:	6860      	ldr	r0, [r4, #4]
 80065ac:	4798      	blx	r3
 80065ae:	7420      	strb	r0, [r4, #16]
                    workToCome |= entry->active;
 80065b0:	4305      	orrs	r5, r0
            entry = entry->next;
 80065b2:	68a4      	ldr	r4, [r4, #8]
 80065b4:	e7e8      	b.n	8006588 <taskPeriodicMon+0x8>
 80065b6:	bf00      	nop
 80065b8:	200011a0 	.word	0x200011a0

080065bc <osalThreadSuspendTimeoutS>:
{
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
}

msg_t osalThreadSuspendTimeoutS(thread_reference_t* thread_reference, systime_t timeout)
{
 80065bc:	b513      	push	{r0, r1, r4, lr}
 80065be:	4604      	mov	r4, r0
 80065c0:	4608      	mov	r0, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80065c2:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80065c6:	b12b      	cbz	r3, 80065d4 <osalThreadSuspendTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80065c8:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80065cc:	b12b      	cbz	r3, 80065da <osalThreadSuspendTimeoutS+0x1e>
    msg_t ulInterruptStatus;
    osalDbgCheckClassS();
 80065ce:	f7fe f9f1 	bl	80049b4 <vTaskEndScheduler>
 80065d2:	e7fe      	b.n	80065d2 <osalThreadSuspendTimeoutS+0x16>
 80065d4:	f7fe f9ee 	bl	80049b4 <vTaskEndScheduler>
 80065d8:	e7fe      	b.n	80065d8 <osalThreadSuspendTimeoutS+0x1c>

    if(!timeout) {
 80065da:	b181      	cbz	r1, 80065fe <osalThreadSuspendTimeoutS+0x42>
        return MSG_TIMEOUT;
    }

    if(thread_reference) {
 80065dc:	b134      	cbz	r4, 80065ec <osalThreadSuspendTimeoutS+0x30>

xTaskHandle xGetCurrentTaskHandle( void )
{
    xTaskHandle xReturn;

    portENTER_CRITICAL();
 80065de:	f7fe f9d9 	bl	8004994 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80065e2:	4b0a      	ldr	r3, [pc, #40]	; (800660c <osalThreadSuspendTimeoutS+0x50>)
 80065e4:	6819      	ldr	r1, [r3, #0]
    portEXIT_CRITICAL();
 80065e6:	f7fe fbed 	bl	8004dc4 <vPortExitCritical>
        *thread_reference = xGetCurrentTaskHandle();
 80065ea:	6021      	str	r1, [r4, #0]
    }

    if(!xTaskNotifyWait(ULONG_MAX, ULONG_MAX, (uint32_t*)&ulInterruptStatus, timeout )) {
 80065ec:	4602      	mov	r2, r0
 80065ee:	a901      	add	r1, sp, #4
 80065f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80065f4:	f7ff ff6e 	bl	80064d4 <xTaskNotifyWait.constprop.0>
 80065f8:	b920      	cbnz	r0, 8006604 <osalThreadSuspendTimeoutS+0x48>
        if(thread_reference) {
 80065fa:	b104      	cbz	r4, 80065fe <osalThreadSuspendTimeoutS+0x42>
            *thread_reference = NULL;
 80065fc:	6020      	str	r0, [r4, #0]
        return MSG_TIMEOUT;
 80065fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006602:	e000      	b.n	8006606 <osalThreadSuspendTimeoutS+0x4a>
        }

        return MSG_TIMEOUT;
    }

    return ulInterruptStatus;
 8006604:	9801      	ldr	r0, [sp, #4]
}
 8006606:	b002      	add	sp, #8
 8006608:	bd10      	pop	{r4, pc}
 800660a:	bf00      	nop
 800660c:	200011a8 	.word	0x200011a8

08006610 <spiReceive.part.0>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006610:	b570      	push	{r4, r5, r6, lr}
 8006612:	460d      	mov	r5, r1
 8006614:	4616      	mov	r6, r2

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 8006616:	f7fe f9bd 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800661a:	7803      	ldrb	r3, [r0, #0]
 800661c:	2b02      	cmp	r3, #2
 800661e:	d002      	beq.n	8006626 <spiReceive.part.0+0x16>
 8006620:	f7fe f9c8 	bl	80049b4 <vTaskEndScheduler>
 8006624:	e7fe      	b.n	8006624 <spiReceive.part.0+0x14>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8006626:	6843      	ldr	r3, [r0, #4]
 8006628:	681b      	ldr	r3, [r3, #0]
 800662a:	b113      	cbz	r3, 8006632 <spiReceive.part.0+0x22>
 800662c:	f7fe f9c2 	bl	80049b4 <vTaskEndScheduler>
 8006630:	e7fe      	b.n	8006630 <spiReceive.part.0+0x20>
  spiStartReceiveI(spip, n, rxbuf);
 8006632:	2303      	movs	r3, #3
 8006634:	7003      	strb	r3, [r0, #0]
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8006636:	6e43      	ldr	r3, [r0, #100]	; 0x64
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8006638:	4a0f      	ldr	r2, [pc, #60]	; (8006678 <spiReceive.part.0+0x68>)
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800663a:	685c      	ldr	r4, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800663c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800663e:	60e6      	str	r6, [r4, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8006640:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8006644:	6065      	str	r5, [r4, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 8006646:	6023      	str	r3, [r4, #0]
  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 8006648:	6e83      	ldr	r3, [r0, #104]	; 0x68
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
 800664a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800664e:	685b      	ldr	r3, [r3, #4]
 8006650:	3008      	adds	r0, #8
 8006652:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8006654:	6e82      	ldr	r2, [r0, #104]	; 0x68
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8006656:	605d      	str	r5, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 8006658:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800665a:	6822      	ldr	r2, [r4, #0]
 800665c:	f042 0201 	orr.w	r2, r2, #1
 8006660:	6022      	str	r2, [r4, #0]
  dmaStreamEnable(spip->dmatx);
 8006662:	681a      	ldr	r2, [r3, #0]
 8006664:	f042 0201 	orr.w	r2, r2, #1
 8006668:	601a      	str	r2, [r3, #0]
 800666a:	f7ff ffa7 	bl	80065bc <osalThreadSuspendTimeoutS>
  (void) osalThreadSuspendS(&spip->thread);
  osalSysUnlock();
}
 800666e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  osalSysUnlock();
 8006672:	f7fe bbb3 	b.w	8004ddc <osalSysUnlock.lto_priv.0>
 8006676:	bf00      	nop
 8006678:	0800c9ac 	.word	0x0800c9ac

0800667c <osalThreadEnqueueTimeoutS>:
{
 800667c:	b570      	push	{r4, r5, r6, lr}
 800667e:	4605      	mov	r5, r0
    if(!timeout) {
 8006680:	4608      	mov	r0, r1
 8006682:	2900      	cmp	r1, #0
 8006684:	d03f      	beq.n	8006706 <osalThreadEnqueueTimeoutS+0x8a>
    osalDbgCheck(thread_queue != NULL);
 8006686:	b915      	cbnz	r5, 800668e <osalThreadEnqueueTimeoutS+0x12>
 8006688:	f7fe f994 	bl	80049b4 <vTaskEndScheduler>
 800668c:	e7fe      	b.n	800668c <osalThreadEnqueueTimeoutS+0x10>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800668e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006692:	2b00      	cmp	r3, #0
 8006694:	d034      	beq.n	8006700 <osalThreadEnqueueTimeoutS+0x84>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8006696:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 800669a:	b113      	cbz	r3, 80066a2 <osalThreadEnqueueTimeoutS+0x26>
    osalDbgCheckClassS();
 800669c:	f7fe f98a 	bl	80049b4 <vTaskEndScheduler>
 80066a0:	e7fe      	b.n	80066a0 <osalThreadEnqueueTimeoutS+0x24>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80066a2:	4e1a      	ldr	r6, [pc, #104]	; (800670c <osalThreadEnqueueTimeoutS+0x90>)
    portENTER_CRITICAL();
 80066a4:	f7fe f976 	bl	8004994 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 80066a8:	6834      	ldr	r4, [r6, #0]
    portEXIT_CRITICAL();
 80066aa:	f7fe fb8b 	bl	8004dc4 <vPortExitCritical>
    vTaskSetThreadLocalStoragePointer(currentTask, LOCAL_STORAGE_QUEUE_NEXT, thread_queue->head);
 80066ae:	682b      	ldr	r3, [r5, #0]
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 80066b0:	b9e4      	cbnz	r4, 80066ec <osalThreadEnqueueTimeoutS+0x70>
 80066b2:	6832      	ldr	r2, [r6, #0]
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066b4:	6553      	str	r3, [r2, #84]	; 0x54
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 80066b6:	b9dc      	cbnz	r4, 80066f0 <osalThreadEnqueueTimeoutS+0x74>
 80066b8:	6832      	ldr	r2, [r6, #0]
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066ba:	2100      	movs	r1, #0
 80066bc:	6591      	str	r1, [r2, #88]	; 0x58
    if(thread_queue->head){
 80066be:	b103      	cbz	r3, 80066c2 <osalThreadEnqueueTimeoutS+0x46>
 80066c0:	659c      	str	r4, [r3, #88]	; 0x58
    if(!thread_queue->tail){
 80066c2:	686b      	ldr	r3, [r5, #4]
    thread_queue->head = currentTask;
 80066c4:	602c      	str	r4, [r5, #0]
    if(!thread_queue->tail){
 80066c6:	b903      	cbnz	r3, 80066ca <osalThreadEnqueueTimeoutS+0x4e>
        thread_queue->tail = currentTask;
 80066c8:	606c      	str	r4, [r5, #4]
    msg_t msg = osalThreadSuspendTimeoutS(NULL, timeout);
 80066ca:	4601      	mov	r1, r0
 80066cc:	2000      	movs	r0, #0
 80066ce:	f7ff ff75 	bl	80065bc <osalThreadSuspendTimeoutS>
    if(msg == MSG_TIMEOUT) {
 80066d2:	1c43      	adds	r3, r0, #1
 80066d4:	d109      	bne.n	80066ea <osalThreadEnqueueTimeoutS+0x6e>
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80066d6:	b96c      	cbnz	r4, 80066f4 <osalThreadEnqueueTimeoutS+0x78>
 80066d8:	6833      	ldr	r3, [r6, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 80066da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80066dc:	b904      	cbnz	r4, 80066e0 <osalThreadEnqueueTimeoutS+0x64>
 80066de:	6834      	ldr	r4, [r6, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 80066e0:	6da2      	ldr	r2, [r4, #88]	; 0x58
        if(nextTask){
 80066e2:	b14b      	cbz	r3, 80066f8 <osalThreadEnqueueTimeoutS+0x7c>
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 80066e4:	659a      	str	r2, [r3, #88]	; 0x58
        if(prevTask){
 80066e6:	b14a      	cbz	r2, 80066fc <osalThreadEnqueueTimeoutS+0x80>
 80066e8:	6553      	str	r3, [r2, #84]	; 0x54
}
 80066ea:	bd70      	pop	{r4, r5, r6, pc}
 80066ec:	4622      	mov	r2, r4
 80066ee:	e7e1      	b.n	80066b4 <osalThreadEnqueueTimeoutS+0x38>
 80066f0:	4622      	mov	r2, r4
 80066f2:	e7e2      	b.n	80066ba <osalThreadEnqueueTimeoutS+0x3e>
 80066f4:	4623      	mov	r3, r4
 80066f6:	e7f0      	b.n	80066da <osalThreadEnqueueTimeoutS+0x5e>
            thread_queue->tail = prevTask;
 80066f8:	606a      	str	r2, [r5, #4]
 80066fa:	e7f4      	b.n	80066e6 <osalThreadEnqueueTimeoutS+0x6a>
            thread_queue->head = nextTask;
 80066fc:	602b      	str	r3, [r5, #0]
 80066fe:	e7f4      	b.n	80066ea <osalThreadEnqueueTimeoutS+0x6e>
    osalDbgCheckClassS();
 8006700:	f7fe f958 	bl	80049b4 <vTaskEndScheduler>
 8006704:	e7fe      	b.n	8006704 <osalThreadEnqueueTimeoutS+0x88>
        return MSG_TIMEOUT;
 8006706:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800670a:	e7ee      	b.n	80066ea <osalThreadEnqueueTimeoutS+0x6e>
 800670c:	200011a8 	.word	0x200011a8

08006710 <ibqGetFullBufferTimeoutS>:
                                 systime_t timeout) {
 8006710:	b538      	push	{r3, r4, r5, lr}
 8006712:	4604      	mov	r4, r0
 8006714:	460d      	mov	r5, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006716:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800671a:	b12b      	cbz	r3, 8006728 <ibqGetFullBufferTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 800671c:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 8006720:	b16b      	cbz	r3, 800673e <ibqGetFullBufferTimeoutS+0x2e>
  osalDbgCheckClassS();
 8006722:	f7fe f947 	bl	80049b4 <vTaskEndScheduler>
 8006726:	e7fe      	b.n	8006726 <ibqGetFullBufferTimeoutS+0x16>
 8006728:	f7fe f944 	bl	80049b4 <vTaskEndScheduler>
 800672c:	e7fe      	b.n	800672c <ibqGetFullBufferTimeoutS+0x1c>
    if (ibqp->suspended) {
 800672e:	7a23      	ldrb	r3, [r4, #8]
 8006730:	b9ab      	cbnz	r3, 800675e <ibqGetFullBufferTimeoutS+0x4e>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8006732:	4629      	mov	r1, r5
 8006734:	4620      	mov	r0, r4
 8006736:	f7ff ffa1 	bl	800667c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800673a:	2800      	cmp	r0, #0
 800673c:	db0e      	blt.n	800675c <ibqGetFullBufferTimeoutS+0x4c>
  while (ibqIsEmptyI(ibqp)) {
 800673e:	68e3      	ldr	r3, [r4, #12]
 8006740:	2b00      	cmp	r3, #0
 8006742:	d0f4      	beq.n	800672e <ibqGetFullBufferTimeoutS+0x1e>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8006744:	68e3      	ldr	r3, [r4, #12]
 8006746:	b913      	cbnz	r3, 800674e <ibqGetFullBufferTimeoutS+0x3e>
 8006748:	f7fe f934 	bl	80049b4 <vTaskEndScheduler>
 800674c:	e7fe      	b.n	800674c <ibqGetFullBufferTimeoutS+0x3c>
  return MSG_OK;
 800674e:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8006750:	6962      	ldr	r2, [r4, #20]
 8006752:	1d13      	adds	r3, r2, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8006754:	6812      	ldr	r2, [r2, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8006756:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8006758:	4413      	add	r3, r2
 800675a:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 800675c:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 800675e:	f06f 0001 	mvn.w	r0, #1
 8006762:	e7fb      	b.n	800675c <ibqGetFullBufferTimeoutS+0x4c>

08006764 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8006764:	b538      	push	{r3, r4, r5, lr}
 8006766:	460d      	mov	r5, r1
  osalSysLock();
 8006768:	f7fe f914 	bl	8004994 <vPortEnterCritical>
  if (ibqp->ptr == NULL) {
 800676c:	6a83      	ldr	r3, [r0, #40]	; 0x28
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 800676e:	4604      	mov	r4, r0
  if (ibqp->ptr == NULL) {
 8006770:	b943      	cbnz	r3, 8006784 <ibqGetTimeout+0x20>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8006772:	4629      	mov	r1, r5
 8006774:	f7ff ffcc 	bl	8006710 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8006778:	4605      	mov	r5, r0
 800677a:	b118      	cbz	r0, 8006784 <ibqGetTimeout+0x20>
  osalSysUnlock();
 800677c:	f7fe fb2e 	bl	8004ddc <osalSysUnlock.lto_priv.0>
}
 8006780:	4628      	mov	r0, r5
 8006782:	bd38      	pop	{r3, r4, r5, pc}
  msg = (msg_t)*ibqp->ptr;
 8006784:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 8006786:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  msg = (msg_t)*ibqp->ptr;
 8006788:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 800678c:	4293      	cmp	r3, r2
  ibqp->ptr++;
 800678e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 8006790:	d3f4      	bcc.n	800677c <ibqGetTimeout+0x18>
    ibqReleaseEmptyBufferS(ibqp);
 8006792:	4620      	mov	r0, r4
 8006794:	f7fe f91a 	bl	80049cc <ibqReleaseEmptyBufferS>
 8006798:	e7f0      	b.n	800677c <ibqGetTimeout+0x18>

0800679a <_get.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800679a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800679e:	3018      	adds	r0, #24
 80067a0:	f7ff bfe0 	b.w	8006764 <ibqGetTimeout>

080067a4 <_gett.lto_priv.1>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 80067a4:	3018      	adds	r0, #24
 80067a6:	f7ff bfdd 	b.w	8006764 <ibqGetTimeout>

080067aa <obqGetEmptyBufferTimeoutS>:
                                systime_t timeout) {
 80067aa:	b538      	push	{r3, r4, r5, lr}
 80067ac:	4604      	mov	r4, r0
 80067ae:	460d      	mov	r5, r1
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80067b0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80067b4:	b12b      	cbz	r3, 80067c2 <obqGetEmptyBufferTimeoutS+0x18>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 80067b6:	f3ef 8305 	mrs	r3, IPSR
	if( ulCurrentInterrupt == 0 )
 80067ba:	b16b      	cbz	r3, 80067d8 <obqGetEmptyBufferTimeoutS+0x2e>
  osalDbgCheckClassS();
 80067bc:	f7fe f8fa 	bl	80049b4 <vTaskEndScheduler>
 80067c0:	e7fe      	b.n	80067c0 <obqGetEmptyBufferTimeoutS+0x16>
 80067c2:	f7fe f8f7 	bl	80049b4 <vTaskEndScheduler>
 80067c6:	e7fe      	b.n	80067c6 <obqGetEmptyBufferTimeoutS+0x1c>
    if (obqp->suspended) {
 80067c8:	7a23      	ldrb	r3, [r4, #8]
 80067ca:	b9ab      	cbnz	r3, 80067f8 <obqGetEmptyBufferTimeoutS+0x4e>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 80067cc:	4629      	mov	r1, r5
 80067ce:	4620      	mov	r0, r4
 80067d0:	f7ff ff54 	bl	800667c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80067d4:	2800      	cmp	r0, #0
 80067d6:	db0e      	blt.n	80067f6 <obqGetEmptyBufferTimeoutS+0x4c>
  while (obqIsFullI(obqp)) {
 80067d8:	68e3      	ldr	r3, [r4, #12]
 80067da:	2b00      	cmp	r3, #0
 80067dc:	d0f4      	beq.n	80067c8 <obqGetEmptyBufferTimeoutS+0x1e>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80067de:	68e3      	ldr	r3, [r4, #12]
 80067e0:	b913      	cbnz	r3, 80067e8 <obqGetEmptyBufferTimeoutS+0x3e>
 80067e2:	f7fe f8e7 	bl	80049b4 <vTaskEndScheduler>
 80067e6:	e7fe      	b.n	80067e6 <obqGetEmptyBufferTimeoutS+0x3c>
  return MSG_OK;
 80067e8:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80067ea:	6923      	ldr	r3, [r4, #16]
 80067ec:	1d1a      	adds	r2, r3, #4
 80067ee:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 80067f0:	69e2      	ldr	r2, [r4, #28]
 80067f2:	4413      	add	r3, r2
 80067f4:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 80067f6:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 80067f8:	f06f 0001 	mvn.w	r0, #1
 80067fc:	e7fb      	b.n	80067f6 <obqGetEmptyBufferTimeoutS+0x4c>

080067fe <obqPutTimeout>:
                    systime_t timeout) {
 80067fe:	b570      	push	{r4, r5, r6, lr}
 8006800:	460d      	mov	r5, r1
 8006802:	4616      	mov	r6, r2
  osalSysLock();
 8006804:	f7fe f8c6 	bl	8004994 <vPortEnterCritical>
  if (obqp->ptr == NULL) {
 8006808:	6a83      	ldr	r3, [r0, #40]	; 0x28
                    systime_t timeout) {
 800680a:	4604      	mov	r4, r0
  if (obqp->ptr == NULL) {
 800680c:	b933      	cbnz	r3, 800681c <obqPutTimeout+0x1e>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800680e:	4631      	mov	r1, r6
 8006810:	f7ff ffcb 	bl	80067aa <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8006814:	b110      	cbz	r0, 800681c <obqPutTimeout+0x1e>
      osalSysUnlock();
 8006816:	f7fe fae1 	bl	8004ddc <osalSysUnlock.lto_priv.0>
}
 800681a:	bd70      	pop	{r4, r5, r6, pc}
  *obqp->ptr = b;
 800681c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800681e:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8006820:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8006822:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
 8006824:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8006826:	4293      	cmp	r3, r2
  obqp->ptr++;
 8006828:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 800682a:	d304      	bcc.n	8006836 <obqPutTimeout+0x38>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800682c:	69e1      	ldr	r1, [r4, #28]
 800682e:	4620      	mov	r0, r4
 8006830:	3904      	subs	r1, #4
 8006832:	f7fe f905 	bl	8004a40 <obqPostFullBufferS>
  osalSysUnlock();
 8006836:	f7fe fad1 	bl	8004ddc <osalSysUnlock.lto_priv.0>
  return MSG_OK;
 800683a:	2000      	movs	r0, #0
 800683c:	e7ed      	b.n	800681a <obqPutTimeout+0x1c>

0800683e <_put.lto_priv.1>:
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800683e:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static msg_t _put(void *ip, uint8_t b) {
 8006842:	b538      	push	{r3, r4, r5, lr}
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006844:	6893      	ldr	r3, [r2, #8]
static msg_t _put(void *ip, uint8_t b) {
 8006846:	4604      	mov	r4, r0
 8006848:	460d      	mov	r5, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800684a:	b113      	cbz	r3, 8006852 <_put.lto_priv.1+0x14>
 800684c:	2101      	movs	r1, #1
 800684e:	6810      	ldr	r0, [r2, #0]
 8006850:	4798      	blx	r3
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8006852:	4629      	mov	r1, r5
 8006854:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8006858:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
}
 800685c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8006860:	f7ff bfcd 	b.w	80067fe <obqPutTimeout>

08006864 <_putt.lto_priv.1>:
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8006864:	b570      	push	{r4, r5, r6, lr}
 8006866:	4616      	mov	r6, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006868:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 800686c:	4604      	mov	r4, r0
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 800686e:	6893      	ldr	r3, [r2, #8]
static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {
 8006870:	460d      	mov	r5, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006872:	b113      	cbz	r3, 800687a <_putt.lto_priv.1+0x16>
 8006874:	2101      	movs	r1, #1
 8006876:	6810      	ldr	r0, [r2, #0]
 8006878:	4798      	blx	r3
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800687a:	4632      	mov	r2, r6
 800687c:	4629      	mov	r1, r5
 800687e:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8006882:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8006886:	f7ff bfba 	b.w	80067fe <obqPutTimeout>

0800688a <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800688a:	b538      	push	{r3, r4, r5, lr}
 800688c:	4604      	mov	r4, r0
 800688e:	460d      	mov	r5, r1
  uint8_t b;

  osalSysLock();
 8006890:	f7fe f880 	bl	8004994 <vPortEnterCritical>

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8006894:	68a3      	ldr	r3, [r4, #8]
 8006896:	b19b      	cbz	r3, 80068c0 <iqGetTimeout+0x36>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8006898:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800689a:	69a2      	ldr	r2, [r4, #24]
  iqp->q_counter--;
 800689c:	3b01      	subs	r3, #1
 800689e:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80068a0:	1c53      	adds	r3, r2, #1
 80068a2:	61a3      	str	r3, [r4, #24]
 80068a4:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 80068a6:	6922      	ldr	r2, [r4, #16]
 80068a8:	4293      	cmp	r3, r2
    iqp->q_rdptr = iqp->q_buffer;
 80068aa:	bf24      	itt	cs
 80068ac:	68e3      	ldrcs	r3, [r4, #12]
 80068ae:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80068b0:	69e3      	ldr	r3, [r4, #28]
 80068b2:	b10b      	cbz	r3, 80068b8 <iqGetTimeout+0x2e>
    iqp->q_notify(iqp);
 80068b4:	4620      	mov	r0, r4
 80068b6:	4798      	blx	r3
  }

  osalSysUnlock();
 80068b8:	f7fe fa90 	bl	8004ddc <osalSysUnlock.lto_priv.0>

  return (msg_t)b;
 80068bc:	4628      	mov	r0, r5
 80068be:	e007      	b.n	80068d0 <iqGetTimeout+0x46>
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80068c0:	4629      	mov	r1, r5
 80068c2:	4620      	mov	r0, r4
 80068c4:	f7ff feda 	bl	800667c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80068c8:	2800      	cmp	r0, #0
 80068ca:	dae3      	bge.n	8006894 <iqGetTimeout+0xa>
      osalSysUnlock();
 80068cc:	f7fe fa86 	bl	8004ddc <osalSysUnlock.lto_priv.0>
}
 80068d0:	bd38      	pop	{r3, r4, r5, pc}

080068d2 <_get.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80068d2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80068d6:	3018      	adds	r0, #24
 80068d8:	f7ff bfd7 	b.w	800688a <iqGetTimeout>

080068dc <_gett.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80068dc:	3018      	adds	r0, #24
 80068de:	f7ff bfd4 	b.w	800688a <iqGetTimeout>
	...

080068e4 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80068e4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80068e8:	4604      	mov	r4, r0
 80068ea:	460d      	mov	r5, r1
 80068ec:	461f      	mov	r7, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 80068ee:	4616      	mov	r6, r2
 80068f0:	b912      	cbnz	r2, 80068f8 <iqReadTimeout+0x14>
 80068f2:	f7fe f85f 	bl	80049b4 <vTaskEndScheduler>
 80068f6:	e7fe      	b.n	80068f6 <iqReadTimeout+0x12>
  size_t r = 0;
 80068f8:	f04f 0800 	mov.w	r8, #0
		xReturn = xTickCount;
 80068fc:	f8df a088 	ldr.w	sl, [pc, #136]	; 8006988 <iqReadTimeout+0xa4>
  qnotify_t nfy = iqp->q_notify;
 8006900:	f8d0 901c 	ldr.w	r9, [r0, #28]

  osalSysLock();
 8006904:	f7fe f846 	bl	8004994 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006908:	f7ff fb00 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800690c:	f8da 3000 	ldr.w	r3, [sl]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006910:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 8006914:	18fb      	adds	r3, r7, r3
 8006916:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
 8006918:	68a3      	ldr	r3, [r4, #8]
 800691a:	b1e3      	cbz	r3, 8006956 <iqReadTimeout+0x72>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800691c:	68a3      	ldr	r3, [r4, #8]
 800691e:	3b01      	subs	r3, #1
 8006920:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8006922:	69a3      	ldr	r3, [r4, #24]
 8006924:	1c5a      	adds	r2, r3, #1
 8006926:	61a2      	str	r2, [r4, #24]
 8006928:	781b      	ldrb	r3, [r3, #0]
 800692a:	f805 3b01 	strb.w	r3, [r5], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 800692e:	6923      	ldr	r3, [r4, #16]
 8006930:	69a2      	ldr	r2, [r4, #24]
 8006932:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8006934:	bf24      	itt	cs
 8006936:	68e3      	ldrcs	r3, [r4, #12]
 8006938:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800693a:	f1b9 0f00 	cmp.w	r9, #0
 800693e:	d001      	beq.n	8006944 <iqReadTimeout+0x60>
      nfy(iqp);
 8006940:	4620      	mov	r0, r4
 8006942:	47c8      	blx	r9
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8006944:	f7fe fa4a 	bl	8004ddc <osalSysUnlock.lto_priv.0>

    r++;
    if (--n == 0U) {
 8006948:	3e01      	subs	r6, #1
    r++;
 800694a:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 800694e:	d016      	beq.n	800697e <iqReadTimeout+0x9a>
      return r;
    }

    osalSysLock();
 8006950:	f7fe f820 	bl	8004994 <vPortEnterCritical>
    while (iqIsEmptyI(iqp)) {
 8006954:	e7e0      	b.n	8006918 <iqReadTimeout+0x34>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006956:	f11b 0f03 	cmn.w	fp, #3
 800695a:	d906      	bls.n	800696a <iqReadTimeout+0x86>
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800695c:	4639      	mov	r1, r7
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
 800695e:	4620      	mov	r0, r4
 8006960:	f7ff fe8c 	bl	800667c <osalThreadEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8006964:	2800      	cmp	r0, #0
 8006966:	d0d7      	beq.n	8006918 <iqReadTimeout+0x34>
 8006968:	e007      	b.n	800697a <iqReadTimeout+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800696a:	f7ff facf 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800696e:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8006972:	9b01      	ldr	r3, [sp, #4]
 8006974:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8006976:	428f      	cmp	r7, r1
 8006978:	d2f1      	bcs.n	800695e <iqReadTimeout+0x7a>
        osalSysUnlock();
 800697a:	f7fe fa2f 	bl	8004ddc <osalSysUnlock.lto_priv.0>
  }
}
 800697e:	4640      	mov	r0, r8
 8006980:	b003      	add	sp, #12
 8006982:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006986:	bf00      	nop
 8006988:	20001648 	.word	0x20001648

0800698c <_read.lto_priv.0>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800698c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006990:	3018      	adds	r0, #24
 8006992:	f7ff bfa7 	b.w	80068e4 <iqReadTimeout>

08006996 <_readt.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8006996:	3018      	adds	r0, #24
 8006998:	f7ff bfa4 	b.w	80068e4 <iqReadTimeout>

0800699c <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 800699c:	b570      	push	{r4, r5, r6, lr}
 800699e:	4604      	mov	r4, r0
 80069a0:	460d      	mov	r5, r1
 80069a2:	4616      	mov	r6, r2

  osalSysLock();
 80069a4:	f7fd fff6 	bl	8004994 <vPortEnterCritical>

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80069a8:	68a3      	ldr	r3, [r4, #8]
 80069aa:	b1a3      	cbz	r3, 80069d6 <oqPutTimeout+0x3a>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80069ac:	68a3      	ldr	r3, [r4, #8]
 80069ae:	3b01      	subs	r3, #1
 80069b0:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80069b2:	6963      	ldr	r3, [r4, #20]
 80069b4:	1c5a      	adds	r2, r3, #1
 80069b6:	6162      	str	r2, [r4, #20]
 80069b8:	701d      	strb	r5, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80069ba:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 80069be:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80069c0:	bf24      	itt	cs
 80069c2:	68e3      	ldrcs	r3, [r4, #12]
 80069c4:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80069c6:	69e3      	ldr	r3, [r4, #28]
 80069c8:	b10b      	cbz	r3, 80069ce <oqPutTimeout+0x32>
    oqp->q_notify(oqp);
 80069ca:	4620      	mov	r0, r4
 80069cc:	4798      	blx	r3
  }

  osalSysUnlock();
 80069ce:	f7fe fa05 	bl	8004ddc <osalSysUnlock.lto_priv.0>
 80069d2:	2000      	movs	r0, #0
 80069d4:	e007      	b.n	80069e6 <oqPutTimeout+0x4a>
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80069d6:	4631      	mov	r1, r6
 80069d8:	4620      	mov	r0, r4
 80069da:	f7ff fe4f 	bl	800667c <osalThreadEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80069de:	2800      	cmp	r0, #0
 80069e0:	dae2      	bge.n	80069a8 <oqPutTimeout+0xc>
      osalSysUnlock();
 80069e2:	f7fe f9fb 	bl	8004ddc <osalSysUnlock.lto_priv.0>

  return MSG_OK;
}
 80069e6:	bd70      	pop	{r4, r5, r6, pc}

080069e8 <_put.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80069e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80069ec:	303c      	adds	r0, #60	; 0x3c
 80069ee:	f7ff bfd5 	b.w	800699c <oqPutTimeout>

080069f2 <_putt.lto_priv.0>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80069f2:	303c      	adds	r0, #60	; 0x3c
 80069f4:	f7ff bfd2 	b.w	800699c <oqPutTimeout>

080069f8 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 80069f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80069fc:	4604      	mov	r4, r0
 80069fe:	460d      	mov	r5, r1
 8006a00:	461f      	mov	r7, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 8006a02:	4616      	mov	r6, r2
 8006a04:	b912      	cbnz	r2, 8006a0c <oqWriteTimeout+0x14>
 8006a06:	f7fd ffd5 	bl	80049b4 <vTaskEndScheduler>
 8006a0a:	e7fe      	b.n	8006a0a <oqWriteTimeout+0x12>
  size_t w = 0;
 8006a0c:	f04f 0800 	mov.w	r8, #0
 8006a10:	f8df a088 	ldr.w	sl, [pc, #136]	; 8006a9c <oqWriteTimeout+0xa4>
  qnotify_t nfy = oqp->q_notify;
 8006a14:	f8d0 901c 	ldr.w	r9, [r0, #28]

  osalSysLock();
 8006a18:	f7fd ffbc 	bl	8004994 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006a1c:	f7ff fa76 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8006a20:	f8da 3000 	ldr.w	r3, [sl]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006a24:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 8006a28:	18fb      	adds	r3, r7, r3
 8006a2a:	9301      	str	r3, [sp, #4]
    while (oqIsFullI(oqp)) {
 8006a2c:	68a3      	ldr	r3, [r4, #8]
 8006a2e:	b1e3      	cbz	r3, 8006a6a <oqWriteTimeout+0x72>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8006a30:	68a3      	ldr	r3, [r4, #8]
 8006a32:	3b01      	subs	r3, #1
 8006a34:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8006a36:	6963      	ldr	r3, [r4, #20]
 8006a38:	1c5a      	adds	r2, r3, #1
 8006a3a:	6162      	str	r2, [r4, #20]
 8006a3c:	f815 2b01 	ldrb.w	r2, [r5], #1
 8006a40:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8006a42:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8006a46:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8006a48:	bf24      	itt	cs
 8006a4a:	68e3      	ldrcs	r3, [r4, #12]
 8006a4c:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8006a4e:	f1b9 0f00 	cmp.w	r9, #0
 8006a52:	d001      	beq.n	8006a58 <oqWriteTimeout+0x60>
      nfy(oqp);
 8006a54:	4620      	mov	r0, r4
 8006a56:	47c8      	blx	r9
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
 8006a58:	f7fe f9c0 	bl	8004ddc <osalSysUnlock.lto_priv.0>

    w++;
    if (--n == 0U) {
 8006a5c:	3e01      	subs	r6, #1
    w++;
 8006a5e:	f108 0801 	add.w	r8, r8, #1
    if (--n == 0U) {
 8006a62:	d016      	beq.n	8006a92 <oqWriteTimeout+0x9a>
      return w;
    }

    osalSysLock();
 8006a64:	f7fd ff96 	bl	8004994 <vPortEnterCritical>
  while (true) {
 8006a68:	e7e0      	b.n	8006a2c <oqWriteTimeout+0x34>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8006a6a:	f11b 0f03 	cmn.w	fp, #3
 8006a6e:	d906      	bls.n	8006a7e <oqWriteTimeout+0x86>
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8006a70:	4639      	mov	r1, r7
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
 8006a72:	4620      	mov	r0, r4
 8006a74:	f7ff fe02 	bl	800667c <osalThreadEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8006a78:	2800      	cmp	r0, #0
 8006a7a:	d0d7      	beq.n	8006a2c <oqWriteTimeout+0x34>
 8006a7c:	e007      	b.n	8006a8e <oqWriteTimeout+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006a7e:	f7ff fa45 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8006a82:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8006a86:	9b01      	ldr	r3, [sp, #4]
 8006a88:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8006a8a:	428f      	cmp	r7, r1
 8006a8c:	d2f1      	bcs.n	8006a72 <oqWriteTimeout+0x7a>
        osalSysUnlock();
 8006a8e:	f7fe f9a5 	bl	8004ddc <osalSysUnlock.lto_priv.0>
  }
}
 8006a92:	4640      	mov	r0, r8
 8006a94:	b003      	add	sp, #12
 8006a96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006a9a:	bf00      	nop
 8006a9c:	20001648 	.word	0x20001648

08006aa0 <_write.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8006aa0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006aa4:	303c      	adds	r0, #60	; 0x3c
 8006aa6:	f7ff bfa7 	b.w	80069f8 <oqWriteTimeout>

08006aaa <_writet.lto_priv.0>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8006aaa:	303c      	adds	r0, #60	; 0x3c
 8006aac:	f7ff bfa4 	b.w	80069f8 <oqWriteTimeout>

08006ab0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8006ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8006ab2:	f100 040b 	add.w	r4, r0, #11
 8006ab6:	4623      	mov	r3, r4
  do {
    i = (int)(l % radix);
 8006ab8:	460d      	mov	r5, r1
 8006aba:	fbb1 f1f2 	udiv	r1, r1, r2
 8006abe:	fb02 5711 	mls	r7, r2, r1, r5
    i += '0';
 8006ac2:	f107 0630 	add.w	r6, r7, #48	; 0x30
    if (i > '9')
 8006ac6:	2e39      	cmp	r6, #57	; 0x39
      i += 'A' - '0' - 10;
 8006ac8:	bfc8      	it	gt
 8006aca:	f107 0637 	addgt.w	r6, r7, #55	; 0x37
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8006ace:	4295      	cmp	r5, r2
    *--q = i;
 8006ad0:	f803 6d01 	strb.w	r6, [r3, #-1]!
  } while ((ll /= radix) != 0);
 8006ad4:	d2f0      	bcs.n	8006ab8 <long_to_string_with_divisor.constprop.0+0x8>
 8006ad6:	1e42      	subs	r2, r0, #1

  i = (int)(p + MAX_FILLER - q);
 8006ad8:	1ae1      	subs	r1, r4, r3
  do
    *p++ = *q++;
 8006ada:	f813 5b01 	ldrb.w	r5, [r3], #1
  while (--i);
 8006ade:	429c      	cmp	r4, r3
    *p++ = *q++;
 8006ae0:	f802 5f01 	strb.w	r5, [r2, #1]!
  while (--i);
 8006ae4:	d1f9      	bne.n	8006ada <long_to_string_with_divisor.constprop.0+0x2a>

  return p;
}
 8006ae6:	4408      	add	r0, r1
 8006ae8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08006aec <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006aec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006af0:	460b      	mov	r3, r1
 8006af2:	4680      	mov	r8, r0
 8006af4:	4614      	mov	r4, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8006af6:	f04f 0900 	mov.w	r9, #0
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006afa:	b087      	sub	sp, #28
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006afc:	461f      	mov	r7, r3
 8006afe:	f817 1b01 	ldrb.w	r1, [r7], #1
    if (c == 0)
 8006b02:	2900      	cmp	r1, #0
 8006b04:	f000 8152 	beq.w	8006dac <chvprintf+0x2c0>
      return n;
    if (c != '%') {
 8006b08:	2925      	cmp	r1, #37	; 0x25
 8006b0a:	d007      	beq.n	8006b1c <chvprintf+0x30>
      streamPut(chp, (uint8_t)c);
 8006b0c:	f8d8 3000 	ldr.w	r3, [r8]
 8006b10:	4640      	mov	r0, r8
 8006b12:	689b      	ldr	r3, [r3, #8]
 8006b14:	4798      	blx	r3
      n++;
 8006b16:	f109 0901 	add.w	r9, r9, #1
      continue;
 8006b1a:	e112      	b.n	8006d42 <chvprintf+0x256>
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8006b1c:	785a      	ldrb	r2, [r3, #1]
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8006b1e:	f04f 0b00 	mov.w	fp, #0
    if (*fmt == '-') {
 8006b22:	2a2d      	cmp	r2, #45	; 0x2d
      fmt++;
 8006b24:	bf08      	it	eq
 8006b26:	1c9f      	addeq	r7, r3, #2
    if (*fmt == '0') {
 8006b28:	f897 a000 	ldrb.w	sl, [r7]
      left_align = TRUE;
 8006b2c:	bf0c      	ite	eq
 8006b2e:	2301      	moveq	r3, #1
    left_align = FALSE;
 8006b30:	2300      	movne	r3, #0
    if (*fmt == '0') {
 8006b32:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
    filler = ' ';
 8006b36:	bf18      	it	ne
 8006b38:	f04f 0a20 	movne.w	sl, #32
    left_align = FALSE;
 8006b3c:	9301      	str	r3, [sp, #4]
      fmt++;
 8006b3e:	bf08      	it	eq
 8006b40:	3701      	addeq	r7, #1
    while (TRUE) {
      c = *fmt++;
 8006b42:	f817 2b01 	ldrb.w	r2, [r7], #1
      if (c >= '0' && c <= '9')
 8006b46:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
 8006b4a:	b2c9      	uxtb	r1, r1
 8006b4c:	2909      	cmp	r1, #9
 8006b4e:	d904      	bls.n	8006b5a <chvprintf+0x6e>
        c -= '0';
      else if (c == '*')
 8006b50:	2a2a      	cmp	r2, #42	; 0x2a
 8006b52:	d106      	bne.n	8006b62 <chvprintf+0x76>
        c = va_arg(ap, int);
 8006b54:	f854 1b04 	ldr.w	r1, [r4], #4
 8006b58:	b2c9      	uxtb	r1, r1
      else
        break;
      width = width * 10 + c;
 8006b5a:	230a      	movs	r3, #10
 8006b5c:	fb03 1b0b 	mla	fp, r3, fp, r1
      c = *fmt++;
 8006b60:	e7ef      	b.n	8006b42 <chvprintf+0x56>
    }
    precision = 0;
    if (c == '.') {
 8006b62:	2a2e      	cmp	r2, #46	; 0x2e
    precision = 0;
 8006b64:	f04f 0100 	mov.w	r1, #0
    if (c == '.') {
 8006b68:	d10f      	bne.n	8006b8a <chvprintf+0x9e>
      while (TRUE) {
        c = *fmt++;
 8006b6a:	f817 2b01 	ldrb.w	r2, [r7], #1
        if (c >= '0' && c <= '9')
 8006b6e:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
 8006b72:	b2c0      	uxtb	r0, r0
 8006b74:	2809      	cmp	r0, #9
 8006b76:	d904      	bls.n	8006b82 <chvprintf+0x96>
          c -= '0';
        else if (c == '*')
 8006b78:	2a2a      	cmp	r2, #42	; 0x2a
 8006b7a:	d106      	bne.n	8006b8a <chvprintf+0x9e>
          c = va_arg(ap, int);
 8006b7c:	f854 0b04 	ldr.w	r0, [r4], #4
 8006b80:	b2c0      	uxtb	r0, r0
        else
          break;
        precision *= 10;
        precision += c;
 8006b82:	230a      	movs	r3, #10
 8006b84:	fb03 0101 	mla	r1, r3, r1, r0
        c = *fmt++;
 8006b88:	e7ef      	b.n	8006b6a <chvprintf+0x7e>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8006b8a:	f002 00df 	and.w	r0, r2, #223	; 0xdf
 8006b8e:	284c      	cmp	r0, #76	; 0x4c
 8006b90:	d115      	bne.n	8006bbe <chvprintf+0xd2>
      is_long = TRUE;
      if (*fmt)
 8006b92:	7838      	ldrb	r0, [r7, #0]
 8006b94:	b108      	cbz	r0, 8006b9a <chvprintf+0xae>
        c = *fmt++;
 8006b96:	4602      	mov	r2, r0
 8006b98:	3701      	adds	r7, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8006b9a:	2a64      	cmp	r2, #100	; 0x64
 8006b9c:	d06f      	beq.n	8006c7e <chvprintf+0x192>
 8006b9e:	f200 80e3 	bhi.w	8006d68 <chvprintf+0x27c>
 8006ba2:	2a58      	cmp	r2, #88	; 0x58
 8006ba4:	f000 80d9 	beq.w	8006d5a <chvprintf+0x26e>
 8006ba8:	d821      	bhi.n	8006bee <chvprintf+0x102>
 8006baa:	2a4f      	cmp	r2, #79	; 0x4f
 8006bac:	f000 80b5 	beq.w	8006d1a <chvprintf+0x22e>
 8006bb0:	f200 80d5 	bhi.w	8006d5e <chvprintf+0x272>
 8006bb4:	2a44      	cmp	r2, #68	; 0x44
 8006bb6:	d062      	beq.n	8006c7e <chvprintf+0x192>
 8006bb8:	2a49      	cmp	r2, #73	; 0x49
 8006bba:	d060      	beq.n	8006c7e <chvprintf+0x192>
 8006bbc:	e010      	b.n	8006be0 <chvprintf+0xf4>
      is_long = (c >= 'A') && (c <= 'Z');
 8006bbe:	f1a2 0041 	sub.w	r0, r2, #65	; 0x41
    switch (c) {
 8006bc2:	2a64      	cmp	r2, #100	; 0x64
      is_long = (c >= 'A') && (c <= 'Z');
 8006bc4:	b2c0      	uxtb	r0, r0
    switch (c) {
 8006bc6:	d056      	beq.n	8006c76 <chvprintf+0x18a>
 8006bc8:	d81e      	bhi.n	8006c08 <chvprintf+0x11c>
 8006bca:	2a55      	cmp	r2, #85	; 0x55
 8006bcc:	f000 8096 	beq.w	8006cfc <chvprintf+0x210>
 8006bd0:	d80a      	bhi.n	8006be8 <chvprintf+0xfc>
 8006bd2:	2a49      	cmp	r2, #73	; 0x49
 8006bd4:	d04f      	beq.n	8006c76 <chvprintf+0x18a>
 8006bd6:	2a4f      	cmp	r2, #79	; 0x4f
 8006bd8:	f000 809b 	beq.w	8006d12 <chvprintf+0x226>
 8006bdc:	2a44      	cmp	r2, #68	; 0x44
 8006bde:	d04a      	beq.n	8006c76 <chvprintf+0x18a>
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 8006be0:	4626      	mov	r6, r4
      *p++ = c;
 8006be2:	f88d 200c 	strb.w	r2, [sp, #12]
      break;
 8006be6:	e00b      	b.n	8006c00 <chvprintf+0x114>
    switch (c) {
 8006be8:	2a58      	cmp	r2, #88	; 0x58
 8006bea:	f000 8094 	beq.w	8006d16 <chvprintf+0x22a>
 8006bee:	2a63      	cmp	r2, #99	; 0x63
 8006bf0:	d1f6      	bne.n	8006be0 <chvprintf+0xf4>
      *p++ = va_arg(ap, int);
 8006bf2:	4626      	mov	r6, r4
      filler = ' ';
 8006bf4:	f04f 0a20 	mov.w	sl, #32
      *p++ = va_arg(ap, int);
 8006bf8:	f856 2b04 	ldr.w	r2, [r6], #4
 8006bfc:	f88d 200c 	strb.w	r2, [sp, #12]
    s = tmpbuf;
 8006c00:	ac03      	add	r4, sp, #12
      *p++ = c;
 8006c02:	f10d 000d 	add.w	r0, sp, #13
      break;
 8006c06:	e04c      	b.n	8006ca2 <chvprintf+0x1b6>
    switch (c) {
 8006c08:	2a69      	cmp	r2, #105	; 0x69
 8006c0a:	d034      	beq.n	8006c76 <chvprintf+0x18a>
 8006c0c:	f1a2 056f 	sub.w	r5, r2, #111	; 0x6f
 8006c10:	b2ee      	uxtb	r6, r5
 8006c12:	2e09      	cmp	r6, #9
 8006c14:	d8e4      	bhi.n	8006be0 <chvprintf+0xf4>
 8006c16:	2d09      	cmp	r5, #9
 8006c18:	d8e2      	bhi.n	8006be0 <chvprintf+0xf4>
 8006c1a:	a301      	add	r3, pc, #4	; (adr r3, 8006c20 <chvprintf+0x134>)
 8006c1c:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 8006c20:	08006d13 	.word	0x08006d13
 8006c24:	08006be1 	.word	0x08006be1
 8006c28:	08006be1 	.word	0x08006be1
 8006c2c:	08006be1 	.word	0x08006be1
 8006c30:	08006c49 	.word	0x08006c49
 8006c34:	08006be1 	.word	0x08006be1
 8006c38:	08006cfd 	.word	0x08006cfd
 8006c3c:	08006be1 	.word	0x08006be1
 8006c40:	08006be1 	.word	0x08006be1
 8006c44:	08006d17 	.word	0x08006d17
      if ((s = va_arg(ap, char *)) == 0)
 8006c48:	4626      	mov	r6, r4
        s = "(null)";
 8006c4a:	4b5a      	ldr	r3, [pc, #360]	; (8006db4 <chvprintf+0x2c8>)
      if ((s = va_arg(ap, char *)) == 0)
 8006c4c:	f856 4b04 	ldr.w	r4, [r6], #4
        precision = 32767;
 8006c50:	f647 72ff 	movw	r2, #32767	; 0x7fff
        s = "(null)";
 8006c54:	2c00      	cmp	r4, #0
 8006c56:	bf08      	it	eq
 8006c58:	461c      	moveq	r4, r3
        precision = 32767;
 8006c5a:	2900      	cmp	r1, #0
 8006c5c:	bf08      	it	eq
 8006c5e:	4611      	moveq	r1, r2
 8006c60:	4620      	mov	r0, r4
 8006c62:	4421      	add	r1, r4
      for (p = s; *p && (--precision >= 0); p++)
 8006c64:	7802      	ldrb	r2, [r0, #0]
 8006c66:	b10a      	cbz	r2, 8006c6c <chvprintf+0x180>
 8006c68:	4288      	cmp	r0, r1
 8006c6a:	d102      	bne.n	8006c72 <chvprintf+0x186>
      filler = ' ';
 8006c6c:	f04f 0a20 	mov.w	sl, #32
 8006c70:	e017      	b.n	8006ca2 <chvprintf+0x1b6>
      for (p = s; *p && (--precision >= 0); p++)
 8006c72:	3001      	adds	r0, #1
 8006c74:	e7f6      	b.n	8006c64 <chvprintf+0x178>
      if (is_long)
 8006c76:	2819      	cmp	r0, #25
        l = va_arg(ap, int);
 8006c78:	f104 0604 	add.w	r6, r4, #4
      if (is_long)
 8006c7c:	d83c      	bhi.n	8006cf8 <chvprintf+0x20c>
        l = va_arg(ap, long);
 8006c7e:	4626      	mov	r6, r4
 8006c80:	f856 1b04 	ldr.w	r1, [r6], #4
      if (l < 0) {
 8006c84:	2900      	cmp	r1, #0
        *p++ = '-';
 8006c86:	bfbc      	itt	lt
 8006c88:	222d      	movlt	r2, #45	; 0x2d
 8006c8a:	f88d 200c 	strblt.w	r2, [sp, #12]
  return long_to_string_with_divisor(p, num, radix, 0);
 8006c8e:	f04f 020a 	mov.w	r2, #10
        l = -l;
 8006c92:	bfba      	itte	lt
 8006c94:	4249      	neglt	r1, r1
        *p++ = '-';
 8006c96:	f10d 000d 	addlt.w	r0, sp, #13
    p = tmpbuf;
 8006c9a:	a803      	addge	r0, sp, #12
  return long_to_string_with_divisor(p, num, radix, 0);
 8006c9c:	f7ff ff08 	bl	8006ab0 <long_to_string_with_divisor.constprop.0>
    s = tmpbuf;
 8006ca0:	ac03      	add	r4, sp, #12
    }
    i = (int)(p - s);
 8006ca2:	1b05      	subs	r5, r0, r4
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006ca4:	9901      	ldr	r1, [sp, #4]
    if ((width -= i) < 0)
 8006ca6:	ebab 0305 	sub.w	r3, fp, r5
 8006caa:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
    if (left_align == FALSE)
 8006cae:	2900      	cmp	r1, #0
 8006cb0:	d149      	bne.n	8006d46 <chvprintf+0x25a>
      width = -width;
    if (width < 0) {
 8006cb2:	2b00      	cmp	r3, #0
      width = -width;
 8006cb4:	f1c2 0b00 	rsb	fp, r2, #0
    if (width < 0) {
 8006cb8:	dd1c      	ble.n	8006cf4 <chvprintf+0x208>
      if (*s == '-' && filler == '0') {
 8006cba:	7821      	ldrb	r1, [r4, #0]
 8006cbc:	292d      	cmp	r1, #45	; 0x2d
 8006cbe:	d10d      	bne.n	8006cdc <chvprintf+0x1f0>
 8006cc0:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
 8006cc4:	d10a      	bne.n	8006cdc <chvprintf+0x1f0>
        streamPut(chp, (uint8_t)*s++);
 8006cc6:	f8d8 3000 	ldr.w	r3, [r8]
 8006cca:	4640      	mov	r0, r8
 8006ccc:	689b      	ldr	r3, [r3, #8]
 8006cce:	9201      	str	r2, [sp, #4]
 8006cd0:	4798      	blx	r3
 8006cd2:	9a01      	ldr	r2, [sp, #4]
        n++;
        i--;
 8006cd4:	3d01      	subs	r5, #1
      n++;
 8006cd6:	f109 0901 	add.w	r9, r9, #1
        streamPut(chp, (uint8_t)*s++);
 8006cda:	3401      	adds	r4, #1
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8006cdc:	f8d8 3000 	ldr.w	r3, [r8]
 8006ce0:	4651      	mov	r1, sl
 8006ce2:	4640      	mov	r0, r8
 8006ce4:	689b      	ldr	r3, [r3, #8]
 8006ce6:	9201      	str	r2, [sp, #4]
 8006ce8:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8006cea:	f11b 0b01 	adds.w	fp, fp, #1
 8006cee:	9a01      	ldr	r2, [sp, #4]
 8006cf0:	d1f4      	bne.n	8006cdc <chvprintf+0x1f0>
 8006cf2:	4491      	add	r9, r2
 8006cf4:	462b      	mov	r3, r5
 8006cf6:	e01b      	b.n	8006d30 <chvprintf+0x244>
        l = va_arg(ap, int);
 8006cf8:	6821      	ldr	r1, [r4, #0]
 8006cfa:	e7c3      	b.n	8006c84 <chvprintf+0x198>
      c = 10;
 8006cfc:	220a      	movs	r2, #10
        l = va_arg(ap, unsigned int);
 8006cfe:	4626      	mov	r6, r4
      if (is_long)
 8006d00:	2819      	cmp	r0, #25
        l = va_arg(ap, unsigned int);
 8006d02:	f856 1b04 	ldr.w	r1, [r6], #4
      if (is_long)
 8006d06:	d802      	bhi.n	8006d0e <chvprintf+0x222>
        l = va_arg(ap, unsigned long);
 8006d08:	4626      	mov	r6, r4
 8006d0a:	f856 1b04 	ldr.w	r1, [r6], #4
  return long_to_string_with_divisor(p, num, radix, 0);
 8006d0e:	a803      	add	r0, sp, #12
 8006d10:	e7c4      	b.n	8006c9c <chvprintf+0x1b0>
      c = 8;
 8006d12:	2208      	movs	r2, #8
 8006d14:	e7f3      	b.n	8006cfe <chvprintf+0x212>
    switch (c) {
 8006d16:	2210      	movs	r2, #16
 8006d18:	e7f1      	b.n	8006cfe <chvprintf+0x212>
 8006d1a:	2208      	movs	r2, #8
 8006d1c:	e7f4      	b.n	8006d08 <chvprintf+0x21c>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8006d1e:	f8d8 2000 	ldr.w	r2, [r8]
 8006d22:	4640      	mov	r0, r8
 8006d24:	6892      	ldr	r2, [r2, #8]
 8006d26:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006d2a:	9301      	str	r3, [sp, #4]
 8006d2c:	4790      	blx	r2
      n++;
 8006d2e:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 8006d30:	3b01      	subs	r3, #1
 8006d32:	d5f4      	bpl.n	8006d1e <chvprintf+0x232>
 8006d34:	2d00      	cmp	r5, #0
 8006d36:	bfa8      	it	ge
 8006d38:	44a9      	addge	r9, r5
 8006d3a:	465c      	mov	r4, fp
    }

    while (width) {
 8006d3c:	b92c      	cbnz	r4, 8006d4a <chvprintf+0x25e>
 8006d3e:	4634      	mov	r4, r6
 8006d40:	44d9      	add	r9, fp
 8006d42:	463b      	mov	r3, r7
 8006d44:	e6da      	b.n	8006afc <chvprintf+0x10>
 8006d46:	4693      	mov	fp, r2
 8006d48:	e7d4      	b.n	8006cf4 <chvprintf+0x208>
      streamPut(chp, (uint8_t)filler);
 8006d4a:	f8d8 3000 	ldr.w	r3, [r8]
 8006d4e:	4651      	mov	r1, sl
 8006d50:	4640      	mov	r0, r8
 8006d52:	689b      	ldr	r3, [r3, #8]
 8006d54:	4798      	blx	r3
      n++;
      width--;
 8006d56:	3c01      	subs	r4, #1
 8006d58:	e7f0      	b.n	8006d3c <chvprintf+0x250>
    switch (c) {
 8006d5a:	2210      	movs	r2, #16
 8006d5c:	e7d4      	b.n	8006d08 <chvprintf+0x21c>
 8006d5e:	2a55      	cmp	r2, #85	; 0x55
 8006d60:	f47f af3e 	bne.w	8006be0 <chvprintf+0xf4>
      c = 10;
 8006d64:	220a      	movs	r2, #10
      if (is_long)
 8006d66:	e7cf      	b.n	8006d08 <chvprintf+0x21c>
    switch (c) {
 8006d68:	2a69      	cmp	r2, #105	; 0x69
 8006d6a:	d088      	beq.n	8006c7e <chvprintf+0x192>
 8006d6c:	f1a2 006f 	sub.w	r0, r2, #111	; 0x6f
 8006d70:	b2c5      	uxtb	r5, r0
 8006d72:	2d09      	cmp	r5, #9
 8006d74:	f63f af34 	bhi.w	8006be0 <chvprintf+0xf4>
 8006d78:	2809      	cmp	r0, #9
 8006d7a:	f63f af31 	bhi.w	8006be0 <chvprintf+0xf4>
 8006d7e:	a301      	add	r3, pc, #4	; (adr r3, 8006d84 <chvprintf+0x298>)
 8006d80:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 8006d84:	08006d1b 	.word	0x08006d1b
 8006d88:	08006be1 	.word	0x08006be1
 8006d8c:	08006be1 	.word	0x08006be1
 8006d90:	08006be1 	.word	0x08006be1
 8006d94:	08006c49 	.word	0x08006c49
 8006d98:	08006be1 	.word	0x08006be1
 8006d9c:	08006d65 	.word	0x08006d65
 8006da0:	08006be1 	.word	0x08006be1
 8006da4:	08006be1 	.word	0x08006be1
 8006da8:	08006d5b 	.word	0x08006d5b
    }
  }
}
 8006dac:	4648      	mov	r0, r9
 8006dae:	b007      	add	sp, #28
 8006db0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006db4:	0800babe 	.word	0x0800babe

08006db8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>:
	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
 8006db8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( xTaskToNotify );
 8006dba:	4604      	mov	r4, r0
 8006dbc:	b900      	cbnz	r0, 8006dc0 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x8>
 8006dbe:	e7fe      	b.n	8006dbe <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x6>
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006dc0:	f7ff f8a4 	bl	8005f0c <vPortValidateInterruptPriority>
		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006dc4:	f7fe fd22 	bl	800580c <ulPortEnterCriticalFromISR>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8006dc8:	2202      	movs	r2, #2
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8006dca:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006dce:	4606      	mov	r6, r0
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006dd0:	2b01      	cmp	r3, #1
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 8006dd2:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8006dd6:	b2dd      	uxtb	r5, r3
					pxTCB->ulNotifiedValue = ulValue;
 8006dd8:	6621      	str	r1, [r4, #96]	; 0x60
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006dda:	d11f      	bne.n	8006e1c <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x64>
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8006ddc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006dde:	b103      	cbz	r3, 8006de2 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x2a>
 8006de0:	e7fe      	b.n	8006de0 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x28>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006de2:	4b13      	ldr	r3, [pc, #76]	; (8006e30 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x78>)
 8006de4:	681b      	ldr	r3, [r3, #0]
 8006de6:	b9f3      	cbnz	r3, 8006e26 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x6e>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006de8:	1d27      	adds	r7, r4, #4
 8006dea:	4638      	mov	r0, r7
 8006dec:	f7fd fc53 	bl	8004696 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006df0:	4a10      	ldr	r2, [pc, #64]	; (8006e34 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x7c>)
 8006df2:	2014      	movs	r0, #20
 8006df4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006df6:	6811      	ldr	r1, [r2, #0]
 8006df8:	409d      	lsls	r5, r3
 8006dfa:	430d      	orrs	r5, r1
 8006dfc:	4639      	mov	r1, r7
 8006dfe:	6015      	str	r5, [r2, #0]
 8006e00:	4a0d      	ldr	r2, [pc, #52]	; (8006e38 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x80>)
 8006e02:	fb00 2003 	mla	r0, r0, r3, r2
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8006e06:	f7fd fc23 	bl	8004650 <vListInsertEnd>
				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006e0a:	4b0c      	ldr	r3, [pc, #48]	; (8006e3c <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x84>)
 8006e0c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006e0e:	681b      	ldr	r3, [r3, #0]
 8006e10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006e12:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8006e14:	bf82      	ittt	hi
 8006e16:	2201      	movhi	r2, #1
 8006e18:	4b09      	ldrhi	r3, [pc, #36]	; (8006e40 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x88>)
 8006e1a:	601a      	strhi	r2, [r3, #0]
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006e1c:	4630      	mov	r0, r6
	}
 8006e1e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8006e22:	f7fe bd0d 	b.w	8005840 <vPortExitCriticalFromISR>
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8006e26:	4807      	ldr	r0, [pc, #28]	; (8006e44 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x8c>)
 8006e28:	f104 0118 	add.w	r1, r4, #24
 8006e2c:	e7eb      	b.n	8006e06 <xTaskGenericNotifyFromISR.constprop.0.isra.0+0x4e>
 8006e2e:	bf00      	nop
 8006e30:	2000136c 	.word	0x2000136c
 8006e34:	20001374 	.word	0x20001374
 8006e38:	200011b8 	.word	0x200011b8
 8006e3c:	200011a8 	.word	0x200011a8
 8006e40:	2000164c 	.word	0x2000164c
 8006e44:	20001600 	.word	0x20001600

08006e48 <osalThreadResumeI.part.0.lto_priv.0>:
{
    osalDbgCheck(mutex != NULL);
    xSemaphoreGive(mutex->handle);
}

static inline void osalThreadResumeI(thread_reference_t* thread_reference, msg_t msg)
 8006e48:	b510      	push	{r4, lr}
 8006e4a:	4604      	mov	r4, r0
{
    osalDbgCheckClassI();
    if(*thread_reference) {
 8006e4c:	6800      	ldr	r0, [r0, #0]
 8006e4e:	b118      	cbz	r0, 8006e58 <osalThreadResumeI.part.0.lto_priv.0+0x10>
        xTaskNotifyFromISR( *thread_reference, msg, eSetValueWithOverwrite, NULL );
 8006e50:	f7ff ffb2 	bl	8006db8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>
        *thread_reference = NULL;
 8006e54:	2300      	movs	r3, #0
 8006e56:	6023      	str	r3, [r4, #0]
    }
}
 8006e58:	bd10      	pop	{r4, pc}

08006e5a <osalThreadDequeueI>:
static bool osalThreadDequeueI(threads_queue_t* thread_queue, msg_t msg){
 8006e5a:	4603      	mov	r3, r0
 8006e5c:	b507      	push	{r0, r1, r2, lr}
    if(!thread_queue->tail){
 8006e5e:	6840      	ldr	r0, [r0, #4]
 8006e60:	b160      	cbz	r0, 8006e7c <osalThreadDequeueI+0x22>
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 8006e62:	6d82      	ldr	r2, [r0, #88]	; 0x58
    thread_reference_t toWakeUp = thread_queue->tail;
 8006e64:	9001      	str	r0, [sp, #4]
    if(prevTask){
 8006e66:	b162      	cbz	r2, 8006e82 <osalThreadDequeueI+0x28>
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 8006e68:	2000      	movs	r0, #0
 8006e6a:	6550      	str	r0, [r2, #84]	; 0x54
    thread_queue->tail = prevTask;
 8006e6c:	605a      	str	r2, [r3, #4]
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006e6e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006e72:	b143      	cbz	r3, 8006e86 <osalThreadDequeueI+0x2c>
 8006e74:	a801      	add	r0, sp, #4
 8006e76:	f7ff ffe7 	bl	8006e48 <osalThreadResumeI.part.0.lto_priv.0>
    return true;
 8006e7a:	2001      	movs	r0, #1
}
 8006e7c:	b003      	add	sp, #12
 8006e7e:	f85d fb04 	ldr.w	pc, [sp], #4
        thread_queue->head = NULL;
 8006e82:	601a      	str	r2, [r3, #0]
 8006e84:	e7f2      	b.n	8006e6c <osalThreadDequeueI+0x12>
    osalDbgCheckClassI();
 8006e86:	f7fd fd95 	bl	80049b4 <vTaskEndScheduler>
 8006e8a:	e7fe      	b.n	8006e8a <osalThreadDequeueI+0x30>

08006e8c <osalThreadDequeueNextI.constprop.0>:
void osalThreadDequeueNextI(threads_queue_t* thread_queue, msg_t msg)
 8006e8c:	b508      	push	{r3, lr}
    osalDbgCheck(thread_queue != NULL);
 8006e8e:	b910      	cbnz	r0, 8006e96 <osalThreadDequeueNextI.constprop.0+0xa>
 8006e90:	f7fd fd90 	bl	80049b4 <vTaskEndScheduler>
 8006e94:	e7fe      	b.n	8006e94 <osalThreadDequeueNextI.constprop.0+0x8>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006e96:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006e9a:	b123      	cbz	r3, 8006ea6 <osalThreadDequeueNextI.constprop.0+0x1a>
}
 8006e9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    osalThreadDequeueI(thread_queue, msg);
 8006ea0:	2100      	movs	r1, #0
 8006ea2:	f7ff bfda 	b.w	8006e5a <osalThreadDequeueI>
    osalDbgCheckClassI();
 8006ea6:	f7fd fd85 	bl	80049b4 <vTaskEndScheduler>
 8006eaa:	e7fe      	b.n	8006eaa <osalThreadDequeueNextI.constprop.0+0x1e>

08006eac <osalThreadDequeueAllI.constprop.0>:
void osalThreadDequeueAllI(threads_queue_t* thread_queue, msg_t msg)
 8006eac:	b510      	push	{r4, lr}
    osalDbgCheck(thread_queue != NULL);
 8006eae:	4604      	mov	r4, r0
 8006eb0:	b910      	cbnz	r0, 8006eb8 <osalThreadDequeueAllI.constprop.0+0xc>
 8006eb2:	f7fd fd7f 	bl	80049b4 <vTaskEndScheduler>
 8006eb6:	e7fe      	b.n	8006eb6 <osalThreadDequeueAllI.constprop.0+0xa>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006eb8:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006ebc:	b913      	cbnz	r3, 8006ec4 <osalThreadDequeueAllI.constprop.0+0x18>
    osalDbgCheckClassI();
 8006ebe:	f7fd fd79 	bl	80049b4 <vTaskEndScheduler>
 8006ec2:	e7fe      	b.n	8006ec2 <osalThreadDequeueAllI.constprop.0+0x16>
    while(osalThreadDequeueI(thread_queue, msg));
 8006ec4:	f06f 0101 	mvn.w	r1, #1
 8006ec8:	4620      	mov	r0, r4
 8006eca:	f7ff ffc6 	bl	8006e5a <osalThreadDequeueI>
 8006ece:	2800      	cmp	r0, #0
 8006ed0:	d1f8      	bne.n	8006ec4 <osalThreadDequeueAllI.constprop.0+0x18>
}
 8006ed2:	bd10      	pop	{r4, pc}

08006ed4 <osalEventBroadcastFlagsI>:
    
    return result;
}

void osalEventBroadcastFlagsI(event_source_t* event_source, eventflags_t set)
{
 8006ed4:	b570      	push	{r4, r5, r6, lr}
    osalDbgCheck(event_source != NULL);
 8006ed6:	4604      	mov	r4, r0
 8006ed8:	b910      	cbnz	r0, 8006ee0 <osalEventBroadcastFlagsI+0xc>
 8006eda:	f7fd fd6b 	bl	80049b4 <vTaskEndScheduler>
 8006ede:	e7fe      	b.n	8006ede <osalEventBroadcastFlagsI+0xa>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006ee0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006ee4:	b34b      	cbz	r3, 8006f3a <osalEventBroadcastFlagsI+0x66>
    osalDbgCheckClassI();

    event_source->setEvents |= set;
 8006ee6:	6846      	ldr	r6, [r0, #4]
    eventflags_t localEvents = event_source->setEvents;

    if(event_source->eventCallback){
 8006ee8:	68c3      	ldr	r3, [r0, #12]
    event_source->setEvents |= set;
 8006eea:	430e      	orrs	r6, r1
 8006eec:	6046      	str	r6, [r0, #4]
    if(event_source->eventCallback){
 8006eee:	b10b      	cbz	r3, 8006ef4 <osalEventBroadcastFlagsI+0x20>
        event_source->eventCallback(event_source, localEvents);
 8006ef0:	4631      	mov	r1, r6
 8006ef2:	4798      	blx	r3
    }

    /* Any repeaters? */
    event_repeater_t* repeater = event_source->firstRepeater;
 8006ef4:	6825      	ldr	r5, [r4, #0]
    while(repeater){
 8006ef6:	b965      	cbnz	r5, 8006f12 <osalEventBroadcastFlagsI+0x3e>
        event_source->setEvents &=~ repeater->triggerEvents;
        repeater = repeater->nextRepeater;
    }
   
    /* Wake up any waiting threads that may be waiting on remaining events */
    if(event_source->setEvents){
 8006ef8:	6863      	ldr	r3, [r4, #4]
 8006efa:	b30b      	cbz	r3, 8006f40 <osalEventBroadcastFlagsI+0x6c>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006efc:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006f00:	b1c3      	cbz	r3, 8006f34 <osalEventBroadcastFlagsI+0x60>
 8006f02:	f104 0008 	add.w	r0, r4, #8
 8006f06:	f06f 0102 	mvn.w	r1, #2
        osalThreadResumeI(&event_source->waitThread, MSG_EVENT_W);
    }
}
 8006f0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8006f0e:	f7ff bf9b 	b.w	8006e48 <osalThreadResumeI.part.0.lto_priv.0>
        if(localEvents & repeater->triggerEvents){
 8006f12:	692b      	ldr	r3, [r5, #16]
 8006f14:	421e      	tst	r6, r3
 8006f16:	d006      	beq.n	8006f26 <osalEventBroadcastFlagsI+0x52>
            repeater->setEvents |= localEvents;
 8006f18:	696b      	ldr	r3, [r5, #20]
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f1a:	69a9      	ldr	r1, [r5, #24]
            repeater->setEvents |= localEvents;
 8006f1c:	4333      	orrs	r3, r6
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f1e:	68e8      	ldr	r0, [r5, #12]
            repeater->setEvents |= localEvents;
 8006f20:	616b      	str	r3, [r5, #20]
            osalEventBroadcastFlagsI(repeater->target, repeater->myEvent);
 8006f22:	f7ff ffd7 	bl	8006ed4 <osalEventBroadcastFlagsI>
        event_source->setEvents &=~ repeater->triggerEvents;
 8006f26:	692a      	ldr	r2, [r5, #16]
 8006f28:	6863      	ldr	r3, [r4, #4]
        repeater = repeater->nextRepeater;
 8006f2a:	682d      	ldr	r5, [r5, #0]
        event_source->setEvents &=~ repeater->triggerEvents;
 8006f2c:	ea23 0302 	bic.w	r3, r3, r2
 8006f30:	6063      	str	r3, [r4, #4]
 8006f32:	e7e0      	b.n	8006ef6 <osalEventBroadcastFlagsI+0x22>
 8006f34:	f7fd fd3e 	bl	80049b4 <vTaskEndScheduler>
 8006f38:	e7fe      	b.n	8006f38 <osalEventBroadcastFlagsI+0x64>
    osalDbgCheckClassI();
 8006f3a:	f7fd fd3b 	bl	80049b4 <vTaskEndScheduler>
 8006f3e:	e7fe      	b.n	8006f3e <osalEventBroadcastFlagsI+0x6a>
}
 8006f40:	bd70      	pop	{r4, r5, r6, pc}

08006f42 <sduDataTransmitted>:
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006f42:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006f46:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006f4a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006f4c:	4605      	mov	r5, r0
 8006f4e:	460e      	mov	r6, r1
  if (sdup == NULL) {
 8006f50:	b394      	cbz	r4, 8006fb8 <sduDataTransmitted+0x76>
  osalSysLockFromISR();
 8006f52:	f7fe fc6d 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 8006f56:	2108      	movs	r1, #8
 8006f58:	1d20      	adds	r0, r4, #4
 8006f5a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 8006f5e:	f7ff ffb9 	bl	8006ed4 <osalEventBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8006f62:	68fb      	ldr	r3, [r7, #12]
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8006f64:	f104 0850 	add.w	r8, r4, #80	; 0x50
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8006f68:	695b      	ldr	r3, [r3, #20]
 8006f6a:	681b      	ldr	r3, [r3, #0]
 8006f6c:	b1bb      	cbz	r3, 8006f9e <sduDataTransmitted+0x5c>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006f6e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006f72:	b33b      	cbz	r3, 8006fc4 <sduDataTransmitted+0x82>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8006f74:	e9d4 2318 	ldrd	r2, r3, [r4, #96]	; 0x60
 8006f78:	429a      	cmp	r2, r3
 8006f7a:	d104      	bne.n	8006f86 <sduDataTransmitted+0x44>
 8006f7c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8006f7e:	b112      	cbz	r2, 8006f86 <sduDataTransmitted+0x44>
 8006f80:	f7fd fd18 	bl	80049b4 <vTaskEndScheduler>
 8006f84:	e7fe      	b.n	8006f84 <sduDataTransmitted+0x42>
  obqp->bcounter++;
 8006f86:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8006f88:	3201      	adds	r2, #1
 8006f8a:	65e2      	str	r2, [r4, #92]	; 0x5c
  obqp->brdptr += obqp->bsize;
 8006f8c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8006f8e:	4413      	add	r3, r2
  if (obqp->brdptr >= obqp->btop) {
 8006f90:	6ea2      	ldr	r2, [r4, #104]	; 0x68
  obqp->brdptr += obqp->bsize;
 8006f92:	6663      	str	r3, [r4, #100]	; 0x64
  if (obqp->brdptr >= obqp->btop) {
 8006f94:	4293      	cmp	r3, r2
 8006f96:	d212      	bcs.n	8006fbe <sduDataTransmitted+0x7c>
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8006f98:	4640      	mov	r0, r8
 8006f9a:	f7ff ff77 	bl	8006e8c <osalThreadDequeueNextI.constprop.0>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8006f9e:	4640      	mov	r0, r8
 8006fa0:	a901      	add	r1, sp, #4
 8006fa2:	f7fd fd39 	bl	8004a18 <obqGetFullBufferI>
  if (buf != NULL) {
 8006fa6:	4602      	mov	r2, r0
 8006fa8:	b178      	cbz	r0, 8006fca <sduDataTransmitted+0x88>
    usbStartTransmitI(usbp, ep, buf, n);
 8006faa:	9b01      	ldr	r3, [sp, #4]
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8006fac:	4631      	mov	r1, r6
 8006fae:	4628      	mov	r0, r5
 8006fb0:	f7fd fdca 	bl	8004b48 <usbStartTransmitI>
  osalSysUnlockFromISR();
 8006fb4:	f7fe fc50 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
}
 8006fb8:	b002      	add	sp, #8
 8006fba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    obqp->brdptr = obqp->buffers;
 8006fbe:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8006fc0:	6663      	str	r3, [r4, #100]	; 0x64
 8006fc2:	e7e9      	b.n	8006f98 <sduDataTransmitted+0x56>
  osalDbgCheckClassI();
 8006fc4:	f7fd fcf6 	bl	80049b4 <vTaskEndScheduler>
 8006fc8:	e7fe      	b.n	8006fc8 <sduDataTransmitted+0x86>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8006fca:	68fb      	ldr	r3, [r7, #12]
 8006fcc:	695a      	ldr	r2, [r3, #20]
 8006fce:	6812      	ldr	r2, [r2, #0]
 8006fd0:	b132      	cbz	r2, 8006fe0 <sduDataTransmitted+0x9e>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8006fd2:	8a1b      	ldrh	r3, [r3, #16]
 8006fd4:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8006fd6:	4013      	ands	r3, r2
 8006fd8:	d102      	bne.n	8006fe0 <sduDataTransmitted+0x9e>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8006fda:	f105 0274 	add.w	r2, r5, #116	; 0x74
 8006fde:	e7e5      	b.n	8006fac <sduDataTransmitted+0x6a>
    if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8006fe0:	f8d4 2498 	ldr.w	r2, [r4, #1176]	; 0x498
 8006fe4:	6893      	ldr	r3, [r2, #8]
 8006fe6:	2b00      	cmp	r3, #0
 8006fe8:	d0e4      	beq.n	8006fb4 <sduDataTransmitted+0x72>
 8006fea:	2101      	movs	r1, #1
 8006fec:	6810      	ldr	r0, [r2, #0]
 8006fee:	4798      	blx	r3
 8006ff0:	e7e0      	b.n	8006fb4 <sduDataTransmitted+0x72>

08006ff2 <osalThreadResumeI.lto_priv.0>:
{
 8006ff2:	b508      	push	{r3, lr}
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8006ff4:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8006ff8:	b11b      	cbz	r3, 8007002 <osalThreadResumeI.lto_priv.0+0x10>
}
 8006ffa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006ffe:	f7ff bf23 	b.w	8006e48 <osalThreadResumeI.part.0.lto_priv.0>
    osalDbgCheckClassI();
 8007002:	f7fd fcd7 	bl	80049b4 <vTaskEndScheduler>
 8007006:	e7fe      	b.n	8007006 <osalThreadResumeI.lto_priv.0+0x14>

08007008 <i2c_lld_serve_rx_end_irq>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8007008:	f011 0108 	ands.w	r1, r1, #8
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800700c:	b538      	push	{r3, r4, r5, lr}
 800700e:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8007010:	d002      	beq.n	8007018 <i2c_lld_serve_rx_end_irq+0x10>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8007012:	f7fd fccf 	bl	80049b4 <vTaskEndScheduler>
 8007016:	e7fe      	b.n	8007016 <i2c_lld_serve_rx_end_irq+0xe>
  dmaStreamDisable(i2cp->dmarx);
 8007018:	6f02      	ldr	r2, [r0, #112]	; 0x70
  I2C_TypeDef *dp = i2cp->i2c;
 800701a:	6f83      	ldr	r3, [r0, #120]	; 0x78
  dmaStreamDisable(i2cp->dmarx);
 800701c:	6855      	ldr	r5, [r2, #4]
 800701e:	6828      	ldr	r0, [r5, #0]
 8007020:	f020 000f 	bic.w	r0, r0, #15
 8007024:	6028      	str	r0, [r5, #0]
 8007026:	7c15      	ldrb	r5, [r2, #16]
 8007028:	6810      	ldr	r0, [r2, #0]
 800702a:	220e      	movs	r2, #14
 800702c:	40aa      	lsls	r2, r5
 800702e:	6042      	str	r2, [r0, #4]
  dp->CR2 &= ~I2C_CR2_LAST;
 8007030:	685a      	ldr	r2, [r3, #4]
 8007032:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8007036:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8007038:	681a      	ldr	r2, [r3, #0]
 800703a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800703e:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8007040:	681a      	ldr	r2, [r3, #0]
 8007042:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007046:	601a      	str	r2, [r3, #0]
  _i2c_wakeup_isr(i2cp);
 8007048:	f7fe fbf2 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 800704c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8007050:	f7ff ffcf 	bl	8006ff2 <osalThreadResumeI.lto_priv.0>
}
 8007054:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  _i2c_wakeup_isr(i2cp);
 8007058:	f7fe bbfe 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>

0800705c <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 800705c:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800705e:	4d4d      	ldr	r5, [pc, #308]	; (8007194 <VectorBC+0x138>)
 8007060:	6fac      	ldr	r4, [r5, #120]	; 0x78
  i2cp->numInterrupts++;
 8007062:	f8d5 2080 	ldr.w	r2, [r5, #128]	; 0x80
  uint32_t regSR2 = dp->SR2;
 8007066:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 8007068:	6966      	ldr	r6, [r4, #20]
  i2cp->numInterrupts++;
 800706a:	3201      	adds	r2, #1
  if ((event & I2C_SR1_BERR) || (i2cp->numInterrupts>=30)) {
 800706c:	05f1      	lsls	r1, r6, #23
  i2cp->numInterrupts++;
 800706e:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
  if ((event & I2C_SR1_BERR) || (i2cp->numInterrupts>=30)) {
 8007072:	d401      	bmi.n	8007078 <VectorBC+0x1c>
 8007074:	2a1d      	cmp	r2, #29
 8007076:	d91c      	bls.n	80070b2 <VectorBC+0x56>
    dp->SR1 &= ~I2C_SR1_BERR;
 8007078:	6963      	ldr	r3, [r4, #20]
    _i2c_wakeup_error_isr(i2cp);
 800707a:	f06f 0101 	mvn.w	r1, #1
    dp->SR1 &= ~I2C_SR1_BERR;
 800707e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007082:	6163      	str	r3, [r4, #20]
    dp->CR2 &=~ I2C_CR2_ITEVTEN | I2C_CR2_ITERREN | I2C_CR2_ITBUFEN;
 8007084:	6863      	ldr	r3, [r4, #4]
 8007086:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800708a:	6063      	str	r3, [r4, #4]
    i2cp->errors = I2C_BUS_ERROR;
 800708c:	2301      	movs	r3, #1
 800708e:	60ab      	str	r3, [r5, #8]
    _i2c_wakeup_error_isr(i2cp);
 8007090:	f7fe fbce 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 8007094:	4840      	ldr	r0, [pc, #256]	; (8007198 <VectorBC+0x13c>)
 8007096:	f7ff ffac 	bl	8006ff2 <osalThreadResumeI.lto_priv.0>
 800709a:	f7fe fbdd 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
    xYieldPending = pdFALSE;
 800709e:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 80070a0:	4b3e      	ldr	r3, [pc, #248]	; (800719c <VectorBC+0x140>)
 80070a2:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 80070a4:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 80070a6:	2a00      	cmp	r2, #0
 80070a8:	d072      	beq.n	8007190 <VectorBC+0x134>
}
 80070aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80070ae:	f7fc be65 	b.w	8003d7c <Vector6C.part.0>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80070b2:	4a3b      	ldr	r2, [pc, #236]	; (80071a0 <VectorBC+0x144>)
 80070b4:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 80070b8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80070bc:	4293      	cmp	r3, r2
 80070be:	d030      	beq.n	8007122 <VectorBC+0xc6>
 80070c0:	d80a      	bhi.n	80070d8 <VectorBC+0x7c>
 80070c2:	3a07      	subs	r2, #7
 80070c4:	4293      	cmp	r3, r2
 80070c6:	d01d      	beq.n	8007104 <VectorBC+0xa8>
 80070c8:	3201      	adds	r2, #1
 80070ca:	4293      	cmp	r3, r2
 80070cc:	d02e      	beq.n	800712c <VectorBC+0xd0>
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80070ce:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 80070d2:	bf18      	it	ne
 80070d4:	69a3      	ldrne	r3, [r4, #24]
 80070d6:	e7e2      	b.n	800709e <VectorBC+0x42>
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80070d8:	4a32      	ldr	r2, [pc, #200]	; (80071a4 <VectorBC+0x148>)
 80070da:	4293      	cmp	r3, r2
 80070dc:	d03c      	beq.n	8007158 <VectorBC+0xfc>
 80070de:	3202      	adds	r2, #2
 80070e0:	4293      	cmp	r3, r2
 80070e2:	d1f4      	bne.n	80070ce <VectorBC+0x72>
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 80070e4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80070e6:	685b      	ldr	r3, [r3, #4]
 80070e8:	6859      	ldr	r1, [r3, #4]
 80070ea:	2900      	cmp	r1, #0
 80070ec:	d03f      	beq.n	800716e <VectorBC+0x112>
      i2cp->addr |= 0x01;
 80070ee:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 80070f2:	f043 0301 	orr.w	r3, r3, #1
 80070f6:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 80070fa:	6823      	ldr	r3, [r4, #0]
 80070fc:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
 8007100:	6023      	str	r3, [r4, #0]
      return;
 8007102:	e7cc      	b.n	800709e <VectorBC+0x42>
    if ((i2cp->addr >> 8) > 0) { 
 8007104:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
 8007108:	0a13      	lsrs	r3, r2, #8
 800710a:	d008      	beq.n	800711e <VectorBC+0xc2>
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800710c:	f003 0306 	and.w	r3, r3, #6
 8007110:	f002 0201 	and.w	r2, r2, #1
 8007114:	4313      	orrs	r3, r2
 8007116:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800711a:	6123      	str	r3, [r4, #16]
    break;
 800711c:	e7d7      	b.n	80070ce <VectorBC+0x72>
      dp->DR = i2cp->addr;
 800711e:	6122      	str	r2, [r4, #16]
 8007120:	e7d5      	b.n	80070ce <VectorBC+0x72>
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8007122:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
 8007126:	f3c3 0347 	ubfx	r3, r3, #1, #8
 800712a:	e7f6      	b.n	800711a <VectorBC+0xbe>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800712c:	6863      	ldr	r3, [r4, #4]
 800712e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007132:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8007134:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8007136:	685b      	ldr	r3, [r3, #4]
 8007138:	681a      	ldr	r2, [r3, #0]
 800713a:	f042 0201 	orr.w	r2, r2, #1
 800713e:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8007140:	6862      	ldr	r2, [r4, #4]
 8007142:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8007146:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8007148:	685b      	ldr	r3, [r3, #4]
 800714a:	2b01      	cmp	r3, #1
 800714c:	d8bf      	bhi.n	80070ce <VectorBC+0x72>
      dp->CR1 &= ~I2C_CR1_ACK;
 800714e:	6823      	ldr	r3, [r4, #0]
 8007150:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007154:	6023      	str	r3, [r4, #0]
 8007156:	e7ba      	b.n	80070ce <VectorBC+0x72>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8007158:	6863      	ldr	r3, [r4, #4]
 800715a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800715e:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8007160:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8007162:	685a      	ldr	r2, [r3, #4]
 8007164:	6813      	ldr	r3, [r2, #0]
 8007166:	f043 0301 	orr.w	r3, r3, #1
 800716a:	6013      	str	r3, [r2, #0]
    break;
 800716c:	e7af      	b.n	80070ce <VectorBC+0x72>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800716e:	6863      	ldr	r3, [r4, #4]
 8007170:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007174:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8007176:	6823      	ldr	r3, [r4, #0]
 8007178:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800717c:	6023      	str	r3, [r4, #0]
    _i2c_wakeup_isr(i2cp);
 800717e:	f7fe fb57 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 8007182:	f105 0060 	add.w	r0, r5, #96	; 0x60
 8007186:	f7ff ff34 	bl	8006ff2 <osalThreadResumeI.lto_priv.0>
 800718a:	f7fe fb65 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
    break;
 800718e:	e79e      	b.n	80070ce <VectorBC+0x72>
}
 8007190:	bd70      	pop	{r4, r5, r6, pc}
 8007192:	bf00      	nop
 8007194:	20000934 	.word	0x20000934
 8007198:	20000994 	.word	0x20000994
 800719c:	2000164c 	.word	0x2000164c
 80071a0:	00030008 	.word	0x00030008
 80071a4:	00070082 	.word	0x00070082

080071a8 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 80071a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 80071aa:	4b35      	ldr	r3, [pc, #212]	; (8007280 <VectorC0+0xd8>)
 80071ac:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80071ae:	6951      	ldr	r1, [r2, #20]

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 80071b0:	f401 445f 	and.w	r4, r1, #57088	; 0xdf00
 80071b4:	43e4      	mvns	r4, r4
 80071b6:	6154      	str	r4, [r2, #20]
  dmaStreamDisable(i2cp->dmatx);
 80071b8:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  uint16_t sr = I2CD1.i2c->SR1;
 80071ba:	b288      	uxth	r0, r1
  dmaStreamDisable(i2cp->dmatx);
 80071bc:	6866      	ldr	r6, [r4, #4]
 80071be:	6835      	ldr	r5, [r6, #0]
 80071c0:	f025 050f 	bic.w	r5, r5, #15
 80071c4:	6035      	str	r5, [r6, #0]
 80071c6:	7c25      	ldrb	r5, [r4, #16]
 80071c8:	6826      	ldr	r6, [r4, #0]
 80071ca:	240e      	movs	r4, #14
 80071cc:	fa04 f505 	lsl.w	r5, r4, r5
 80071d0:	6075      	str	r5, [r6, #4]
  dmaStreamDisable(i2cp->dmarx);
 80071d2:	6f1d      	ldr	r5, [r3, #112]	; 0x70
 80071d4:	686f      	ldr	r7, [r5, #4]
 80071d6:	683e      	ldr	r6, [r7, #0]
 80071d8:	f026 060f 	bic.w	r6, r6, #15
 80071dc:	603e      	str	r6, [r7, #0]
 80071de:	682e      	ldr	r6, [r5, #0]
 80071e0:	7c2d      	ldrb	r5, [r5, #16]
 80071e2:	40ac      	lsls	r4, r5
 80071e4:	6074      	str	r4, [r6, #4]
  i2cp->numInterrupts++;
 80071e6:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 80071ea:	3401      	adds	r4, #1
 80071ec:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 80071f0:	f411 7480 	ands.w	r4, r1, #256	; 0x100
    i2cp->errors |= I2C_BUS_ERROR;
 80071f4:	bf18      	it	ne
 80071f6:	2401      	movne	r4, #1
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 80071f8:	0587      	lsls	r7, r0, #22
    i2cp->errors |= I2C_BUS_ERROR;
 80071fa:	609c      	str	r4, [r3, #8]
    i2cp->errors |= I2C_ARBITRATION_LOST;
 80071fc:	bf42      	ittt	mi
 80071fe:	689c      	ldrmi	r4, [r3, #8]
 8007200:	f044 0402 	orrmi.w	r4, r4, #2
 8007204:	609c      	strmi	r4, [r3, #8]
  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8007206:	0546      	lsls	r6, r0, #21
 8007208:	d50b      	bpl.n	8007222 <VectorC0+0x7a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800720a:	6855      	ldr	r5, [r2, #4]
    i2cp->errors |= I2C_ACK_FAILURE;
 800720c:	689c      	ldr	r4, [r3, #8]
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800720e:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 8007212:	6055      	str	r5, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8007214:	6815      	ldr	r5, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8007216:	f044 0404 	orr.w	r4, r4, #4
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800721a:	f445 7500 	orr.w	r5, r5, #512	; 0x200
 800721e:	6015      	str	r5, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8007220:	609c      	str	r4, [r3, #8]
  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8007222:	0505      	lsls	r5, r0, #20
    i2cp->errors |= I2C_OVERRUN;
 8007224:	bf42      	ittt	mi
 8007226:	689a      	ldrmi	r2, [r3, #8]
 8007228:	f042 0208 	orrmi.w	r2, r2, #8
 800722c:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800722e:	0444      	lsls	r4, r0, #17
    i2cp->errors |= I2C_TIMEOUT;
 8007230:	bf42      	ittt	mi
 8007232:	689a      	ldrmi	r2, [r3, #8]
 8007234:	f042 0220 	orrmi.w	r2, r2, #32
 8007238:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800723a:	04c0      	lsls	r0, r0, #19
    i2cp->errors |= I2C_PEC_ERROR;
 800723c:	bf42      	ittt	mi
 800723e:	689a      	ldrmi	r2, [r3, #8]
 8007240:	f042 0210 	orrmi.w	r2, r2, #16
 8007244:	609a      	strmi	r2, [r3, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8007246:	0409      	lsls	r1, r1, #16
    i2cp->errors |= I2C_SMB_ALERT;
 8007248:	689a      	ldr	r2, [r3, #8]
  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800724a:	d50c      	bpl.n	8007266 <VectorC0+0xbe>
    i2cp->errors |= I2C_SMB_ALERT;
 800724c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8007250:	609a      	str	r2, [r3, #8]
    _i2c_wakeup_error_isr(i2cp);
 8007252:	f7fe faed 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 8007256:	f06f 0101 	mvn.w	r1, #1
 800725a:	480a      	ldr	r0, [pc, #40]	; (8007284 <VectorC0+0xdc>)
 800725c:	f7ff fec9 	bl	8006ff2 <osalThreadResumeI.lto_priv.0>
 8007260:	f7fe fafa 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
 8007264:	e001      	b.n	800726a <VectorC0+0xc2>
  if (i2cp->errors != I2C_NO_ERROR)
 8007266:	2a00      	cmp	r2, #0
 8007268:	d1f3      	bne.n	8007252 <VectorC0+0xaa>
 800726a:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 800726c:	4b06      	ldr	r3, [pc, #24]	; (8007288 <VectorC0+0xe0>)
 800726e:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8007270:	6019      	str	r1, [r3, #0]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8007272:	b11a      	cbz	r2, 800727c <VectorC0+0xd4>
}
 8007274:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8007278:	f7fc bd80 	b.w	8003d7c <Vector6C.part.0>
 800727c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800727e:	bf00      	nop
 8007280:	20000934 	.word	0x20000934
 8007284:	20000994 	.word	0x20000994
 8007288:	2000164c 	.word	0x2000164c

0800728c <spi_lld_serve_rx_interrupt>:
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800728c:	b538      	push	{r3, r4, r5, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800728e:	070b      	lsls	r3, r1, #28
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8007290:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8007292:	d502      	bpl.n	800729a <spi_lld_serve_rx_interrupt+0xe>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 8007294:	f7fd fb8e 	bl	80049b4 <vTaskEndScheduler>
 8007298:	e7fe      	b.n	8007298 <spi_lld_serve_rx_interrupt+0xc>
  dmaStreamDisable(spip->dmatx);
 800729a:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800729c:	6859      	ldr	r1, [r3, #4]
 800729e:	680a      	ldr	r2, [r1, #0]
 80072a0:	f022 020f 	bic.w	r2, r2, #15
 80072a4:	600a      	str	r2, [r1, #0]
 80072a6:	7c1a      	ldrb	r2, [r3, #16]
 80072a8:	6819      	ldr	r1, [r3, #0]
 80072aa:	230e      	movs	r3, #14
 80072ac:	fa03 f202 	lsl.w	r2, r3, r2
 80072b0:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(spip->dmarx);
 80072b2:	6e42      	ldr	r2, [r0, #100]	; 0x64
 80072b4:	6855      	ldr	r5, [r2, #4]
 80072b6:	6829      	ldr	r1, [r5, #0]
 80072b8:	f021 010f 	bic.w	r1, r1, #15
 80072bc:	6029      	str	r1, [r5, #0]
 80072be:	6811      	ldr	r1, [r2, #0]
 80072c0:	7c12      	ldrb	r2, [r2, #16]
 80072c2:	4093      	lsls	r3, r2
 80072c4:	604b      	str	r3, [r1, #4]
  _spi_isr_code(spip);
 80072c6:	6843      	ldr	r3, [r0, #4]
 80072c8:	681b      	ldr	r3, [r3, #0]
 80072ca:	b12b      	cbz	r3, 80072d8 <spi_lld_serve_rx_interrupt+0x4c>
 80072cc:	2204      	movs	r2, #4
 80072ce:	7002      	strb	r2, [r0, #0]
 80072d0:	4798      	blx	r3
 80072d2:	7823      	ldrb	r3, [r4, #0]
 80072d4:	2b04      	cmp	r3, #4
 80072d6:	d101      	bne.n	80072dc <spi_lld_serve_rx_interrupt+0x50>
 80072d8:	2302      	movs	r3, #2
 80072da:	7023      	strb	r3, [r4, #0]
 80072dc:	f7fe faa8 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 80072e0:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 80072e4:	b12b      	cbz	r3, 80072f2 <spi_lld_serve_rx_interrupt+0x66>
    if(*thread_reference) {
 80072e6:	68a0      	ldr	r0, [r4, #8]
 80072e8:	b930      	cbnz	r0, 80072f8 <spi_lld_serve_rx_interrupt+0x6c>
}
 80072ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  _spi_isr_code(spip);
 80072ee:	f7fe bab3 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
    osalDbgCheckClassI();
 80072f2:	f7fd fb5f 	bl	80049b4 <vTaskEndScheduler>
 80072f6:	e7fe      	b.n	80072f6 <spi_lld_serve_rx_interrupt+0x6a>
        xTaskNotifyFromISR( *thread_reference, msg, eSetValueWithOverwrite, NULL );
 80072f8:	2100      	movs	r1, #0
 80072fa:	f7ff fd5d 	bl	8006db8 <xTaskGenericNotifyFromISR.constprop.0.isra.0>
        *thread_reference = NULL;
 80072fe:	2300      	movs	r3, #0
 8007300:	60a3      	str	r3, [r4, #8]
 8007302:	e7f2      	b.n	80072ea <spi_lld_serve_rx_interrupt+0x5e>

08007304 <gpioSetPinMode.isra.0>:
bool gpioSetPinMode(uint16_t pin, uint8_t mode)
 8007304:	b510      	push	{r4, lr}
 8007306:	4604      	mov	r4, r0
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 8007308:	0a00      	lsrs	r0, r0, #8
 800730a:	f7fd f855 	bl	80043b8 <gpioGetPortDriver>
    return port->functions->setMode(port, gpioPin, mode);
 800730e:	6883      	ldr	r3, [r0, #8]
 8007310:	460a      	mov	r2, r1
 8007312:	681b      	ldr	r3, [r3, #0]
 8007314:	b2e1      	uxtb	r1, r4
}
 8007316:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return port->functions->setMode(port, gpioPin, mode);
 800731a:	4718      	bx	r3

0800731c <i2cSafeRawHardwareControl>:
{
 800731c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    i2cSafeConfig* config = (i2cSafeConfig*)i2c->i2cSafeConfig;
 8007320:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
 8007322:	4604      	mov	r4, r0
  osalDbgCheck((i2cp != NULL) && (config != NULL));
 8007324:	b915      	cbnz	r5, 800732c <i2cSafeRawHardwareControl+0x10>
 8007326:	f7fd fb45 	bl	80049b4 <vTaskEndScheduler>
 800732a:	e7fe      	b.n	800732a <i2cSafeRawHardwareControl+0xe>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800732c:	7803      	ldrb	r3, [r0, #0]
 800732e:	1e5a      	subs	r2, r3, #1
 8007330:	2a01      	cmp	r2, #1
 8007332:	d904      	bls.n	800733e <i2cSafeRawHardwareControl+0x22>
 8007334:	2b05      	cmp	r3, #5
 8007336:	d002      	beq.n	800733e <i2cSafeRawHardwareControl+0x22>
 8007338:	f7fd fb3c 	bl	80049b4 <vTaskEndScheduler>
 800733c:	e7fe      	b.n	800733c <i2cSafeRawHardwareControl+0x20>
  osalSysLock();
 800733e:	f7fd fb29 	bl	8004994 <vPortEnterCritical>
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8007342:	f894 8000 	ldrb.w	r8, [r4]
  I2C_TypeDef *dp = i2cp->i2c;
 8007346:	6fa6      	ldr	r6, [r4, #120]	; 0x78
  if (i2cp->state == I2C_STOP) {
 8007348:	f1b8 0f01 	cmp.w	r8, #1
  i2cp->config = config;
 800734c:	6065      	str	r5, [r4, #4]
 800734e:	d13a      	bne.n	80073c6 <i2cSafeRawHardwareControl+0xaa>

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8007350:	238a      	movs	r3, #138	; 0x8a
 8007352:	229a      	movs	r2, #154	; 0x9a
 8007354:	e9c4 321a 	strd	r3, r2, [r4, #104]	; 0x68
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_P2M;

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8007358:	4b6b      	ldr	r3, [pc, #428]	; (8007508 <i2cSafeRawHardwareControl+0x1ec>)
 800735a:	429c      	cmp	r4, r3
 800735c:	d133      	bne.n	80073c6 <i2cSafeRawHardwareControl+0xaa>
      bool b;

      rccResetI2C1();
 800735e:	4f6b      	ldr	r7, [pc, #428]	; (800750c <i2cSafeRawHardwareControl+0x1f0>)
      b = dmaStreamAllocate(i2cp->dmarx,
 8007360:	4622      	mov	r2, r4
      rccResetI2C1();
 8007362:	693b      	ldr	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8007364:	496a      	ldr	r1, [pc, #424]	; (8007510 <i2cSafeRawHardwareControl+0x1f4>)
      rccResetI2C1();
 8007366:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800736a:	613b      	str	r3, [r7, #16]
 800736c:	2300      	movs	r3, #0
      b = dmaStreamAllocate(i2cp->dmarx,
 800736e:	6f20      	ldr	r0, [r4, #112]	; 0x70
      rccResetI2C1();
 8007370:	613b      	str	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8007372:	f7ff f863 	bl	800643c <dmaStreamAllocate.constprop.0>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8007376:	b110      	cbz	r0, 800737e <i2cSafeRawHardwareControl+0x62>
 8007378:	f7fd fb1c 	bl	80049b4 <vTaskEndScheduler>
 800737c:	e7fe      	b.n	800737c <i2cSafeRawHardwareControl+0x60>
      b = dmaStreamAllocate(i2cp->dmatx,
 800737e:	4622      	mov	r2, r4
 8007380:	4964      	ldr	r1, [pc, #400]	; (8007514 <i2cSafeRawHardwareControl+0x1f8>)
 8007382:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8007384:	f7ff f85a 	bl	800643c <dmaStreamAllocate.constprop.0>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8007388:	b110      	cbz	r0, 8007390 <i2cSafeRawHardwareControl+0x74>
 800738a:	f7fd fb13 	bl	80049b4 <vTaskEndScheduler>
 800738e:	e7fe      	b.n	800738e <i2cSafeRawHardwareControl+0x72>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007390:	22c0      	movs	r2, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007392:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
      rccEnableI2C1(FALSE);
 8007396:	69fb      	ldr	r3, [r7, #28]
 8007398:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800739c:	61fb      	str	r3, [r7, #28]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800739e:	4b5e      	ldr	r3, [pc, #376]	; (8007518 <i2cSafeRawHardwareControl+0x1fc>)
 80073a0:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80073a4:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80073a8:	6019      	str	r1, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80073aa:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80073ae:	f8c3 8184 	str.w	r8, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80073b2:	f8c3 8004 	str.w	r8, [r3, #4]
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80073b6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80073b8:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80073bc:	66a3      	str	r3, [r4, #104]	; 0x68
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80073be:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80073c0:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80073c4:	66e3      	str	r3, [r4, #108]	; 0x6c
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 80073c6:	6f23      	ldr	r3, [r4, #112]	; 0x70
  int32_t clock_speed = i2cp->config->clock_speed;
 80073c8:	6867      	ldr	r7, [r4, #4]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 80073ca:	685a      	ldr	r2, [r3, #4]
 80073cc:	f106 0310 	add.w	r3, r6, #16
 80073d0:	6093      	str	r3, [r2, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80073d2:	6f62      	ldr	r2, [r4, #116]	; 0x74
  int32_t clock_speed = i2cp->config->clock_speed;
 80073d4:	6879      	ldr	r1, [r7, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80073d6:	6852      	ldr	r2, [r2, #4]
  osalDbgCheck((i2cp != NULL) &&
 80073d8:	1e48      	subs	r0, r1, #1
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80073da:	6093      	str	r3, [r2, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 80073dc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 80073e0:	f44f 6210 	mov.w	r2, #2304	; 0x900
  dp->CR1 = I2C_CR1_SWRST;
 80073e4:	6033      	str	r3, [r6, #0]
  dp->CR1 = 0;
 80073e6:	2300      	movs	r3, #0
 80073e8:	6033      	str	r3, [r6, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 80073ea:	6072      	str	r2, [r6, #4]
  osalDbgCheck((i2cp != NULL) &&
 80073ec:	4a4b      	ldr	r2, [pc, #300]	; (800751c <i2cSafeRawHardwareControl+0x200>)
 80073ee:	4290      	cmp	r0, r2
 80073f0:	d902      	bls.n	80073f8 <i2cSafeRawHardwareControl+0xdc>
 80073f2:	f7fd fadf 	bl	80049b4 <vTaskEndScheduler>
 80073f6:	e7fe      	b.n	80073f6 <i2cSafeRawHardwareControl+0xda>
  I2C_TypeDef *dp = i2cp->i2c;
 80073f8:	6fa0      	ldr	r0, [r4, #120]	; 0x78
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 80073fa:	7a3a      	ldrb	r2, [r7, #8]
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80073fc:	f8d0 c004 	ldr.w	ip, [r0, #4]
 8007400:	f02c 0c3f 	bic.w	ip, ip, #63	; 0x3f
 8007404:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8007408:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 800740c:	f8c0 c004 	str.w	ip, [r0, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8007410:	f8d0 c004 	ldr.w	ip, [r0, #4]
 8007414:	f04c 0c24 	orr.w	ip, ip, #36	; 0x24
 8007418:	f8c0 c004 	str.w	ip, [r0, #4]
  if (clock_speed <= 100000) {
 800741c:	f8df c100 	ldr.w	ip, [pc, #256]	; 8007520 <i2cSafeRawHardwareControl+0x204>
 8007420:	4561      	cmp	r1, ip
 8007422:	d839      	bhi.n	8007498 <i2cSafeRawHardwareControl+0x17c>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 8007424:	2a01      	cmp	r2, #1
 8007426:	d002      	beq.n	800742e <i2cSafeRawHardwareControl+0x112>
 8007428:	f7fd fac4 	bl	80049b4 <vTaskEndScheduler>
 800742c:	e7fe      	b.n	800742c <i2cSafeRawHardwareControl+0x110>
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 800742e:	4a3d      	ldr	r2, [pc, #244]	; (8007524 <i2cSafeRawHardwareControl+0x208>)
 8007430:	0049      	lsls	r1, r1, #1
 8007432:	fbb2 f3f1 	udiv	r3, r2, r1
 8007436:	fb01 2213 	mls	r2, r1, r3, r2
 800743a:	b112      	cbz	r2, 8007442 <i2cSafeRawHardwareControl+0x126>
 800743c:	f7fd faba 	bl	80049b4 <vTaskEndScheduler>
 8007440:	e7fe      	b.n	8007440 <i2cSafeRawHardwareControl+0x124>
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8007442:	b29b      	uxth	r3, r3
    osalDbgAssert(clock_div >= 0x04,
 8007444:	2b03      	cmp	r3, #3
 8007446:	d802      	bhi.n	800744e <i2cSafeRawHardwareControl+0x132>
 8007448:	f7fd fab4 	bl	80049b4 <vTaskEndScheduler>
 800744c:	e7fe      	b.n	800744c <i2cSafeRawHardwareControl+0x130>
    dp->TRISE = I2C_CLK_FREQ + 1;
 800744e:	2225      	movs	r2, #37	; 0x25
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007450:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    dp->TRISE = I2C_CLK_FREQ + 1;
 8007454:	6202      	str	r2, [r0, #32]
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8007456:	d24b      	bcs.n	80074f0 <i2cSafeRawHardwareControl+0x1d4>
  dp->CCR = regCCR;
 8007458:	61c3      	str	r3, [r0, #28]
  i2copmode_t opmode = i2cp->config->op_mode;
 800745a:	783a      	ldrb	r2, [r7, #0]
  regCR1 = dp->CR1;
 800745c:	6803      	ldr	r3, [r0, #0]
  switch (opmode) {
 800745e:	2a02      	cmp	r2, #2
  regCR1 = dp->CR1;
 8007460:	b29b      	uxth	r3, r3
  switch (opmode) {
 8007462:	d048      	beq.n	80074f6 <i2cSafeRawHardwareControl+0x1da>
 8007464:	2a03      	cmp	r2, #3
 8007466:	d04c      	beq.n	8007502 <i2cSafeRawHardwareControl+0x1e6>
 8007468:	2a01      	cmp	r2, #1
 800746a:	d102      	bne.n	8007472 <i2cSafeRawHardwareControl+0x156>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800746c:	f023 030a 	bic.w	r3, r3, #10
 8007470:	b29b      	uxth	r3, r3
  dp->CR1 = regCR1;
 8007472:	6003      	str	r3, [r0, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8007474:	6833      	ldr	r3, [r6, #0]
 8007476:	f043 0301 	orr.w	r3, r3, #1
 800747a:	6033      	str	r3, [r6, #0]
  i2cp->state = I2C_READY;
 800747c:	2302      	movs	r3, #2
 800747e:	7023      	strb	r3, [r4, #0]
  osalSysUnlock();
 8007480:	f7fd fcac 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    gpioSetPinMode(config->sclPin, config->peripheralMode);
 8007484:	7c29      	ldrb	r1, [r5, #16]
 8007486:	89a8      	ldrh	r0, [r5, #12]
 8007488:	f7ff ff3c 	bl	8007304 <gpioSetPinMode.isra.0>
    gpioSetPinMode(config->sdaPin, config->peripheralMode);
 800748c:	7c29      	ldrb	r1, [r5, #16]
 800748e:	89e8      	ldrh	r0, [r5, #14]
}
 8007490:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    gpioSetPinMode(config->sdaPin, config->peripheralMode);
 8007494:	f7ff bf36 	b.w	8007304 <gpioSetPinMode.isra.0>
  else if (clock_speed <= 400000) {
 8007498:	f8df c08c 	ldr.w	ip, [pc, #140]	; 8007528 <i2cSafeRawHardwareControl+0x20c>
 800749c:	4561      	cmp	r1, ip
 800749e:	dcdb      	bgt.n	8007458 <i2cSafeRawHardwareControl+0x13c>
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 80074a0:	1e93      	subs	r3, r2, #2
 80074a2:	2b01      	cmp	r3, #1
 80074a4:	d902      	bls.n	80074ac <i2cSafeRawHardwareControl+0x190>
 80074a6:	f7fd fa85 	bl	80049b4 <vTaskEndScheduler>
 80074aa:	e7fe      	b.n	80074aa <i2cSafeRawHardwareControl+0x18e>
    if (duty == FAST_DUTY_CYCLE_2) {
 80074ac:	2a02      	cmp	r2, #2
 80074ae:	4b1d      	ldr	r3, [pc, #116]	; (8007524 <i2cSafeRawHardwareControl+0x208>)
 80074b0:	d110      	bne.n	80074d4 <i2cSafeRawHardwareControl+0x1b8>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 80074b2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80074b6:	fbb3 f2f1 	udiv	r2, r3, r1
 80074ba:	fb01 3312 	mls	r3, r1, r2, r3
 80074be:	b113      	cbz	r3, 80074c6 <i2cSafeRawHardwareControl+0x1aa>
 80074c0:	f7fd fa78 	bl	80049b4 <vTaskEndScheduler>
 80074c4:	e7fe      	b.n	80074c4 <i2cSafeRawHardwareControl+0x1a8>
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 80074c6:	b292      	uxth	r2, r2
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80074c8:	4313      	orrs	r3, r2
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80074ca:	220b      	movs	r2, #11
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80074cc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80074d0:	6202      	str	r2, [r0, #32]
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 80074d2:	e7c1      	b.n	8007458 <i2cSafeRawHardwareControl+0x13c>
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 80074d4:	2219      	movs	r2, #25
 80074d6:	4351      	muls	r1, r2
 80074d8:	fbb3 f2f1 	udiv	r2, r3, r1
 80074dc:	fb01 3312 	mls	r3, r1, r2, r3
 80074e0:	b113      	cbz	r3, 80074e8 <i2cSafeRawHardwareControl+0x1cc>
 80074e2:	f7fd fa67 	bl	80049b4 <vTaskEndScheduler>
 80074e6:	e7fe      	b.n	80074e6 <i2cSafeRawHardwareControl+0x1ca>
      regCCR |= I2C_CCR_DUTY;
 80074e8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80074ec:	b292      	uxth	r2, r2
      regCCR |= I2C_CCR_DUTY;
 80074ee:	e7eb      	b.n	80074c8 <i2cSafeRawHardwareControl+0x1ac>
  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 80074f0:	f7fd fa60 	bl	80049b4 <vTaskEndScheduler>
 80074f4:	e7fe      	b.n	80074f4 <i2cSafeRawHardwareControl+0x1d8>
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 80074f6:	f023 0308 	bic.w	r3, r3, #8
 80074fa:	b29b      	uxth	r3, r3
 80074fc:	f043 0302 	orr.w	r3, r3, #2
    break;
 8007500:	e7b7      	b.n	8007472 <i2cSafeRawHardwareControl+0x156>
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8007502:	f043 030a 	orr.w	r3, r3, #10
    break;
 8007506:	e7b4      	b.n	8007472 <i2cSafeRawHardwareControl+0x156>
 8007508:	20000934 	.word	0x20000934
 800750c:	40021000 	.word	0x40021000
 8007510:	08007009 	.word	0x08007009
 8007514:	08004c79 	.word	0x08004c79
 8007518:	e000e100 	.word	0xe000e100
 800751c:	003d08ff 	.word	0x003d08ff
 8007520:	000186a0 	.word	0x000186a0
 8007524:	02255100 	.word	0x02255100
 8007528:	00061a80 	.word	0x00061a80

0800752c <gpioSetPin.isra.0>:
bool gpioSetPin(uint16_t pin, bool on)
 800752c:	b510      	push	{r4, lr}
 800752e:	4604      	mov	r4, r0
    const GPIOPort* port = gpioGetPortDriver(gpioPort);
 8007530:	0a00      	lsrs	r0, r0, #8
 8007532:	f7fc ff41 	bl	80043b8 <gpioGetPortDriver>
    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
 8007536:	b2e4      	uxtb	r4, r4
 8007538:	fa01 f204 	lsl.w	r2, r1, r4
 800753c:	2101      	movs	r1, #1
 800753e:	6883      	ldr	r3, [r0, #8]
 8007540:	40a1      	lsls	r1, r4
 8007542:	689b      	ldr	r3, [r3, #8]
}
 8007544:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return port->functions->setValue(port, 1<<gpioPin, on<<gpioPin);
 8007548:	4718      	bx	r3
	...

0800754c <converterSetGpio>:

static xTaskHandle mixLedTaskHandle;
static volatile uint32_t mixLedDelay = 0;

static void converterSetGpio(const ConverterManager* converter, uint32_t gpioValues)
{
 800754c:	b570      	push	{r4, r5, r6, lr}
    /* We need to set some IO depending on the active band */

    gpioValues |= bandSpecificGpioSettings[converter->activeBand];
 800754e:	4b69      	ldr	r3, [pc, #420]	; (80076f4 <converterSetGpio+0x1a8>)
 8007550:	7e05      	ldrb	r5, [r0, #24]
 8007552:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]

    /* The lowest 8 bits are all connected over I2C */
    //Not anymore! Changed in hardware V2
    
    uint8_t gpioVals = gpioValues;// & 0xFF;
    switch(converter->activeBand){
 8007556:	2d04      	cmp	r5, #4
    gpioValues |= bandSpecificGpioSettings[converter->activeBand];
 8007558:	ea44 0401 	orr.w	r4, r4, r1
    switch(converter->activeBand){
 800755c:	d86c      	bhi.n	8007638 <converterSetGpio+0xec>
 800755e:	2d01      	cmp	r5, #1
 8007560:	d84f      	bhi.n	8007602 <converterSetGpio+0xb6>
 8007562:	bb95      	cbnz	r5, 80075ca <converterSetGpio+0x7e>
        case 0:
            gpioSetPin(GPIO_SW_SW,0);//PB 0
 8007564:	4629      	mov	r1, r5
 8007566:	f44f 7080 	mov.w	r0, #256	; 0x100
 800756a:	f7ff ffdf 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_BYPASS,0);//PB 12
 800756e:	4629      	mov	r1, r5
 8007570:	f44f 7086 	mov.w	r0, #268	; 0x10c
 8007574:	f7ff ffda 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_MIX, 1);//PB 13
 8007578:	2101      	movs	r1, #1
 800757a:	f240 100d 	movw	r0, #269	; 0x10d
 800757e:	f7ff ffd5 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_X2, 0);//PB 14
 8007582:	4629      	mov	r1, r5
 8007584:	f44f 7087 	mov.w	r0, #270	; 0x10e
 8007588:	f7ff ffd0 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_EN, 0);//PB 15
 800758c:	4629      	mov	r1, r5
 800758e:	f240 100f 	movw	r0, #271	; 0x10f
 8007592:	f7ff ffcb 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_SW_EN,1);
 8007596:	2101      	movs	r1, #1
 8007598:	f44f 7084 	mov.w	r0, #264	; 0x108
            gpioSetPin(GPIO_SW_SW,0);//PB 0
            gpioSetPin(GPIO_SW_BYPASS,1);//PB 12
            gpioSetPin(GPIO_SW_MIX, 0);//PB 13
            gpioSetPin(GPIO_MIX_X2, 0);//PB 14
            gpioSetPin(GPIO_MIX_EN, 0);//PB 15
            gpioSetPin(GPIO_LOWBAND, 0);//PA 2
 800759c:	f7ff ffc6 	bl	800752c <gpioSetPin.isra.0>

void systemEnableMCO(bool enable)
{
    if(enable) {
        //RCC->CFGR |= STM32_MCOSEL_SYSCLK;
        RCC->CFGR |=STM32_MCOSEL_PLLDIV2;
 80075a0:	4a55      	ldr	r2, [pc, #340]	; (80076f8 <converterSetGpio+0x1ac>)
 80075a2:	6853      	ldr	r3, [r2, #4]
 80075a4:	f043 63e0 	orr.w	r3, r3, #117440512	; 0x7000000
 80075a8:	6053      	str	r3, [r2, #4]
    mixBlinkDelay += (gpioValues & _BV(CONVERTER_IO_PIN_LED1))? 100:0;
 80075aa:	f414 6380 	ands.w	r3, r4, #1024	; 0x400
 80075ae:	bf18      	it	ne
 80075b0:	2364      	movne	r3, #100	; 0x64
    mixBlinkDelay += (gpioValues & _BV(CONVERTER_IO_PIN_LED2))? 200:0;
 80075b2:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
 80075b6:	bf18      	it	ne
 80075b8:	24c8      	movne	r4, #200	; 0xc8
 80075ba:	441c      	add	r4, r3
    mixLedDelay = mixBlinkDelay;
 80075bc:	4b4f      	ldr	r3, [pc, #316]	; (80076fc <converterSetGpio+0x1b0>)
 80075be:	601c      	str	r4, [r3, #0]
    vTaskResume(mixLedTaskHandle);
 80075c0:	4b4f      	ldr	r3, [pc, #316]	; (8007700 <converterSetGpio+0x1b4>)
 80075c2:	681c      	ldr	r4, [r3, #0]
		configASSERT( xTaskToResume );
 80075c4:	2c00      	cmp	r4, #0
 80075c6:	d14d      	bne.n	8007664 <converterSetGpio+0x118>
 80075c8:	e7fe      	b.n	80075c8 <converterSetGpio+0x7c>
            gpioSetPin(GPIO_SW_SW,1);//PB 0
 80075ca:	2101      	movs	r1, #1
 80075cc:	f44f 7080 	mov.w	r0, #256	; 0x100
 80075d0:	f7ff ffac 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_BYPASS,0);//PB 12
 80075d4:	2100      	movs	r1, #0
 80075d6:	f44f 7086 	mov.w	r0, #268	; 0x10c
 80075da:	f7ff ffa7 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_MIX, 0);//PB 13
 80075de:	2100      	movs	r1, #0
 80075e0:	f240 100d 	movw	r0, #269	; 0x10d
 80075e4:	f7ff ffa2 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_X2, 0);//PB 14
 80075e8:	2100      	movs	r1, #0
 80075ea:	f44f 7087 	mov.w	r0, #270	; 0x10e
 80075ee:	f7ff ff9d 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_EN, 1);//PB 15
 80075f2:	2101      	movs	r1, #1
 80075f4:	f240 100f 	movw	r0, #271	; 0x10f
 80075f8:	f7ff ff98 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_LOWBAND, 1);//PA 2
 80075fc:	2101      	movs	r1, #1
            gpioSetPin(GPIO_LOWBAND, 0);//PA 2
 80075fe:	2002      	movs	r0, #2
 8007600:	e7cc      	b.n	800759c <converterSetGpio+0x50>
            gpioSetPin(GPIO_SW_SW,1);//PB 0
 8007602:	2101      	movs	r1, #1
 8007604:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007608:	f7ff ff90 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_BYPASS,0);//PB 12
 800760c:	2100      	movs	r1, #0
 800760e:	f44f 7086 	mov.w	r0, #268	; 0x10c
 8007612:	f7ff ff8b 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_MIX, 1);//PB 13
 8007616:	2101      	movs	r1, #1
 8007618:	f240 100d 	movw	r0, #269	; 0x10d
 800761c:	f7ff ff86 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_X2, 1);//PB 14
 8007620:	2101      	movs	r1, #1
 8007622:	f44f 7087 	mov.w	r0, #270	; 0x10e
 8007626:	f7ff ff81 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_EN, 1);//PB 15
 800762a:	2101      	movs	r1, #1
            gpioSetPin(GPIO_MIX_EN, 0);//PB 15
 800762c:	f240 100f 	movw	r0, #271	; 0x10f
 8007630:	f7ff ff7c 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_LOWBAND, 0);//PA 2
 8007634:	2100      	movs	r1, #0
 8007636:	e7e2      	b.n	80075fe <converterSetGpio+0xb2>
            gpioSetPin(GPIO_SW_SW,0);//PB 0
 8007638:	2100      	movs	r1, #0
 800763a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800763e:	f7ff ff75 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_BYPASS,1);//PB 12
 8007642:	2101      	movs	r1, #1
 8007644:	f44f 7086 	mov.w	r0, #268	; 0x10c
 8007648:	f7ff ff70 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_SW_MIX, 0);//PB 13
 800764c:	2100      	movs	r1, #0
 800764e:	f240 100d 	movw	r0, #269	; 0x10d
 8007652:	f7ff ff6b 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_X2, 0);//PB 14
 8007656:	2100      	movs	r1, #0
 8007658:	f44f 7087 	mov.w	r0, #270	; 0x10e
 800765c:	f7ff ff66 	bl	800752c <gpioSetPin.isra.0>
            gpioSetPin(GPIO_MIX_EN, 0);//PB 15
 8007660:	2100      	movs	r1, #0
 8007662:	e7e3      	b.n	800762c <converterSetGpio+0xe0>
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8007664:	4d27      	ldr	r5, [pc, #156]	; (8007704 <converterSetGpio+0x1b8>)
 8007666:	682b      	ldr	r3, [r5, #0]
 8007668:	429c      	cmp	r4, r3
 800766a:	d042      	beq.n	80076f2 <converterSetGpio+0x1a6>
			taskENTER_CRITICAL();
 800766c:	f7fd f992 	bl	8004994 <vPortEnterCritical>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8007670:	6962      	ldr	r2, [r4, #20]
 8007672:	4b25      	ldr	r3, [pc, #148]	; (8007708 <converterSetGpio+0x1bc>)
 8007674:	429a      	cmp	r2, r3
 8007676:	d138      	bne.n	80076ea <converterSetGpio+0x19e>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 8007678:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800767a:	4a24      	ldr	r2, [pc, #144]	; (800770c <converterSetGpio+0x1c0>)
 800767c:	4293      	cmp	r3, r2
 800767e:	d034      	beq.n	80076ea <converterSetGpio+0x19e>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 8007680:	bb9b      	cbnz	r3, 80076ea <converterSetGpio+0x19e>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 8007682:	1d26      	adds	r6, r4, #4
 8007684:	4630      	mov	r0, r6
 8007686:	f7fd f806 	bl	8004696 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800768a:	2301      	movs	r3, #1
 800768c:	4920      	ldr	r1, [pc, #128]	; (8007710 <converterSetGpio+0x1c4>)
 800768e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8007690:	6808      	ldr	r0, [r1, #0]
 8007692:	4093      	lsls	r3, r2
 8007694:	4303      	orrs	r3, r0
 8007696:	2014      	movs	r0, #20
 8007698:	600b      	str	r3, [r1, #0]
 800769a:	4b1e      	ldr	r3, [pc, #120]	; (8007714 <converterSetGpio+0x1c8>)
 800769c:	4631      	mov	r1, r6
 800769e:	fb00 3002 	mla	r0, r0, r2, r3
 80076a2:	f7fc ffd5 	bl	8004650 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80076a6:	682b      	ldr	r3, [r5, #0]
 80076a8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80076aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80076ac:	429a      	cmp	r2, r3
 80076ae:	d31c      	bcc.n	80076ea <converterSetGpio+0x19e>
						taskYIELD_IF_USING_PREEMPTION();
 80076b0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80076b4:	4a18      	ldr	r2, [pc, #96]	; (8007718 <converterSetGpio+0x1cc>)
 80076b6:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80076ba:	6011      	str	r1, [r2, #0]
 80076bc:	4a17      	ldr	r2, [pc, #92]	; (800771c <converterSetGpio+0x1d0>)
 80076be:	6812      	ldr	r2, [r2, #0]
 80076c0:	b14a      	cbz	r2, 80076d6 <converterSetGpio+0x18a>
 80076c2:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80076c6:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80076ca:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80076ce:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80076d2:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80076d6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80076da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80076de:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80076e2:	f3bf 8f4f 	dsb	sy
 80076e6:	f3bf 8f6f 	isb	sy
}
 80076ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 80076ee:	f7fd bb69 	b.w	8004dc4 <vPortExitCritical>
 80076f2:	bd70      	pop	{r4, r5, r6, pc}
 80076f4:	0800c8e4 	.word	0x0800c8e4
 80076f8:	40021000 	.word	0x40021000
 80076fc:	20001198 	.word	0x20001198
 8007700:	2000119c 	.word	0x2000119c
 8007704:	200011a8 	.word	0x200011a8
 8007708:	20001620 	.word	0x20001620
 800770c:	20001600 	.word	0x20001600
 8007710:	20001374 	.word	0x20001374
 8007714:	200011b8 	.word	0x200011b8
 8007718:	2000134c 	.word	0x2000134c
 800771c:	20001358 	.word	0x20001358

08007720 <usbShellTerminated>:
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
}

static volatile bool usbShellIsUp = false;
static void usbShellTerminated(void* param)
{
 8007720:	b508      	push	{r3, lr}
    (void)param;

    gpioSetPin(GPIO_LED_USB, true);
 8007722:	2101      	movs	r1, #1
 8007724:	f240 1003 	movw	r0, #259	; 0x103
 8007728:	f7ff ff00 	bl	800752c <gpioSetPin.isra.0>
    osalThreadSleepSeconds(1);
 800772c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007730:	f7fd fe26 	bl	8005380 <vTaskDelay>
    usbShellIsUp = false;
 8007734:	2200      	movs	r2, #0
 8007736:	4b01      	ldr	r3, [pc, #4]	; (800773c <usbShellTerminated+0x1c>)
 8007738:	701a      	strb	r2, [r3, #0]
}
 800773a:	bd08      	pop	{r3, pc}
 800773c:	20001355 	.word	0x20001355

08007740 <mac2870LockCallback>:
    if(locked) {
 8007740:	b120      	cbz	r0, 800774c <mac2870LockCallback+0xc>
        gpioSetPin(GPIO_LED_LOCK, false);
 8007742:	2100      	movs	r1, #0
        gpioSetPin(GPIO_LED_LOCK, true);
 8007744:	f44f 7082 	mov.w	r0, #260	; 0x104
 8007748:	f7ff bef0 	b.w	800752c <gpioSetPin.isra.0>
 800774c:	2101      	movs	r1, #1
 800774e:	e7f9      	b.n	8007744 <mac2870LockCallback+0x4>

08007750 <i2cSafeClockGoHigh>:
{
 8007750:	b538      	push	{r3, r4, r5, lr}
    gpioSetPin(config->sclPin, level);
 8007752:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
{
 8007754:	4605      	mov	r5, r0
    gpioSetPin(config->sclPin, level);
 8007756:	2101      	movs	r1, #1
 8007758:	8998      	ldrh	r0, [r3, #12]
 800775a:	f7ff fee7 	bl	800752c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 800775e:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8007762:	f7fe fbf1 	bl	8005f48 <vPortBusyDelay>
    for(j=5; !i2cSafeRawGetClock(i2c); j--) {
 8007766:	2406      	movs	r4, #6
    return gpioGetPin(config->sclPin);
 8007768:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800776a:	8998      	ldrh	r0, [r3, #12]
 800776c:	f7fc fe32 	bl	80043d4 <gpioGetPin>
    for(j=5; !i2cSafeRawGetClock(i2c); j--) {
 8007770:	b108      	cbz	r0, 8007776 <i2cSafeClockGoHigh+0x26>
    return I2C_BUS_OK;
 8007772:	2000      	movs	r0, #0
}
 8007774:	bd38      	pop	{r3, r4, r5, pc}
        osalThreadSleepMilliseconds(1);
 8007776:	2001      	movs	r0, #1
        if(j == 0) {
 8007778:	3c01      	subs	r4, #1
        osalThreadSleepMilliseconds(1);
 800777a:	f7fd fe01 	bl	8005380 <vTaskDelay>
        if(j == 0) {
 800777e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8007782:	d1f1      	bne.n	8007768 <i2cSafeClockGoHigh+0x18>
            return I2C_BUS_STUCK_SCL_PULLED_LOW;
 8007784:	2001      	movs	r0, #1
 8007786:	e7f5      	b.n	8007774 <i2cSafeClockGoHigh+0x24>

08007788 <i2cSafeClockGoLow>:
{
 8007788:	b510      	push	{r4, lr}
 800778a:	4604      	mov	r4, r0
    gpioSetPin(config->sclPin, level);
 800778c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 800778e:	2100      	movs	r1, #0
 8007790:	8998      	ldrh	r0, [r3, #12]
 8007792:	f7ff fecb 	bl	800752c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 8007796:	f44f 70c8 	mov.w	r0, #400	; 0x190
 800779a:	f7fe fbd5 	bl	8005f48 <vPortBusyDelay>
    return gpioGetPin(config->sclPin);
 800779e:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80077a0:	8998      	ldrh	r0, [r3, #12]
 80077a2:	f7fc fe17 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SCL_PULLED_HIGH;
 80077a6:	2800      	cmp	r0, #0
}
 80077a8:	bf14      	ite	ne
 80077aa:	2003      	movne	r0, #3
 80077ac:	2000      	moveq	r0, #0
 80077ae:	bd10      	pop	{r4, pc}

080077b0 <i2cSafeDataGoHigh>:
{
 80077b0:	b510      	push	{r4, lr}
 80077b2:	4604      	mov	r4, r0
    gpioSetPin(config->sdaPin, level);
 80077b4:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 80077b6:	2101      	movs	r1, #1
 80077b8:	89d8      	ldrh	r0, [r3, #14]
 80077ba:	f7ff feb7 	bl	800752c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 80077be:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80077c2:	f7fe fbc1 	bl	8005f48 <vPortBusyDelay>
    return gpioGetPin(config->sdaPin);
 80077c6:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80077c8:	89d8      	ldrh	r0, [r3, #14]
 80077ca:	f7fc fe03 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SDA_PULLED_LOW;
 80077ce:	2800      	cmp	r0, #0
}
 80077d0:	bf0c      	ite	eq
 80077d2:	2002      	moveq	r0, #2
 80077d4:	2000      	movne	r0, #0
 80077d6:	bd10      	pop	{r4, pc}

080077d8 <i2cSafeDataGoLow>:
{
 80077d8:	b510      	push	{r4, lr}
 80077da:	4604      	mov	r4, r0
    gpioSetPin(config->sdaPin, level);
 80077dc:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 80077de:	2100      	movs	r1, #0
 80077e0:	89d8      	ldrh	r0, [r3, #14]
 80077e2:	f7ff fea3 	bl	800752c <gpioSetPin.isra.0>
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 80077e6:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80077ea:	f7fe fbad 	bl	8005f48 <vPortBusyDelay>
    return gpioGetPin(config->sdaPin);
 80077ee:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80077f0:	89d8      	ldrh	r0, [r3, #14]
 80077f2:	f7fc fdef 	bl	80043d4 <gpioGetPin>
        return I2C_BUS_STUCK_SDA_PULLED_HIGH;
 80077f6:	2800      	cmp	r0, #0
}
 80077f8:	bf14      	ite	ne
 80077fa:	2004      	movne	r0, #4
 80077fc:	2000      	moveq	r0, #0
 80077fe:	bd10      	pop	{r4, pc}

08007800 <sdu_start_receive.isra.0>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8007800:	b510      	push	{r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8007802:	f8d0 1498 	ldr.w	r1, [r0, #1176]	; 0x498
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8007806:	4603      	mov	r3, r0
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8007808:	6808      	ldr	r0, [r1, #0]
 800780a:	7802      	ldrb	r2, [r0, #0]
 800780c:	2a04      	cmp	r2, #4
 800780e:	d11c      	bne.n	800784a <sdu_start_receive.isra.0+0x4a>
 8007810:	7d1a      	ldrb	r2, [r3, #20]
 8007812:	2a02      	cmp	r2, #2
 8007814:	d119      	bne.n	800784a <sdu_start_receive.isra.0+0x4a>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8007816:	2201      	movs	r2, #1
 8007818:	790c      	ldrb	r4, [r1, #4]
 800781a:	40a2      	lsls	r2, r4
 800781c:	8944      	ldrh	r4, [r0, #10]
 800781e:	4222      	tst	r2, r4
 8007820:	d113      	bne.n	800784a <sdu_start_receive.isra.0+0x4a>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007822:	f3ef 8211 	mrs	r2, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007826:	b16a      	cbz	r2, 8007844 <sdu_start_receive.isra.0+0x44>
  if (ibqIsFullI(ibqp)) {
 8007828:	e9d3 240a 	ldrd	r2, r4, [r3, #40]	; 0x28
 800782c:	42a2      	cmp	r2, r4
 800782e:	d101      	bne.n	8007834 <sdu_start_receive.isra.0+0x34>
 8007830:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007832:	b953      	cbnz	r3, 800784a <sdu_start_receive.isra.0+0x4a>
}
 8007834:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8007838:	f44f 7380 	mov.w	r3, #256	; 0x100
 800783c:	7949      	ldrb	r1, [r1, #5]
 800783e:	3204      	adds	r2, #4
 8007840:	f7fd b946 	b.w	8004ad0 <usbStartReceiveI>
  osalDbgCheckClassI();
 8007844:	f7fd f8b6 	bl	80049b4 <vTaskEndScheduler>
 8007848:	e7fe      	b.n	8007848 <sdu_start_receive.isra.0+0x48>
}
 800784a:	bd10      	pop	{r4, pc}

0800784c <ibnotify>:
  (void) sdu_start_receive(sdup);
 800784c:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800784e:	f7ff bfd7 	b.w	8007800 <sdu_start_receive.isra.0>

08007852 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8007852:	3111      	adds	r1, #17
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8007854:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8007856:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 800785a:	2c00      	cmp	r4, #0
 800785c:	d03d      	beq.n	80078da <sduDataReceived+0x88>
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 800785e:	2104      	movs	r1, #4
  osalSysLockFromISR();
 8007860:	f7fd ffe6 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 8007864:	1860      	adds	r0, r4, r1
 8007866:	f7ff fb35 	bl	8006ed4 <osalEventBroadcastFlagsI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800786a:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800786e:	b163      	cbz	r3, 800788a <sduDataReceived+0x38>
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8007870:	f8d4 2498 	ldr.w	r2, [r4, #1176]	; 0x498
 8007874:	6813      	ldr	r3, [r2, #0]
 8007876:	7952      	ldrb	r2, [r2, #5]
 8007878:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800787c:	68db      	ldr	r3, [r3, #12]
  ibqPostFullBufferI(&sdup->ibqueue,
 800787e:	699b      	ldr	r3, [r3, #24]
 8007880:	685a      	ldr	r2, [r3, #4]
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8007882:	b92a      	cbnz	r2, 8007890 <sduDataReceived+0x3e>
 8007884:	f7fd f896 	bl	80049b4 <vTaskEndScheduler>
 8007888:	e7fe      	b.n	8007888 <sduDataReceived+0x36>
  osalDbgCheckClassI();
 800788a:	f7fd f893 	bl	80049b4 <vTaskEndScheduler>
 800788e:	e7fe      	b.n	800788e <sduDataReceived+0x3c>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8007890:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8007892:	3b04      	subs	r3, #4
 8007894:	429a      	cmp	r2, r3
 8007896:	d8f5      	bhi.n	8007884 <sduDataReceived+0x32>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8007898:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
 800789c:	428b      	cmp	r3, r1
 800789e:	d104      	bne.n	80078aa <sduDataReceived+0x58>
 80078a0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80078a2:	b111      	cbz	r1, 80078aa <sduDataReceived+0x58>
 80078a4:	f7fd f886 	bl	80049b4 <vTaskEndScheduler>
 80078a8:	e7fe      	b.n	80078a8 <sduDataReceived+0x56>
  *((size_t *)ibqp->bwrptr) = size;
 80078aa:	601a      	str	r2, [r3, #0]
  ibqp->bcounter++;
 80078ac:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80078ae:	3201      	adds	r2, #1
 80078b0:	6262      	str	r2, [r4, #36]	; 0x24
  ibqp->bwrptr += ibqp->bsize;
 80078b2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80078b4:	4413      	add	r3, r2
  if (ibqp->bwrptr >= ibqp->btop) {
 80078b6:	6b22      	ldr	r2, [r4, #48]	; 0x30
  ibqp->bwrptr += ibqp->bsize;
 80078b8:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->bwrptr >= ibqp->btop) {
 80078ba:	4293      	cmp	r3, r2
 80078bc:	d20a      	bcs.n	80078d4 <sduDataReceived+0x82>
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 80078be:	f104 0018 	add.w	r0, r4, #24
 80078c2:	f7ff fae3 	bl	8006e8c <osalThreadDequeueNextI.constprop.0>
  (void) sdu_start_receive(sdup);
 80078c6:	4620      	mov	r0, r4
 80078c8:	f7ff ff9a 	bl	8007800 <sdu_start_receive.isra.0>
}
 80078cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlockFromISR();
 80078d0:	f7fd bfc2 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
    ibqp->bwrptr = ibqp->buffers;
 80078d4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80078d6:	62a3      	str	r3, [r4, #40]	; 0x28
 80078d8:	e7f1      	b.n	80078be <sduDataReceived+0x6c>
}
 80078da:	bd10      	pop	{r4, pc}

080078dc <ibqReadTimeout.part.0>:
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
 80078dc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80078e0:	461f      	mov	r7, r3
 80078e2:	4604      	mov	r4, r0
  size_t r = 0;
 80078e4:	2600      	movs	r6, #0
		xReturn = xTickCount;
 80078e6:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8007994 <ibqReadTimeout.part.0+0xb8>
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
 80078ea:	4690      	mov	r8, r2
 80078ec:	460d      	mov	r5, r1
  osalSysLock();
 80078ee:	f7fd f851 	bl	8004994 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80078f2:	f7fe fb0b 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80078f6:	f8da 3000 	ldr.w	r3, [sl]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80078fa:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 80078fe:	eb07 0903 	add.w	r9, r7, r3
    if (ibqp->ptr == NULL) {
 8007902:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007904:	b93b      	cbnz	r3, 8007916 <ibqReadTimeout.part.0+0x3a>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8007906:	f11b 0f03 	cmn.w	fp, #3
 800790a:	d92a      	bls.n	8007962 <ibqReadTimeout.part.0+0x86>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800790c:	4639      	mov	r1, r7
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800790e:	4620      	mov	r0, r4
 8007910:	f7fe fefe 	bl	8006710 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8007914:	bb68      	cbnz	r0, 8007972 <ibqReadTimeout.part.0+0x96>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8007916:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
    if (size > (n - r)) {
 800791a:	eba8 0306 	sub.w	r3, r8, r6
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800791e:	1a52      	subs	r2, r2, r1
    if (size > (n - r)) {
 8007920:	429a      	cmp	r2, r3
 8007922:	bf28      	it	cs
 8007924:	461a      	movcs	r2, r3
    if (size > 64U) {
 8007926:	2a40      	cmp	r2, #64	; 0x40
 8007928:	d929      	bls.n	800797e <ibqReadTimeout.part.0+0xa2>
      memcpy(bp, ibqp->ptr, 64U);
 800792a:	462b      	mov	r3, r5
 800792c:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8007930:	f851 0b04 	ldr.w	r0, [r1], #4
 8007934:	4291      	cmp	r1, r2
 8007936:	f843 0b04 	str.w	r0, [r3], #4
 800793a:	d1f9      	bne.n	8007930 <ibqReadTimeout.part.0+0x54>
      ibqp->ptr += 64U;
 800793c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += 64U;
 800793e:	3540      	adds	r5, #64	; 0x40
      ibqp->ptr += 64U;
 8007940:	3340      	adds	r3, #64	; 0x40
 8007942:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += 64U;
 8007944:	3640      	adds	r6, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
 8007946:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 800794a:	429a      	cmp	r2, r3
 800794c:	d302      	bcc.n	8007954 <ibqReadTimeout.part.0+0x78>
      ibqReleaseEmptyBufferS(ibqp);
 800794e:	4620      	mov	r0, r4
 8007950:	f7fd f83c 	bl	80049cc <ibqReleaseEmptyBufferS>
    osalSysUnlock();
 8007954:	f7fd fa42 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    if (r >= n) {
 8007958:	45b0      	cmp	r8, r6
 800795a:	d90c      	bls.n	8007976 <ibqReadTimeout.part.0+0x9a>
    osalSysLock();
 800795c:	f7fd f81a 	bl	8004994 <vPortEnterCritical>
  while (true) {
 8007960:	e7cf      	b.n	8007902 <ibqReadTimeout.part.0+0x26>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007962:	f7fe fad3 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8007966:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800796a:	eba9 0101 	sub.w	r1, r9, r1
        if (next_timeout > timeout) {
 800796e:	428f      	cmp	r7, r1
 8007970:	d2cd      	bcs.n	800790e <ibqReadTimeout.part.0+0x32>
        osalSysUnlock();
 8007972:	f7fd fa33 	bl	8004ddc <osalSysUnlock.lto_priv.0>
}
 8007976:	4630      	mov	r0, r6
 8007978:	b003      	add	sp, #12
 800797a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      memcpy(bp, ibqp->ptr, size);
 800797e:	4628      	mov	r0, r5
 8007980:	9201      	str	r2, [sp, #4]
 8007982:	f7fc f8a7 	bl	8003ad4 <memcpy>
      bp        += size;
 8007986:	9a01      	ldr	r2, [sp, #4]
      ibqp->ptr += size;
 8007988:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
 800798a:	4415      	add	r5, r2
      ibqp->ptr += size;
 800798c:	4413      	add	r3, r2
 800798e:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
 8007990:	4416      	add	r6, r2
 8007992:	e7d8      	b.n	8007946 <ibqReadTimeout.part.0+0x6a>
 8007994:	20001648 	.word	0x20001648

08007998 <_readt.lto_priv.1>:
static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8007998:	b510      	push	{r4, lr}
  osalDbgCheck(n > 0U);
 800799a:	b912      	cbnz	r2, 80079a2 <_readt.lto_priv.1+0xa>
 800799c:	f7fd f80a 	bl	80049b4 <vTaskEndScheduler>
 80079a0:	e7fe      	b.n	80079a0 <_readt.lto_priv.1+0x8>
 80079a2:	3018      	adds	r0, #24
}
 80079a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80079a8:	f7ff bf98 	b.w	80078dc <ibqReadTimeout.part.0>

080079ac <_read.lto_priv.1>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 80079ac:	b510      	push	{r4, lr}
 80079ae:	b912      	cbnz	r2, 80079b6 <_read.lto_priv.1+0xa>
 80079b0:	f7fd f800 	bl	80049b4 <vTaskEndScheduler>
 80079b4:	e7fe      	b.n	80079b4 <_read.lto_priv.1+0x8>
 80079b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 80079ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80079be:	3018      	adds	r0, #24
 80079c0:	f7ff bf8c 	b.w	80078dc <ibqReadTimeout.part.0>

080079c4 <obqWriteTimeout.part.0>:
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
 80079c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80079c8:	461f      	mov	r7, r3
 80079ca:	4604      	mov	r4, r0
  size_t w = 0;
 80079cc:	2600      	movs	r6, #0
 80079ce:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8007a7c <obqWriteTimeout.part.0+0xb8>
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
 80079d2:	4690      	mov	r8, r2
 80079d4:	460d      	mov	r5, r1
  osalSysLock();
 80079d6:	f7fc ffdd 	bl	8004994 <vPortEnterCritical>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80079da:	f7fe fa97 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80079de:	f8da 3000 	ldr.w	r3, [sl]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80079e2:	f107 3bff 	add.w	fp, r7, #4294967295	; 0xffffffff
  deadline = osalOsGetSystemTimeX() + timeout;
 80079e6:	eb07 0903 	add.w	r9, r7, r3
    if (obqp->ptr == NULL) {
 80079ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80079ec:	b93b      	cbnz	r3, 80079fe <obqWriteTimeout.part.0+0x3a>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80079ee:	f11b 0f03 	cmn.w	fp, #3
 80079f2:	d92a      	bls.n	8007a4a <obqWriteTimeout.part.0+0x86>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80079f4:	4639      	mov	r1, r7
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80079f6:	4620      	mov	r0, r4
 80079f8:	f7fe fed7 	bl	80067aa <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 80079fc:	bb68      	cbnz	r0, 8007a5a <obqWriteTimeout.part.0+0x96>
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80079fe:	e9d4 020a 	ldrd	r0, r2, [r4, #40]	; 0x28
    if (size > (n - w)) {
 8007a02:	eba8 0306 	sub.w	r3, r8, r6
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8007a06:	1a12      	subs	r2, r2, r0
    if (size > (n - w)) {
 8007a08:	429a      	cmp	r2, r3
 8007a0a:	bf28      	it	cs
 8007a0c:	461a      	movcs	r2, r3
    if (size > 64U) {
 8007a0e:	2a40      	cmp	r2, #64	; 0x40
 8007a10:	d929      	bls.n	8007a66 <obqWriteTimeout.part.0+0xa2>
      memcpy(obqp->ptr, bp, 64U);
 8007a12:	f105 0340 	add.w	r3, r5, #64	; 0x40
 8007a16:	f855 2b04 	ldr.w	r2, [r5], #4
 8007a1a:	429d      	cmp	r5, r3
 8007a1c:	f840 2b04 	str.w	r2, [r0], #4
 8007a20:	d1f9      	bne.n	8007a16 <obqWriteTimeout.part.0+0x52>
      obqp->ptr += 64U;
 8007a22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      w         += 64U;
 8007a24:	3640      	adds	r6, #64	; 0x40
      obqp->ptr += 64U;
 8007a26:	3340      	adds	r3, #64	; 0x40
 8007a28:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8007a2a:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
 8007a2e:	429a      	cmp	r2, r3
 8007a30:	d304      	bcc.n	8007a3c <obqWriteTimeout.part.0+0x78>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8007a32:	69e1      	ldr	r1, [r4, #28]
 8007a34:	4620      	mov	r0, r4
 8007a36:	3904      	subs	r1, #4
 8007a38:	f7fd f802 	bl	8004a40 <obqPostFullBufferS>
    osalSysUnlock();
 8007a3c:	f7fd f9ce 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    if (w >= n) {
 8007a40:	45b0      	cmp	r8, r6
 8007a42:	d90c      	bls.n	8007a5e <obqWriteTimeout.part.0+0x9a>
    osalSysLock();
 8007a44:	f7fc ffa6 	bl	8004994 <vPortEnterCritical>
  while (true) {
 8007a48:	e7cf      	b.n	80079ea <obqWriteTimeout.part.0+0x26>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007a4a:	f7fe fa5f 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8007a4e:	f8da 1000 	ldr.w	r1, [sl]
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8007a52:	eba9 0101 	sub.w	r1, r9, r1
        if (next_timeout > timeout) {
 8007a56:	428f      	cmp	r7, r1
 8007a58:	d2cd      	bcs.n	80079f6 <obqWriteTimeout.part.0+0x32>
        osalSysUnlock();
 8007a5a:	f7fd f9bf 	bl	8004ddc <osalSysUnlock.lto_priv.0>
}
 8007a5e:	4630      	mov	r0, r6
 8007a60:	b003      	add	sp, #12
 8007a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      memcpy(obqp->ptr, bp, size);
 8007a66:	4629      	mov	r1, r5
 8007a68:	9201      	str	r2, [sp, #4]
 8007a6a:	f7fc f833 	bl	8003ad4 <memcpy>
      bp        += size;
 8007a6e:	9a01      	ldr	r2, [sp, #4]
      obqp->ptr += size;
 8007a70:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
 8007a72:	4415      	add	r5, r2
      obqp->ptr += size;
 8007a74:	4413      	add	r3, r2
 8007a76:	62a3      	str	r3, [r4, #40]	; 0x28
      w         += size;
 8007a78:	4416      	add	r6, r2
 8007a7a:	e7d6      	b.n	8007a2a <obqWriteTimeout.part.0+0x66>
 8007a7c:	20001648 	.word	0x20001648

08007a80 <_write.lto_priv.1>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a80:	b570      	push	{r4, r5, r6, lr}
 8007a82:	4615      	mov	r5, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a84:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a88:	4604      	mov	r4, r0
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a8a:	6893      	ldr	r3, [r2, #8]
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8007a8c:	460e      	mov	r6, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007a8e:	b113      	cbz	r3, 8007a96 <_write.lto_priv.1+0x16>
 8007a90:	2101      	movs	r1, #1
 8007a92:	6810      	ldr	r0, [r2, #0]
 8007a94:	4798      	blx	r3
  osalDbgCheck(n > 0U);
 8007a96:	b915      	cbnz	r5, 8007a9e <_write.lto_priv.1+0x1e>
 8007a98:	f7fc ff8c 	bl	80049b4 <vTaskEndScheduler>
 8007a9c:	e7fe      	b.n	8007a9c <_write.lto_priv.1+0x1c>
 8007a9e:	462a      	mov	r2, r5
 8007aa0:	4631      	mov	r1, r6
 8007aa2:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8007aa6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
 8007aaa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8007aae:	f7ff bf89 	b.w	80079c4 <obqWriteTimeout.part.0>

08007ab2 <_writet.lto_priv.1>:
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007ab2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007ab6:	4615      	mov	r5, r2
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007ab8:	f8d0 2498 	ldr.w	r2, [r0, #1176]	; 0x498
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007abc:	461f      	mov	r7, r3
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007abe:	6893      	ldr	r3, [r2, #8]
static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007ac0:	4604      	mov	r4, r0
 8007ac2:	460e      	mov	r6, r1
  if(sdup->config->sofCallback) sdup->config->sofCallback(sdup->config->usbp, true);
 8007ac4:	b113      	cbz	r3, 8007acc <_writet.lto_priv.1+0x1a>
 8007ac6:	2101      	movs	r1, #1
 8007ac8:	6810      	ldr	r0, [r2, #0]
 8007aca:	4798      	blx	r3
 8007acc:	b915      	cbnz	r5, 8007ad4 <_writet.lto_priv.1+0x22>
 8007ace:	f7fc ff71 	bl	80049b4 <vTaskEndScheduler>
 8007ad2:	e7fe      	b.n	8007ad2 <_writet.lto_priv.1+0x20>
 8007ad4:	463b      	mov	r3, r7
 8007ad6:	462a      	mov	r2, r5
 8007ad8:	4631      	mov	r1, r6
 8007ada:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8007ade:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8007ae2:	f7ff bf6f 	b.w	80079c4 <obqWriteTimeout.part.0>

08007ae6 <_writes>:
static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 8007ae6:	b538      	push	{r3, r4, r5, lr}
 8007ae8:	4605      	mov	r5, r0
  if (msp->size - msp->eos < n)
 8007aea:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8007aee:	1a1c      	subs	r4, r3, r0
 8007af0:	4294      	cmp	r4, r2
 8007af2:	bf28      	it	cs
 8007af4:	4614      	movcs	r4, r2
  memcpy(msp->buffer + msp->eos, bp, n);
 8007af6:	686b      	ldr	r3, [r5, #4]
 8007af8:	4622      	mov	r2, r4
 8007afa:	4418      	add	r0, r3
 8007afc:	f7fb ffea 	bl	8003ad4 <memcpy>
  msp->eos += n;
 8007b00:	68eb      	ldr	r3, [r5, #12]
}
 8007b02:	4620      	mov	r0, r4
  msp->eos += n;
 8007b04:	4423      	add	r3, r4
 8007b06:	60eb      	str	r3, [r5, #12]
}
 8007b08:	bd38      	pop	{r3, r4, r5, pc}

08007b0a <_reads>:
static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8007b0a:	b538      	push	{r3, r4, r5, lr}
 8007b0c:	4605      	mov	r5, r0
 8007b0e:	4608      	mov	r0, r1
  if (msp->eos - msp->offset < n)
 8007b10:	e9d5 3103 	ldrd	r3, r1, [r5, #12]
 8007b14:	1a5c      	subs	r4, r3, r1
 8007b16:	4294      	cmp	r4, r2
 8007b18:	bf28      	it	cs
 8007b1a:	4614      	movcs	r4, r2
  memcpy(bp, msp->buffer + msp->offset, n);
 8007b1c:	686b      	ldr	r3, [r5, #4]
 8007b1e:	4622      	mov	r2, r4
 8007b20:	4419      	add	r1, r3
 8007b22:	f7fb ffd7 	bl	8003ad4 <memcpy>
  msp->offset += n;
 8007b26:	692b      	ldr	r3, [r5, #16]
}
 8007b28:	4620      	mov	r0, r4
  msp->offset += n;
 8007b2a:	4423      	add	r3, r4
 8007b2c:	612b      	str	r3, [r5, #16]
}
 8007b2e:	bd38      	pop	{r3, r4, r5, pc}

08007b30 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
 8007b30:	b570      	push	{r4, r5, r6, lr}
 8007b32:	4604      	mov	r4, r0
 8007b34:	460e      	mov	r6, r1
 8007b36:	4615      	mov	r5, r2
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007b38:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007b3c:	b11b      	cbz	r3, 8007b46 <usbInitEndpointI+0x16>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8007b3e:	b928      	cbnz	r0, 8007b4c <usbInitEndpointI+0x1c>
 8007b40:	f7fc ff38 	bl	80049b4 <vTaskEndScheduler>
 8007b44:	e7fe      	b.n	8007b44 <usbInitEndpointI+0x14>
  osalDbgCheckClassI();
 8007b46:	f7fc ff35 	bl	80049b4 <vTaskEndScheduler>
 8007b4a:	e7fe      	b.n	8007b4a <usbInitEndpointI+0x1a>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8007b4c:	7803      	ldrb	r3, [r0, #0]
 8007b4e:	2b04      	cmp	r3, #4
 8007b50:	d002      	beq.n	8007b58 <usbInitEndpointI+0x28>
 8007b52:	f7fc ff2f 	bl	80049b4 <vTaskEndScheduler>
 8007b56:	e7fe      	b.n	8007b56 <usbInitEndpointI+0x26>
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8007b58:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8007b5c:	68d9      	ldr	r1, [r3, #12]
 8007b5e:	b111      	cbz	r1, 8007b66 <usbInitEndpointI+0x36>
 8007b60:	f7fc ff28 	bl	80049b4 <vTaskEndScheduler>
 8007b64:	e7fe      	b.n	8007b64 <usbInitEndpointI+0x34>
  if (epcp->in_state != NULL) {
 8007b66:	6950      	ldr	r0, [r2, #20]
  usbp->epc[ep] = epcp;
 8007b68:	60da      	str	r2, [r3, #12]
  if (epcp->in_state != NULL) {
 8007b6a:	b110      	cbz	r0, 8007b72 <usbInitEndpointI+0x42>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8007b6c:	2210      	movs	r2, #16
 8007b6e:	f003 fe4d 	bl	800b80c <memset>
  if (epcp->out_state != NULL) {
 8007b72:	69a8      	ldr	r0, [r5, #24]
 8007b74:	b118      	cbz	r0, 8007b7e <usbInitEndpointI+0x4e>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8007b76:	2210      	movs	r2, #16
 8007b78:	2100      	movs	r1, #0
 8007b7a:	f003 fe47 	bl	800b80c <memset>
  usb_lld_init_endpoint(usbp, ep);
 8007b7e:	4631      	mov	r1, r6
 8007b80:	4620      	mov	r0, r4
}
 8007b82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_init_endpoint(usbp, ep);
 8007b86:	f7fd b895 	b.w	8004cb4 <usb_lld_init_endpoint>

08007b8a <get_history>:
    shp->sh_end -= shp->sh_size;
  *(shp->sh_buffer + shp->sh_end) = 0;
  shp->sh_cur = 0;
}

static int get_history(ShellHistory *shp, char *line, int dir) {
 8007b8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (shp == NULL)
    return -1;

  /* Count the number of lines saved in the buffer */
  int idx = shp->sh_beg;
  while (idx != shp->sh_end) {
 8007b8e:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
static int get_history(ShellHistory *shp, char *line, int dir) {
 8007b92:	4604      	mov	r4, r0
 8007b94:	4688      	mov	r8, r1
  int idx = shp->sh_beg;
 8007b96:	4628      	mov	r0, r5
  int count=0;
 8007b98:	2100      	movs	r1, #0
  while (idx != shp->sh_end) {
 8007b9a:	4286      	cmp	r6, r0
 8007b9c:	d12a      	bne.n	8007bf4 <get_history+0x6a>
    if (idx >= shp->sh_size)
      idx -= shp->sh_size;
    count++;
  }

  if (dir == SHELL_HIST_DIR_FW) {
 8007b9e:	2a01      	cmp	r2, #1
 8007ba0:	d104      	bne.n	8007bac <get_history+0x22>
    if (shp->sh_cur > 0)
 8007ba2:	6923      	ldr	r3, [r4, #16]
 8007ba4:	2b00      	cmp	r3, #0
 8007ba6:	dd48      	ble.n	8007c3a <get_history+0xb0>
      shp->sh_cur -= 2;
 8007ba8:	3b02      	subs	r3, #2
 8007baa:	6123      	str	r3, [r4, #16]
    else
      return 0;
  }

  if (count >= shp->sh_cur) {
 8007bac:	6923      	ldr	r3, [r4, #16]
 8007bae:	428b      	cmp	r3, r1
 8007bb0:	dc45      	bgt.n	8007c3e <get_history+0xb4>
    idx += *(shp->sh_buffer + idx) + 1;
 8007bb2:	f8d4 c000 	ldr.w	ip, [r4]
 8007bb6:	3901      	subs	r1, #1
    idx = shp->sh_beg;
    int i = 0;
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
      idx += *(shp->sh_buffer + idx) + 1;
 8007bb8:	f81c 7005 	ldrb.w	r7, [ip, r5]
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8007bbc:	42a8      	cmp	r0, r5
      idx += *(shp->sh_buffer + idx) + 1;
 8007bbe:	463e      	mov	r6, r7
    while (idx != shp->sh_end && shp->sh_cur != (count - i - 1)) {
 8007bc0:	d001      	beq.n	8007bc6 <get_history+0x3c>
 8007bc2:	428b      	cmp	r3, r1
 8007bc4:	d120      	bne.n	8007c08 <get_history+0x7e>
      i++;
    }

    int length = *(shp->sh_buffer + idx);

    if (length > 0) {
 8007bc6:	b39f      	cbz	r7, 8007c30 <get_history+0xa6>
      shp->sh_cur++;
 8007bc8:	3301      	adds	r3, #1

      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8007bca:	2240      	movs	r2, #64	; 0x40
 8007bcc:	2100      	movs	r1, #0
      shp->sh_cur++;
 8007bce:	6123      	str	r3, [r4, #16]
      memset(line, 0, SHELL_MAX_LINE_LENGTH);
 8007bd0:	4640      	mov	r0, r8
 8007bd2:	f003 fe1b 	bl	800b80c <memset>
      if ((idx + length) < shp->sh_size) {
 8007bd6:	6863      	ldr	r3, [r4, #4]
 8007bd8:	19ea      	adds	r2, r5, r7
 8007bda:	429a      	cmp	r2, r3
 8007bdc:	6820      	ldr	r0, [r4, #0]
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8007bde:	f105 0101 	add.w	r1, r5, #1
      if ((idx + length) < shp->sh_size) {
 8007be2:	da19      	bge.n	8007c18 <get_history+0x8e>
        memcpy(line, (shp->sh_buffer + idx + 1), length);
 8007be4:	4401      	add	r1, r0
 8007be6:	463a      	mov	r2, r7
 8007be8:	4640      	mov	r0, r8
         * Since the saved line was split at the end of the buffer,
         * get the line in two parts.
         */
        int part_len = shp->sh_size - idx - 1;
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8007bea:	f7fb ff73 	bl	8003ad4 <memcpy>
      shp->sh_cur++;
      return 0;
    }
  }
  return -1;
}
 8007bee:	4630      	mov	r0, r6
 8007bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    idx += *(shp->sh_buffer + idx) + 1;
 8007bf4:	6823      	ldr	r3, [r4, #0]
    count++;
 8007bf6:	3101      	adds	r1, #1
    idx += *(shp->sh_buffer + idx) + 1;
 8007bf8:	5c1b      	ldrb	r3, [r3, r0]
 8007bfa:	3301      	adds	r3, #1
 8007bfc:	4418      	add	r0, r3
    if (idx >= shp->sh_size)
 8007bfe:	6863      	ldr	r3, [r4, #4]
 8007c00:	4283      	cmp	r3, r0
      idx -= shp->sh_size;
 8007c02:	bfd8      	it	le
 8007c04:	1ac0      	suble	r0, r0, r3
    count++;
 8007c06:	e7c8      	b.n	8007b9a <get_history+0x10>
      if (idx >= shp->sh_size)
 8007c08:	6866      	ldr	r6, [r4, #4]
      idx += *(shp->sh_buffer + idx) + 1;
 8007c0a:	3701      	adds	r7, #1
 8007c0c:	443d      	add	r5, r7
      if (idx >= shp->sh_size)
 8007c0e:	42ae      	cmp	r6, r5
        idx -= shp->sh_size;
 8007c10:	bfd8      	it	le
 8007c12:	1bad      	suble	r5, r5, r6
      i++;
 8007c14:	3901      	subs	r1, #1
 8007c16:	e7cf      	b.n	8007bb8 <get_history+0x2e>
        int part_len = shp->sh_size - idx - 1;
 8007c18:	1b5d      	subs	r5, r3, r5
 8007c1a:	3d01      	subs	r5, #1
        memcpy(line, shp->sh_buffer + idx + 1, part_len);
 8007c1c:	4401      	add	r1, r0
 8007c1e:	462a      	mov	r2, r5
 8007c20:	4640      	mov	r0, r8
 8007c22:	f7fb ff57 	bl	8003ad4 <memcpy>
        memcpy(line + part_len, shp->sh_buffer, length - part_len);
 8007c26:	6821      	ldr	r1, [r4, #0]
 8007c28:	1b7a      	subs	r2, r7, r5
 8007c2a:	eb08 0005 	add.w	r0, r8, r5
 8007c2e:	e7dc      	b.n	8007bea <get_history+0x60>
    else if (dir == SHELL_HIST_DIR_FW) {
 8007c30:	2a01      	cmp	r2, #1
 8007c32:	d104      	bne.n	8007c3e <get_history+0xb4>
      shp->sh_cur++;
 8007c34:	3301      	adds	r3, #1
 8007c36:	6123      	str	r3, [r4, #16]
      return 0;
 8007c38:	e7d9      	b.n	8007bee <get_history+0x64>
      return 0;
 8007c3a:	2600      	movs	r6, #0
 8007c3c:	e7d7      	b.n	8007bee <get_history+0x64>
  return -1;
 8007c3e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8007c42:	e7d4      	b.n	8007bee <get_history+0x64>

08007c44 <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007c44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007c48:	460d      	mov	r5, r1
 8007c4a:	e9dd 9808 	ldrd	r9, r8, [sp, #32]
 8007c4e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007c50:	0096      	lsls	r6, r2, #2
 8007c52:	4632      	mov	r2, r6
 8007c54:	21a5      	movs	r1, #165	; 0xa5
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007c56:	4607      	mov	r7, r0
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007c58:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8007c5a:	469a      	mov	sl, r3
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8007c5c:	f003 fdd6 	bl	800b80c <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8007c60:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8007c62:	3e04      	subs	r6, #4
 8007c64:	4432      	add	r2, r6
 8007c66:	1e6b      	subs	r3, r5, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8007c68:	f022 0207 	bic.w	r2, r2, #7
 8007c6c:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8007c70:	350f      	adds	r5, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8007c72:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8007c76:	f801 0b01 	strb.w	r0, [r1], #1
		if( pcName[ x ] == 0x00 )
 8007c7a:	b108      	cbz	r0, 8007c80 <prvInitialiseNewTask.constprop.0+0x3c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8007c7c:	42ab      	cmp	r3, r5
 8007c7e:	d1f8      	bne.n	8007c72 <prvInitialiseNewTask.constprop.0+0x2e>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c80:	f1c9 0305 	rsb	r3, r9, #5
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007c84:	2100      	movs	r1, #0
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007c86:	61a3      	str	r3, [r4, #24]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8007c88:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
		pxNewTCB->ulNotifiedValue = 0;
 8007c8c:	6621      	str	r1, [r4, #96]	; 0x60
		pxNewTCB->uxMutexesHeld = 0;
 8007c8e:	e9c4 9113 	strd	r9, r1, [r4, #76]	; 0x4c
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 8007c92:	e9c4 1115 	strd	r1, r1, [r4, #84]	; 0x54
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8007c96:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
 8007c9a:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
	pxItem->pvContainer = NULL;
 8007c9e:	6161      	str	r1, [r4, #20]
 8007ca0:	62a1      	str	r1, [r4, #40]	; 0x28
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8007ca2:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8007ca4:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 8007ca6:	65e1      	str	r1, [r4, #92]	; 0x5c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8007ca8:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
 8007cac:	f842 3c04 	str.w	r3, [r2, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007cb0:	4b0a      	ldr	r3, [pc, #40]	; (8007cdc <prvInitialiseNewTask.constprop.0+0x98>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8007cb2:	f027 0701 	bic.w	r7, r7, #1
 8007cb6:	f842 7c08 	str.w	r7, [r2, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8007cba:	f842 3c0c 	str.w	r3, [r2, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8007cbe:	f842 ac20 	str.w	sl, [r2, #-32]
	*pxTopOfStack = 0;
 8007cc2:	f842 1c44 	str.w	r1, [r2, #-68]
	*pxTopOfStack = 0;
 8007cc6:	f842 1d48 	str.w	r1, [r2, #-72]!
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8007cca:	6022      	str	r2, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8007ccc:	f1b8 0f00 	cmp.w	r8, #0
 8007cd0:	d001      	beq.n	8007cd6 <prvInitialiseNewTask.constprop.0+0x92>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8007cd2:	f8c8 4000 	str.w	r4, [r8]
}
 8007cd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007cda:	bf00      	nop
 8007cdc:	08004dad 	.word	0x08004dad

08007ce0 <xTaskCreate.isra.0>:
	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 8007ce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007ce4:	4606      	mov	r6, r0
 8007ce6:	b085      	sub	sp, #20
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007ce8:	0090      	lsls	r0, r2, #2
	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 8007cea:	460f      	mov	r7, r1
 8007cec:	e9dd 9a0e 	ldrd	r9, sl, [sp, #56]	; 0x38
 8007cf0:	4693      	mov	fp, r2
 8007cf2:	4698      	mov	r8, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8007cf4:	f7fd fa86 	bl	8005204 <pvPortMalloc>
			if( pxStack != NULL )
 8007cf8:	4605      	mov	r5, r0
 8007cfa:	b1f0      	cbz	r0, 8007d3a <xTaskCreate.isra.0+0x5a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8007cfc:	2068      	movs	r0, #104	; 0x68
 8007cfe:	f7fd fa81 	bl	8005204 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8007d02:	4604      	mov	r4, r0
 8007d04:	b198      	cbz	r0, 8007d2e <xTaskCreate.isra.0+0x4e>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8007d06:	2300      	movs	r3, #0
					pxNewTCB->pxStack = pxStack;
 8007d08:	6305      	str	r5, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8007d0a:	f880 3065 	strb.w	r3, [r0, #101]	; 0x65
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8007d0e:	465a      	mov	r2, fp
 8007d10:	e9cd a001 	strd	sl, r0, [sp, #4]
 8007d14:	4643      	mov	r3, r8
 8007d16:	4630      	mov	r0, r6
 8007d18:	4639      	mov	r1, r7
 8007d1a:	f8cd 9000 	str.w	r9, [sp]
 8007d1e:	f7ff ff91 	bl	8007c44 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 8007d22:	4620      	mov	r0, r4
	}
 8007d24:	b005      	add	sp, #20
 8007d26:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			prvAddNewTaskToReadyList( pxNewTCB );
 8007d2a:	f7fd b933 	b.w	8004f94 <prvAddNewTaskToReadyList>
					vPortFree( pxStack );
 8007d2e:	4628      	mov	r0, r5
	}
 8007d30:	b005      	add	sp, #20
 8007d32:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					vPortFree( pxStack );
 8007d36:	f7fd bae9 	b.w	800530c <vPortFree>
	}
 8007d3a:	b005      	add	sp, #20
 8007d3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08007d40 <shellStart.constprop.0>:
    syslog("Shell 0x%08x started (%s).", activeShell, activeShell->taskName);

    shellThread(&activeShell->shellCfg);
}

bool shellStart(BaseSequentialStream* stream,
 8007d40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007d42:	4606      	mov	r6, r0
                unsigned int histSize, const char* taskName,
                void(*terminateCallback)(void* param), void* param)
{
    ActiveShell* activeShell = pvPortMalloc(sizeof(ActiveShell));
 8007d44:	2020      	movs	r0, #32
bool shellStart(BaseSequentialStream* stream,
 8007d46:	460d      	mov	r5, r1
 8007d48:	4617      	mov	r7, r2
    ActiveShell* activeShell = pvPortMalloc(sizeof(ActiveShell));
 8007d4a:	f7fd fa5b 	bl	8005204 <pvPortMalloc>
    if(!activeShell) {
 8007d4e:	4604      	mov	r4, r0
 8007d50:	b300      	cbz	r0, 8007d94 <shellStart.constprop.0+0x54>
        return false;
    }

    memset(activeShell, 0, sizeof(*activeShell));
 8007d52:	2220      	movs	r2, #32
 8007d54:	2100      	movs	r1, #0
 8007d56:	f003 fd59 	bl	800b80c <memset>

    activeShell->param = param;
    activeShell->terminateCallback = terminateCallback;

    activeShell->shellCfg.sc_channel = stream;
    activeShell->shellCfg.sc_commands = shellCommands;
 8007d5a:	4b0f      	ldr	r3, [pc, #60]	; (8007d98 <shellStart.constprop.0+0x58>)

    if(histSize) {
        activeShell->shellCfg.sc_histbuf = pvPortMalloc(histSize);
 8007d5c:	2080      	movs	r0, #128	; 0x80
    activeShell->terminateCallback = terminateCallback;
 8007d5e:	61a7      	str	r7, [r4, #24]
    activeShell->shellCfg.sc_channel = stream;
 8007d60:	6066      	str	r6, [r4, #4]
    activeShell->shellCfg.sc_commands = shellCommands;
 8007d62:	60a3      	str	r3, [r4, #8]
        activeShell->shellCfg.sc_histbuf = pvPortMalloc(histSize);
 8007d64:	f7fd fa4e 	bl	8005204 <pvPortMalloc>
 8007d68:	60e0      	str	r0, [r4, #12]
        if(activeShell->shellCfg.sc_histbuf) {
 8007d6a:	b128      	cbz	r0, 8007d78 <shellStart.constprop.0+0x38>
            memset(activeShell->shellCfg.sc_histbuf, 0, histSize);
 8007d6c:	2780      	movs	r7, #128	; 0x80
 8007d6e:	2100      	movs	r1, #0
 8007d70:	463a      	mov	r2, r7
 8007d72:	f003 fd4b 	bl	800b80c <memset>
            activeShell->shellCfg.sc_histsize = histSize;
 8007d76:	6127      	str	r7, [r4, #16]
        }
    }

    activeShell->stream = stream;
    activeShell->taskName = taskName;
    xTaskCreate(shellStartThread, taskName, 256, activeShell, 2, NULL);
 8007d78:	2302      	movs	r3, #2
 8007d7a:	2200      	movs	r2, #0
 8007d7c:	4807      	ldr	r0, [pc, #28]	; (8007d9c <shellStart.constprop.0+0x5c>)
    activeShell->stream = stream;
 8007d7e:	6166      	str	r6, [r4, #20]
    activeShell->taskName = taskName;
 8007d80:	6025      	str	r5, [r4, #0]
    xTaskCreate(shellStartThread, taskName, 256, activeShell, 2, NULL);
 8007d82:	4629      	mov	r1, r5
 8007d84:	e9cd 3200 	strd	r3, r2, [sp]
 8007d88:	4623      	mov	r3, r4
 8007d8a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d8e:	f7ff ffa7 	bl	8007ce0 <xTaskCreate.isra.0>

    return true;
 8007d92:	2001      	movs	r0, #1
}
 8007d94:	b003      	add	sp, #12
 8007d96:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007d98:	2000085c 	.word	0x2000085c
 8007d9c:	08009be5 	.word	0x08009be5

08007da0 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8007da0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8007da4:	4c62      	ldr	r4, [pc, #392]	; (8007f30 <VectorDC+0x190>)
 8007da6:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
  uint16_t cr1 = u->CR1;
 8007daa:	68f7      	ldr	r7, [r6, #12]
  uint16_t sr = u->SR;
 8007dac:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 8007dae:	05da      	lsls	r2, r3, #23
  uint16_t sr = u->SR;
 8007db0:	b29d      	uxth	r5, r3
  if (sr & USART_SR_LBD) {
 8007db2:	d50b      	bpl.n	8007dcc <VectorDC+0x2c>
    osalSysLockFromISR();
 8007db4:	f7fd fd3c 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8007db8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007dbc:	1d20      	adds	r0, r4, #4
 8007dbe:	f7ff f889 	bl	8006ed4 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8007dc2:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8007dc6:	6033      	str	r3, [r6, #0]
    osalSysUnlockFromISR();
 8007dc8:	f7fd fd46 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
  osalSysLockFromISR();
 8007dcc:	f7fd fd30 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
  chnAddFlagsI(sdp, sts);
 8007dd0:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8007f34 <VectorDC+0x194>
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007dd4:	f108 0914 	add.w	r9, r8, #20
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8007dd8:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 8007ddc:	d124      	bne.n	8007e28 <VectorDC+0x88>
  osalSysUnlockFromISR();
 8007dde:	f7fd fd3b 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8007de2:	0639      	lsls	r1, r7, #24
 8007de4:	d57b      	bpl.n	8007ede <VectorDC+0x13e>
 8007de6:	062a      	lsls	r2, r5, #24
 8007de8:	d579      	bpl.n	8007ede <VectorDC+0x13e>
    osalSysLockFromISR();
 8007dea:	f7fd fd21 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007dee:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007df2:	2b00      	cmp	r3, #0
 8007df4:	f000 8097 	beq.w	8007f26 <VectorDC+0x186>
  if (oqIsEmptyI(oqp)) {
 8007df8:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8007dfc:	429a      	cmp	r2, r3
 8007dfe:	d102      	bne.n	8007e06 <VectorDC+0x66>
 8007e00:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007e02:	2a00      	cmp	r2, #0
 8007e04:	d15f      	bne.n	8007ec6 <VectorDC+0x126>
  oqp->q_counter++;
 8007e06:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007e08:	3201      	adds	r2, #1
 8007e0a:	6462      	str	r2, [r4, #68]	; 0x44
  b = *oqp->q_rdptr++;
 8007e0c:	1c5a      	adds	r2, r3, #1
 8007e0e:	6562      	str	r2, [r4, #84]	; 0x54
 8007e10:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 8007e14:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8007e16:	429a      	cmp	r2, r3
 8007e18:	f080 8082 	bcs.w	8007f20 <VectorDC+0x180>
  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8007e1c:	4846      	ldr	r0, [pc, #280]	; (8007f38 <VectorDC+0x198>)
 8007e1e:	f7ff f835 	bl	8006e8c <osalThreadDequeueNextI.constprop.0>
      u->DR = b;
 8007e22:	f8c6 8004 	str.w	r8, [r6, #4]
 8007e26:	e058      	b.n	8007eda <VectorDC+0x13a>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8007e28:	072b      	lsls	r3, r5, #28
 8007e2a:	d013      	beq.n	8007e54 <VectorDC+0xb4>
    sts |= SD_OVERRUN_ERROR;
 8007e2c:	f015 0f08 	tst.w	r5, #8
 8007e30:	bf0c      	ite	eq
 8007e32:	2100      	moveq	r1, #0
 8007e34:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8007e36:	07e8      	lsls	r0, r5, #31
    sts |= SD_PARITY_ERROR;
 8007e38:	bf48      	it	mi
 8007e3a:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8007e3e:	07aa      	lsls	r2, r5, #30
    sts |= SD_FRAMING_ERROR;
 8007e40:	bf48      	it	mi
 8007e42:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8007e46:	076b      	lsls	r3, r5, #29
  chnAddFlagsI(sdp, sts);
 8007e48:	4640      	mov	r0, r8
    sts |= SD_NOISE_ERROR;
 8007e4a:	bf48      	it	mi
 8007e4c:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
  chnAddFlagsI(sdp, sts);
 8007e50:	f7ff f840 	bl	8006ed4 <osalEventBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 8007e54:	06a8      	lsls	r0, r5, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 8007e56:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 8007e5a:	d51b      	bpl.n	8007e94 <VectorDC+0xf4>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007e5c:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007e60:	b913      	cbnz	r3, 8007e68 <VectorDC+0xc8>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8007e62:	f7fc fda7 	bl	80049b4 <vTaskEndScheduler>
 8007e66:	e7fe      	b.n	8007e66 <VectorDC+0xc6>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8007e68:	6a23      	ldr	r3, [r4, #32]
    b = (uint8_t)u->DR & sdp->rxmask;
 8007e6a:	f894 5084 	ldrb.w	r5, [r4, #132]	; 0x84
 8007e6e:	b91b      	cbnz	r3, 8007e78 <VectorDC+0xd8>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8007e70:	2104      	movs	r1, #4
 8007e72:	4640      	mov	r0, r8
 8007e74:	f7ff f82e 	bl	8006ed4 <osalEventBroadcastFlagsI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 8007e78:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 8007e7c:	b303      	cbz	r3, 8007ec0 <VectorDC+0x120>
  if (iqIsFullI(iqp)) {
 8007e7e:	e9d4 320b 	ldrd	r3, r2, [r4, #44]	; 0x2c
 8007e82:	4293      	cmp	r3, r2
 8007e84:	d109      	bne.n	8007e9a <VectorDC+0xfa>
 8007e86:	6a22      	ldr	r2, [r4, #32]
 8007e88:	b13a      	cbz	r2, 8007e9a <VectorDC+0xfa>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
 8007e8a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8007e8e:	4640      	mov	r0, r8
 8007e90:	f7ff f820 	bl	8006ed4 <osalEventBroadcastFlagsI>
    sr = u->SR;
 8007e94:	6835      	ldr	r5, [r6, #0]
 8007e96:	b2ad      	uxth	r5, r5
 8007e98:	e79e      	b.n	8007dd8 <VectorDC+0x38>
  iqp->q_counter++;
 8007e9a:	6a22      	ldr	r2, [r4, #32]
    b = (uint8_t)u->DR & sdp->rxmask;
 8007e9c:	ea05 050a 	and.w	r5, r5, sl
 8007ea0:	3201      	adds	r2, #1
 8007ea2:	6222      	str	r2, [r4, #32]
  *iqp->q_wrptr++ = b;
 8007ea4:	1c5a      	adds	r2, r3, #1
 8007ea6:	62e2      	str	r2, [r4, #44]	; 0x2c
 8007ea8:	701d      	strb	r5, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8007eaa:	e9d4 320a 	ldrd	r3, r2, [r4, #40]	; 0x28
 8007eae:	429a      	cmp	r2, r3
    iqp->q_wrptr = iqp->q_buffer;
 8007eb0:	bf28      	it	cs
 8007eb2:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007eb4:	4648      	mov	r0, r9
    iqp->q_wrptr = iqp->q_buffer;
 8007eb6:	bf28      	it	cs
 8007eb8:	62e3      	strcs	r3, [r4, #44]	; 0x2c
  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8007eba:	f7fe ffe7 	bl	8006e8c <osalThreadDequeueNextI.constprop.0>
 8007ebe:	e7e9      	b.n	8007e94 <VectorDC+0xf4>
  osalDbgCheckClassI();
 8007ec0:	f7fc fd78 	bl	80049b4 <vTaskEndScheduler>
 8007ec4:	e7fe      	b.n	8007ec4 <VectorDC+0x124>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8007ec6:	2108      	movs	r1, #8
 8007ec8:	481a      	ldr	r0, [pc, #104]	; (8007f34 <VectorDC+0x194>)
 8007eca:	f7ff f803 	bl	8006ed4 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8007ece:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8007ed2:	403b      	ands	r3, r7
 8007ed4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007ed8:	60f3      	str	r3, [r6, #12]
    osalSysUnlockFromISR();
 8007eda:	f7fd fcbd 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
  if (sr & USART_SR_TC) {
 8007ede:	066b      	lsls	r3, r5, #25
 8007ee0:	d515      	bpl.n	8007f0e <VectorDC+0x16e>
    osalSysLockFromISR();
 8007ee2:	f7fd fca5 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
    if (oqIsEmptyI(&sdp->oqueue))
 8007ee6:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
 8007eea:	429a      	cmp	r2, r3
 8007eec:	d105      	bne.n	8007efa <VectorDC+0x15a>
 8007eee:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007ef0:	b11b      	cbz	r3, 8007efa <VectorDC+0x15a>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8007ef2:	2110      	movs	r1, #16
 8007ef4:	480f      	ldr	r0, [pc, #60]	; (8007f34 <VectorDC+0x194>)
 8007ef6:	f7fe ffed 	bl	8006ed4 <osalEventBroadcastFlagsI>
    u->SR = ~USART_SR_TC;
 8007efa:	f06f 0340 	mvn.w	r3, #64	; 0x40
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8007efe:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 8007f02:	043f      	lsls	r7, r7, #16
 8007f04:	0c3f      	lsrs	r7, r7, #16
 8007f06:	60f7      	str	r7, [r6, #12]
    u->SR = ~USART_SR_TC;
 8007f08:	6033      	str	r3, [r6, #0]
    osalSysUnlockFromISR();
 8007f0a:	f7fd fca5 	bl	8005858 <osalSysUnlockFromISR.lto_priv.0>
 8007f0e:	2100      	movs	r1, #0
    UBaseType_t isIt = xYieldPending;
 8007f10:	4b0a      	ldr	r3, [pc, #40]	; (8007f3c <VectorDC+0x19c>)
 8007f12:	681a      	ldr	r2, [r3, #0]
    xYieldPending = pdFALSE;
 8007f14:	6019      	str	r1, [r3, #0]

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8007f16:	b14a      	cbz	r2, 8007f2c <VectorDC+0x18c>
}
 8007f18:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007f1c:	f7fb bf2e 	b.w	8003d7c <Vector6C.part.0>
    oqp->q_rdptr = oqp->q_buffer;
 8007f20:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007f22:	6563      	str	r3, [r4, #84]	; 0x54
 8007f24:	e77a      	b.n	8007e1c <VectorDC+0x7c>
  osalDbgCheckClassI();
 8007f26:	f7fc fd45 	bl	80049b4 <vTaskEndScheduler>
 8007f2a:	e7fe      	b.n	8007f2a <VectorDC+0x18a>
 8007f2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007f30:	200009bc 	.word	0x200009bc
 8007f34:	200009c0 	.word	0x200009c0
 8007f38:	200009f8 	.word	0x200009f8
 8007f3c:	2000164c 	.word	0x2000164c

08007f40 <sanityRebootMonitorTask>:
{
 8007f40:	b508      	push	{r3, lr}
    uint32_t numberOfSeconds = sanityRebootSeconds;
 8007f42:	4b14      	ldr	r3, [pc, #80]	; (8007f94 <sanityRebootMonitorTask+0x54>)
 8007f44:	6819      	ldr	r1, [r3, #0]
    if(numberOfSeconds &&
 8007f46:	b199      	cbz	r1, 8007f70 <sanityRebootMonitorTask+0x30>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8007f48:	f7fd ffe0 	bl	8005f0c <vPortValidateInterruptPriority>
            osalOsGetSystemTimeX() >= OSAL_S2ST(numberOfSeconds)) {
 8007f4c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		xReturn = xTickCount;
 8007f50:	4b11      	ldr	r3, [pc, #68]	; (8007f98 <sanityRebootMonitorTask+0x58>)
 8007f52:	4351      	muls	r1, r2
 8007f54:	681b      	ldr	r3, [r3, #0]
    if(numberOfSeconds &&
 8007f56:	4299      	cmp	r1, r3
 8007f58:	d80a      	bhi.n	8007f70 <sanityRebootMonitorTask+0x30>
        RCC->APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8007f5a:	4a10      	ldr	r2, [pc, #64]	; (8007f9c <sanityRebootMonitorTask+0x5c>)
 8007f5c:	69d3      	ldr	r3, [r2, #28]
 8007f5e:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8007f62:	61d3      	str	r3, [r2, #28]
        BKP->DR10 = 0x424D;
 8007f64:	f244 224d 	movw	r2, #16973	; 0x424d
 8007f68:	4b0d      	ldr	r3, [pc, #52]	; (8007fa0 <sanityRebootMonitorTask+0x60>)
 8007f6a:	629a      	str	r2, [r3, #40]	; 0x28
        NVIC_SystemReset();
 8007f6c:	f7fc f960 	bl	8004230 <NVIC_SystemReset.lto_priv.0>
 */
void wdgReset(WDGDriver *wdgp) {

  osalDbgCheck(wdgp != NULL);

  osalSysLock();
 8007f70:	f7fc fd10 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 8007f74:	4b0b      	ldr	r3, [pc, #44]	; (8007fa4 <sanityRebootMonitorTask+0x64>)
 8007f76:	781a      	ldrb	r2, [r3, #0]
 8007f78:	2a02      	cmp	r2, #2
 8007f7a:	d002      	beq.n	8007f82 <sanityRebootMonitorTask+0x42>
 8007f7c:	f7fc fd1a 	bl	80049b4 <vTaskEndScheduler>
 8007f80:	e7fe      	b.n	8007f80 <sanityRebootMonitorTask+0x40>
 *
 * @notapi
 */
void wdg_lld_reset(WDGDriver * wdgp) {

  wdgp->wdg->KR = KR_KEY_RELOAD;
 8007f82:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8007f86:	689b      	ldr	r3, [r3, #8]
}
 8007f88:	2001      	movs	r0, #1
 8007f8a:	601a      	str	r2, [r3, #0]
  wdgResetI(wdgp);
  osalSysUnlock();
 8007f8c:	f7fc ff26 	bl	8004ddc <osalSysUnlock.lto_priv.0>
 8007f90:	bd08      	pop	{r3, pc}
 8007f92:	bf00      	nop
 8007f94:	20000858 	.word	0x20000858
 8007f98:	20001648 	.word	0x20001648
 8007f9c:	40021000 	.word	0x40021000
 8007fa0:	40006c00 	.word	0x40006c00
 8007fa4:	20000fdc 	.word	0x20000fdc

08007fa8 <i2cSafeRawUnclogBus>:
{
 8007fa8:	b570      	push	{r4, r5, r6, lr}
 8007faa:	4605      	mov	r5, r0
    gpioSetPin(config->sclPin, level);
 8007fac:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8007fae:	2101      	movs	r1, #1
 8007fb0:	8998      	ldrh	r0, [r3, #12]
 8007fb2:	f7ff fabb 	bl	800752c <gpioSetPin.isra.0>
    gpioSetPin(config->sdaPin, level);
 8007fb6:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8007fb8:	2101      	movs	r1, #1
 8007fba:	89d8      	ldrh	r0, [r3, #14]
 8007fbc:	f7ff fab6 	bl	800752c <gpioSetPin.isra.0>
    i2cSafeConfig* config = (i2cSafeConfig*)i2c->i2cSafeConfig;
 8007fc0:	6fec      	ldr	r4, [r5, #124]	; 0x7c
    gpioSetPinMode(config->sdaPin, PAL_MODE_OUTPUT_OPENDRAIN);
 8007fc2:	2107      	movs	r1, #7
 8007fc4:	89e0      	ldrh	r0, [r4, #14]
 8007fc6:	f7ff f99d 	bl	8007304 <gpioSetPinMode.isra.0>
    gpioSetPinMode(config->sclPin, PAL_MODE_OUTPUT_OPENDRAIN);
 8007fca:	2107      	movs	r1, #7
 8007fcc:	89a0      	ldrh	r0, [r4, #12]
 8007fce:	f7ff f999 	bl	8007304 <gpioSetPinMode.isra.0>
  osalSysLock();
 8007fd2:	f7fc fcdf 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8007fd6:	782b      	ldrb	r3, [r5, #0]
 8007fd8:	1e5a      	subs	r2, r3, #1
 8007fda:	2a01      	cmp	r2, #1
 8007fdc:	d904      	bls.n	8007fe8 <i2cSafeRawUnclogBus+0x40>
 8007fde:	2b05      	cmp	r3, #5
 8007fe0:	d004      	beq.n	8007fec <i2cSafeRawUnclogBus+0x44>
 8007fe2:	f7fc fce7 	bl	80049b4 <vTaskEndScheduler>
 8007fe6:	e7fe      	b.n	8007fe6 <i2cSafeRawUnclogBus+0x3e>
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8007fe8:	2b01      	cmp	r3, #1
 8007fea:	d036      	beq.n	800805a <i2cSafeRawUnclogBus+0xb2>
  dp->CR1 = I2C_CR1_SWRST;
 8007fec:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  dp->CR1 = 0;
 8007ff0:	2400      	movs	r4, #0
  I2C_TypeDef *dp = i2cp->i2c;
 8007ff2:	6fab      	ldr	r3, [r5, #120]	; 0x78
  dmaStreamDisable(i2cp->dmatx);
 8007ff4:	6f68      	ldr	r0, [r5, #116]	; 0x74
  dp->CR1 = I2C_CR1_SWRST;
 8007ff6:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmatx);
 8007ff8:	6842      	ldr	r2, [r0, #4]
  dp->CR1 = 0;
 8007ffa:	601c      	str	r4, [r3, #0]
  dp->CR2 = 0;
 8007ffc:	605c      	str	r4, [r3, #4]
  dp->SR1 = 0;
 8007ffe:	615c      	str	r4, [r3, #20]
  dmaStreamDisable(i2cp->dmatx);
 8008000:	6813      	ldr	r3, [r2, #0]
 8008002:	6801      	ldr	r1, [r0, #0]
 8008004:	f023 030f 	bic.w	r3, r3, #15
 8008008:	6013      	str	r3, [r2, #0]
 800800a:	230e      	movs	r3, #14
 800800c:	7c02      	ldrb	r2, [r0, #16]
 800800e:	fa03 f202 	lsl.w	r2, r3, r2
 8008012:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(i2cp->dmarx);
 8008014:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8008016:	6856      	ldr	r6, [r2, #4]
 8008018:	6831      	ldr	r1, [r6, #0]
 800801a:	f021 010f 	bic.w	r1, r1, #15
 800801e:	6031      	str	r1, [r6, #0]
 8008020:	6811      	ldr	r1, [r2, #0]
 8008022:	7c12      	ldrb	r2, [r2, #16]
 8008024:	4093      	lsls	r3, r2
 8008026:	604b      	str	r3, [r1, #4]

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 8008028:	f7fc fdec 	bl	8004c04 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 800802c:	6f28      	ldr	r0, [r5, #112]	; 0x70
 800802e:	f7fc fde9 	bl	8004c04 <dmaStreamRelease>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 8008032:	4b3a      	ldr	r3, [pc, #232]	; (800811c <i2cSafeRawUnclogBus+0x174>)
 8008034:	429d      	cmp	r5, r3
 8008036:	d110      	bne.n	800805a <i2cSafeRawUnclogBus+0xb2>
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8008038:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800803c:	4b38      	ldr	r3, [pc, #224]	; (8008120 <i2cSafeRawUnclogBus+0x178>)
 800803e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8008042:	2201      	movs	r2, #1
  NVIC->IP[n] = 0U;
 8008044:	f883 431f 	strb.w	r4, [r3, #799]	; 0x31f
  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8008048:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      nvicDisableVector(I2C1_EV_IRQn);
      nvicDisableVector(I2C1_ER_IRQn);
      rccDisableI2C1(FALSE);
 800804c:	4a35      	ldr	r2, [pc, #212]	; (8008124 <i2cSafeRawUnclogBus+0x17c>)
  NVIC->IP[n] = 0U;
 800804e:	f883 4320 	strb.w	r4, [r3, #800]	; 0x320
 8008052:	69d3      	ldr	r3, [r2, #28]
 8008054:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8008058:	61d3      	str	r3, [r2, #28]
  i2cp->config = NULL;
 800805a:	2300      	movs	r3, #0
 800805c:	606b      	str	r3, [r5, #4]
  i2cp->state  = I2C_STOP;
 800805e:	2301      	movs	r3, #1
    vPortBusyDelay(i2cSafe_CYCLE_DELAY);
 8008060:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8008064:	702b      	strb	r3, [r5, #0]
  osalSysUnlock();
 8008066:	f7fc feb9 	bl	8004ddc <osalSysUnlock.lto_priv.0>
 800806a:	f7fd ff6d 	bl	8005f48 <vPortBusyDelay>
    i2cSafeDataGoHigh(i2c);
 800806e:	4628      	mov	r0, r5
 8008070:	f7ff fb9e 	bl	80077b0 <i2cSafeDataGoHigh>
 8008074:	2648      	movs	r6, #72	; 0x48
        if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008076:	4628      	mov	r0, r5
 8008078:	f7ff fb6a 	bl	8007750 <i2cSafeClockGoHigh>
 800807c:	4604      	mov	r4, r0
 800807e:	2800      	cmp	r0, #0
 8008080:	d142      	bne.n	8008108 <i2cSafeRawUnclogBus+0x160>
        if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;
 8008082:	4628      	mov	r0, r5
 8008084:	f7ff fb80 	bl	8007788 <i2cSafeClockGoLow>
 8008088:	4604      	mov	r4, r0
 800808a:	2800      	cmp	r0, #0
 800808c:	d13c      	bne.n	8008108 <i2cSafeRawUnclogBus+0x160>
    for(i=0; i<clocks; i++) {
 800808e:	3e01      	subs	r6, #1
 8008090:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8008094:	d1ef      	bne.n	8008076 <i2cSafeRawUnclogBus+0xce>
    if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008096:	4628      	mov	r0, r5
 8008098:	f7ff fb5a 	bl	8007750 <i2cSafeClockGoHigh>
 800809c:	4604      	mov	r4, r0
 800809e:	bb98      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    return gpioGetPin(config->sdaPin);
 80080a0:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 80080a2:	89d8      	ldrh	r0, [r3, #14]
 80080a4:	f7fc f996 	bl	80043d4 <gpioGetPin>
    if(!i2cSafeRawGetData(i2c)){
 80080a8:	b398      	cbz	r0, 8008112 <i2cSafeRawUnclogBus+0x16a>
    if((retVal = i2cSafeDataGoLow(i2c)) != I2C_BUS_OK) goto done;        
 80080aa:	4628      	mov	r0, r5
 80080ac:	f7ff fb94 	bl	80077d8 <i2cSafeDataGoLow>
 80080b0:	4604      	mov	r4, r0
 80080b2:	bb48      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;        
 80080b4:	4628      	mov	r0, r5
 80080b6:	f7ff fb67 	bl	8007788 <i2cSafeClockGoLow>
 80080ba:	4604      	mov	r4, r0
 80080bc:	bb20      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    i2cSafeDataGoHigh(i2c);
 80080be:	4628      	mov	r0, r5
 80080c0:	f7ff fb76 	bl	80077b0 <i2cSafeDataGoHigh>
 80080c4:	2609      	movs	r6, #9
        if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 80080c6:	4628      	mov	r0, r5
 80080c8:	f7ff fb42 	bl	8007750 <i2cSafeClockGoHigh>
 80080cc:	4604      	mov	r4, r0
 80080ce:	b9d8      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
        if((retVal = i2cSafeClockGoLow(i2c)) != I2C_BUS_OK) goto done;
 80080d0:	4628      	mov	r0, r5
 80080d2:	f7ff fb59 	bl	8007788 <i2cSafeClockGoLow>
 80080d6:	4604      	mov	r4, r0
 80080d8:	b9b0      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    return gpioGetPin(config->sdaPin);
 80080da:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 80080dc:	89d8      	ldrh	r0, [r3, #14]
 80080de:	f7fc f979 	bl	80043d4 <gpioGetPin>
        if(checkData && !i2cSafeRawGetData(i2c)){
 80080e2:	b1c0      	cbz	r0, 8008116 <i2cSafeRawUnclogBus+0x16e>
    for(i=0; i<clocks; i++) {
 80080e4:	3e01      	subs	r6, #1
 80080e6:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 80080ea:	d1ec      	bne.n	80080c6 <i2cSafeRawUnclogBus+0x11e>
    if((retVal = i2cSafeDataGoLow(i2c)) != I2C_BUS_OK) goto done;        
 80080ec:	4628      	mov	r0, r5
 80080ee:	f7ff fb73 	bl	80077d8 <i2cSafeDataGoLow>
 80080f2:	4604      	mov	r4, r0
 80080f4:	b940      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeClockGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 80080f6:	4628      	mov	r0, r5
 80080f8:	f7ff fb2a 	bl	8007750 <i2cSafeClockGoHigh>
 80080fc:	4604      	mov	r4, r0
 80080fe:	b918      	cbnz	r0, 8008108 <i2cSafeRawUnclogBus+0x160>
    if((retVal = i2cSafeDataGoHigh(i2c)) != I2C_BUS_OK) goto done;        
 8008100:	4628      	mov	r0, r5
 8008102:	f7ff fb55 	bl	80077b0 <i2cSafeDataGoHigh>
 8008106:	4604      	mov	r4, r0
    i2cSafeRawHardwareControl(i2c);
 8008108:	4628      	mov	r0, r5
 800810a:	f7ff f907 	bl	800731c <i2cSafeRawHardwareControl>
}
 800810e:	4620      	mov	r0, r4
 8008110:	bd70      	pop	{r4, r5, r6, pc}
        retVal = I2C_BUS_STUCK_SDA_PULLED_LOW;
 8008112:	2402      	movs	r4, #2
 8008114:	e7f8      	b.n	8008108 <i2cSafeRawUnclogBus+0x160>
            return I2C_BUS_STUCK_SHORTED_TOGETHER;
 8008116:	2405      	movs	r4, #5
 8008118:	e7f6      	b.n	8008108 <i2cSafeRawUnclogBus+0x160>
 800811a:	bf00      	nop
 800811c:	20000934 	.word	0x20000934
 8008120:	e000e100 	.word	0xe000e100
 8008124:	40021000 	.word	0x40021000

08008128 <max2870SpiState.constprop.0>:
static void max2870SetMUXOut(MAX2870Driver* driver, uint8_t muxOut);

static void max2870SpiState(MAX2870Driver* driver, bool enable)
{
    if(enable) {
        spiAcquireBus(driver->config->spiPort);
 8008128:	6803      	ldr	r3, [r0, #0]
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 800812a:	b510      	push	{r4, lr}
        spiAcquireBus(driver->config->spiPort);
 800812c:	681b      	ldr	r3, [r3, #0]
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 800812e:	4604      	mov	r4, r0
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 8008130:	b913      	cbnz	r3, 8008138 <max2870SpiState.constprop.0+0x10>
 8008132:	f7fc fc3f 	bl	80049b4 <vTaskEndScheduler>
 8008136:	e7fe      	b.n	8008136 <max2870SpiState.constprop.0+0xe>
    xSemaphoreTake(mutex->handle, portMAX_DELAY);
 8008138:	68d8      	ldr	r0, [r3, #12]
 800813a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800813e:	f7fd f97b 	bl	8005438 <xQueueSemaphoreTake>
        spiStart(driver->config->spiPort, driver->config->spiConfig);
 8008142:	6823      	ldr	r3, [r4, #0]
 8008144:	681c      	ldr	r4, [r3, #0]
  osalDbgCheck((spip != NULL) && (config != NULL));
 8008146:	b10c      	cbz	r4, 800814c <max2870SpiState.constprop.0+0x24>
 8008148:	6858      	ldr	r0, [r3, #4]
 800814a:	b910      	cbnz	r0, 8008152 <max2870SpiState.constprop.0+0x2a>
 800814c:	f7fc fc32 	bl	80049b4 <vTaskEndScheduler>
 8008150:	e7fe      	b.n	8008150 <max2870SpiState.constprop.0+0x28>
  osalSysLock();
 8008152:	f7fc fc1f 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8008156:	7823      	ldrb	r3, [r4, #0]
 8008158:	1e5a      	subs	r2, r3, #1
 800815a:	2a01      	cmp	r2, #1
 800815c:	d902      	bls.n	8008164 <max2870SpiState.constprop.0+0x3c>
 800815e:	f7fc fc29 	bl	80049b4 <vTaskEndScheduler>
 8008162:	e7fe      	b.n	8008162 <max2870SpiState.constprop.0+0x3a>
  if (spip->state == SPI_STOP) {
 8008164:	2b01      	cmp	r3, #1
  spip->config = config;
 8008166:	6060      	str	r0, [r4, #4]
 8008168:	d121      	bne.n	80081ae <max2870SpiState.constprop.0+0x86>
    if (&SPID1 == spip) {
 800816a:	4b25      	ldr	r3, [pc, #148]	; (8008200 <max2870SpiState.constprop.0+0xd8>)
 800816c:	429c      	cmp	r4, r3
 800816e:	d116      	bne.n	800819e <max2870SpiState.constprop.0+0x76>
      b = dmaStreamAllocate(spip->dmarx,
 8008170:	4622      	mov	r2, r4
 8008172:	4924      	ldr	r1, [pc, #144]	; (8008204 <max2870SpiState.constprop.0+0xdc>)
 8008174:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8008176:	f7fe f961 	bl	800643c <dmaStreamAllocate.constprop.0>
      osalDbgAssert(!b, "stream already allocated");
 800817a:	b110      	cbz	r0, 8008182 <max2870SpiState.constprop.0+0x5a>
 800817c:	f7fc fc1a 	bl	80049b4 <vTaskEndScheduler>
 8008180:	e7fe      	b.n	8008180 <max2870SpiState.constprop.0+0x58>
      b = dmaStreamAllocate(spip->dmatx,
 8008182:	4622      	mov	r2, r4
 8008184:	4920      	ldr	r1, [pc, #128]	; (8008208 <max2870SpiState.constprop.0+0xe0>)
 8008186:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8008188:	f7fe f958 	bl	800643c <dmaStreamAllocate.constprop.0>
      osalDbgAssert(!b, "stream already allocated");
 800818c:	b110      	cbz	r0, 8008194 <max2870SpiState.constprop.0+0x6c>
 800818e:	f7fc fc11 	bl	80049b4 <vTaskEndScheduler>
 8008192:	e7fe      	b.n	8008192 <max2870SpiState.constprop.0+0x6a>
      rccEnableSPI1(FALSE);
 8008194:	4a1d      	ldr	r2, [pc, #116]	; (800820c <max2870SpiState.constprop.0+0xe4>)
 8008196:	6993      	ldr	r3, [r2, #24]
 8008198:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800819c:	6193      	str	r3, [r2, #24]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800819e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80081a0:	685a      	ldr	r2, [r3, #4]
 80081a2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80081a4:	330c      	adds	r3, #12
 80081a6:	6093      	str	r3, [r2, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 80081a8:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80081aa:	6852      	ldr	r2, [r2, #4]
 80081ac:	6093      	str	r3, [r2, #8]
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80081ae:	6860      	ldr	r0, [r4, #4]
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80081b0:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80081b2:	8941      	ldrh	r1, [r0, #10]
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80081b4:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 80081b8:	f411 6f00 	tst.w	r1, #2048	; 0x800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80081bc:	bf16      	itet	ne
 80081be:	f442 62a0 	orrne.w	r2, r2, #1280	; 0x500
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80081c2:	66e2      	streq	r2, [r4, #108]	; 0x6c
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80081c4:	66e2      	strne	r2, [r4, #108]	; 0x6c
  spip->spi->CR1  = 0;
 80081c6:	f04f 0200 	mov.w	r2, #0
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80081ca:	6f23      	ldr	r3, [r4, #112]	; 0x70
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80081cc:	f441 7141 	orr.w	r1, r1, #772	; 0x304
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 80081d0:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 80081d4:	bf18      	it	ne
 80081d6:	f443 63a0 	orrne.w	r3, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 80081da:	6723      	str	r3, [r4, #112]	; 0x70
  spip->spi->CR1  = 0;
 80081dc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80081de:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80081e0:	8982      	ldrh	r2, [r0, #12]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 80081e2:	6019      	str	r1, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 80081e4:	f042 0207 	orr.w	r2, r2, #7
 80081e8:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 80081ea:	681a      	ldr	r2, [r3, #0]
 80081ec:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80081f0:	601a      	str	r2, [r3, #0]
  spip->state = SPI_READY;
 80081f2:	2302      	movs	r3, #2
 80081f4:	7023      	strb	r3, [r4, #0]
        /* Update monitor state */
        monitorKick(&driver->pllMon, driver->enabled);

        spiReleaseBus(driver->config->spiPort);
    }
}
 80081f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlock();
 80081fa:	f7fc bdef 	b.w	8004ddc <osalSysUnlock.lto_priv.0>
 80081fe:	bf00      	nop
 8008200:	20000ee0 	.word	0x20000ee0
 8008204:	0800728d 	.word	0x0800728d
 8008208:	08004ca7 	.word	0x08004ca7
 800820c:	40021000 	.word	0x40021000

08008210 <spiUnselect.constprop.0>:
void spiUnselect(SPIDriver *spip) {
 8008210:	b508      	push	{r3, lr}
  osalSysLock();
 8008212:	f7fc fbbf 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8008216:	4b08      	ldr	r3, [pc, #32]	; (8008238 <spiUnselect.constprop.0+0x28>)
 8008218:	781a      	ldrb	r2, [r3, #0]
 800821a:	2a02      	cmp	r2, #2
 800821c:	d002      	beq.n	8008224 <spiUnselect.constprop.0+0x14>
 800821e:	f7fc fbc9 	bl	80049b4 <vTaskEndScheduler>
 8008222:	e7fe      	b.n	8008222 <spiUnselect.constprop.0+0x12>
  palSetPad(spip->config->ssport, spip->config->sspad);
 8008224:	685b      	ldr	r3, [r3, #4]
 8008226:	8919      	ldrh	r1, [r3, #8]
 8008228:	685a      	ldr	r2, [r3, #4]
 800822a:	2301      	movs	r3, #1
 800822c:	408b      	lsls	r3, r1
 800822e:	6113      	str	r3, [r2, #16]
}
 8008230:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osalSysUnlock();
 8008234:	f7fc bdd2 	b.w	8004ddc <osalSysUnlock.lto_priv.0>
 8008238:	20000ee0 	.word	0x20000ee0

0800823c <spiSelect.constprop.0>:
void spiSelect(SPIDriver *spip) {
 800823c:	b508      	push	{r3, lr}
  osalSysLock();
 800823e:	f7fc fba9 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8008242:	4b08      	ldr	r3, [pc, #32]	; (8008264 <spiSelect.constprop.0+0x28>)
 8008244:	781a      	ldrb	r2, [r3, #0]
 8008246:	2a02      	cmp	r2, #2
 8008248:	d002      	beq.n	8008250 <spiSelect.constprop.0+0x14>
 800824a:	f7fc fbb3 	bl	80049b4 <vTaskEndScheduler>
 800824e:	e7fe      	b.n	800824e <spiSelect.constprop.0+0x12>
  palClearPad(spip->config->ssport, spip->config->sspad);
 8008250:	685b      	ldr	r3, [r3, #4]
 8008252:	8919      	ldrh	r1, [r3, #8]
 8008254:	685a      	ldr	r2, [r3, #4]
 8008256:	2301      	movs	r3, #1
 8008258:	408b      	lsls	r3, r1
 800825a:	6153      	str	r3, [r2, #20]
}
 800825c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osalSysUnlock();
 8008260:	f7fc bdbc 	b.w	8004ddc <osalSysUnlock.lto_priv.0>
 8008264:	20000ee0 	.word	0x20000ee0

08008268 <spiSend.part.0.constprop.0>:
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8008268:	b510      	push	{r4, lr}
  osalSysLock();
 800826a:	f7fc fb93 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800826e:	4b18      	ldr	r3, [pc, #96]	; (80082d0 <spiSend.part.0.constprop.0+0x68>)
 8008270:	781a      	ldrb	r2, [r3, #0]
 8008272:	2a02      	cmp	r2, #2
 8008274:	d002      	beq.n	800827c <spiSend.part.0.constprop.0+0x14>
 8008276:	f7fc fb9d 	bl	80049b4 <vTaskEndScheduler>
 800827a:	e7fe      	b.n	800827a <spiSend.part.0.constprop.0+0x12>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 800827c:	685a      	ldr	r2, [r3, #4]
 800827e:	6812      	ldr	r2, [r2, #0]
 8008280:	b112      	cbz	r2, 8008288 <spiSend.part.0.constprop.0+0x20>
 8008282:	f7fc fb97 	bl	80049b4 <vTaskEndScheduler>
 8008286:	e7fe      	b.n	8008286 <spiSend.part.0.constprop.0+0x1e>
  spiStartSendI(spip, n, txbuf);
 8008288:	2203      	movs	r2, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800828a:	2404      	movs	r4, #4
 800828c:	701a      	strb	r2, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800828e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8008290:	6851      	ldr	r1, [r2, #4]
 8008292:	4a10      	ldr	r2, [pc, #64]	; (80082d4 <spiSend.part.0.constprop.0+0x6c>)
 8008294:	60ca      	str	r2, [r1, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 8008296:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8008298:	604c      	str	r4, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800829a:	600a      	str	r2, [r1, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800829c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800829e:	6852      	ldr	r2, [r2, #4]
 80082a0:	60d0      	str	r0, [r2, #12]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80082a2:	6f18      	ldr	r0, [r3, #112]	; 0x70
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80082a4:	6054      	str	r4, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80082a6:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80082aa:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(spip->dmarx);
 80082ac:	6808      	ldr	r0, [r1, #0]
 80082ae:	f040 0001 	orr.w	r0, r0, #1
 80082b2:	6008      	str	r0, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 80082b4:	6811      	ldr	r1, [r2, #0]
    return osalThreadSuspendTimeoutS(thread_reference, portMAX_DELAY);
 80082b6:	f103 0008 	add.w	r0, r3, #8
 80082ba:	f041 0101 	orr.w	r1, r1, #1
 80082be:	6011      	str	r1, [r2, #0]
 80082c0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80082c4:	f7fe f97a 	bl	80065bc <osalThreadSuspendTimeoutS>
}
 80082c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  osalSysUnlock();
 80082cc:	f7fc bd86 	b.w	8004ddc <osalSysUnlock.lto_priv.0>
 80082d0:	20000ee0 	.word	0x20000ee0
 80082d4:	20001048 	.word	0x20001048

080082d8 <max2870WriteRegister>:

static bool max2870WriteRegister(MAX2870Driver* driver, const uint32_t addr, uint32_t value, bool force)
{
 80082d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80082da:	4604      	mov	r4, r0
 80082dc:	4618      	mov	r0, r3
    osalDbgCheck(addr < 0x6);
    osalDbgCheck((value & 0x7) == 0);
 80082de:	0753      	lsls	r3, r2, #29
 80082e0:	d002      	beq.n	80082e8 <max2870WriteRegister+0x10>
 80082e2:	f7fc fb67 	bl	80049b4 <vTaskEndScheduler>
 80082e6:	e7fe      	b.n	80082e6 <max2870WriteRegister+0xe>

    if(!force && driver->registers[addr] == value) {
 80082e8:	f101 0332 	add.w	r3, r1, #50	; 0x32
 80082ec:	b918      	cbnz	r0, 80082f6 <max2870WriteRegister+0x1e>
 80082ee:	f854 5023 	ldr.w	r5, [r4, r3, lsl #2]
 80082f2:	42aa      	cmp	r2, r5
 80082f4:	d018      	beq.n	8008328 <max2870WriteRegister+0x50>
        return false;
    }
    driver->registers[addr] = value;
 80082f6:	f844 2023 	str.w	r2, [r4, r3, lsl #2]

    value |= addr;
 80082fa:	430a      	orrs	r2, r1

    uint8_t data[4] = {value>>24, (value >> 16) & 0xFF, (value >> 8) & 0xFF,  (value >> 0) & 0xFF};
 80082fc:	0e13      	lsrs	r3, r2, #24
 80082fe:	f88d 3004 	strb.w	r3, [sp, #4]
 8008302:	0c13      	lsrs	r3, r2, #16
 8008304:	f88d 3005 	strb.w	r3, [sp, #5]
 8008308:	a801      	add	r0, sp, #4
 800830a:	0a13      	lsrs	r3, r2, #8
 800830c:	f88d 3006 	strb.w	r3, [sp, #6]
 8008310:	f88d 2007 	strb.w	r2, [sp, #7]


    spiSelect(&SPID1);
 8008314:	f7ff ff92 	bl	800823c <spiSelect.constprop.0>
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8008318:	f7ff ffa6 	bl	8008268 <spiSend.part.0.constprop.0>
    }
}

static inline void osalSysPolledDelayX(rtcnt_t cycles)
{
    vPortBusyDelay(cycles);
 800831c:	2032      	movs	r0, #50	; 0x32
    spiSend(&SPID1, 4, data);
    spiUnselect(&SPID1);
 800831e:	f7ff ff77 	bl	8008210 <spiUnselect.constprop.0>
 8008322:	f7fd fe11 	bl	8005f48 <vPortBusyDelay>
    osalSysPolledDelayX(50);


    return true;
 8008326:	2001      	movs	r0, #1
}
 8008328:	b003      	add	sp, #12
 800832a:	bd30      	pop	{r4, r5, pc}

0800832c <max2870SetMUXOut>:

    return true;
}

static void max2870SetMUXOut(MAX2870Driver* driver, uint8_t muxOut)
{
 800832c:	b570      	push	{r4, r5, r6, lr}
    uint32_t register2 = driver->registers[2] & ~ (0x7 <<  MAX2870_REG2_MUX_OFFSET);
 800832e:	f8d0 50d0 	ldr.w	r5, [r0, #208]	; 0xd0
    register2 |= (muxOut & 0x7) << MAX2870_REG2_MUX_OFFSET;
    uint32_t register5 = driver->registers[5] & ~ _BV(MAX2870_REG5_MUX_OFFSET);
 8008332:	f8d0 20dc 	ldr.w	r2, [r0, #220]	; 0xdc
    uint32_t register2 = driver->registers[2] & ~ (0x7 <<  MAX2870_REG2_MUX_OFFSET);
 8008336:	f025 53e0 	bic.w	r3, r5, #469762048	; 0x1c000000
    register2 |= (muxOut & 0x7) << MAX2870_REG2_MUX_OFFSET;
 800833a:	068d      	lsls	r5, r1, #26
 800833c:	f005 55e0 	and.w	r5, r5, #469762048	; 0x1c000000
 8008340:	431d      	orrs	r5, r3
    uint32_t register5 = driver->registers[5] & ~ _BV(MAX2870_REG5_MUX_OFFSET);
 8008342:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
    if(muxOut & 0x8) {
 8008346:	070b      	lsls	r3, r1, #28
        register5 |= _BV(MAX2870_REG5_MUX_OFFSET);
 8008348:	bf48      	it	mi
 800834a:	f442 2280 	orrmi.w	r2, r2, #262144	; 0x40000
    }

    /* It seems reg 5 should be written before reg 2 to update the MUX value */
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 800834e:	2300      	movs	r3, #0
 8008350:	2105      	movs	r1, #5
{
 8008352:	4604      	mov	r4, r0
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 8008354:	f7ff ffc0 	bl	80082d8 <max2870WriteRegister>
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 8008358:	462a      	mov	r2, r5
    bool mustUpdateOther = max2870WriteRegister(driver, 5, register5, false);
 800835a:	4603      	mov	r3, r0
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 800835c:	2102      	movs	r1, #2
 800835e:	4620      	mov	r0, r4
}
 8008360:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    max2870WriteRegister(driver, 2, register2, mustUpdateOther);
 8008364:	f7ff bfb8 	b.w	80082d8 <max2870WriteRegister>

08008368 <max2870ReadRegister6>:

static uint32_t max2870ReadRegister6(MAX2870Driver* driver)
{
 8008368:	b513      	push	{r0, r1, r4, lr}
    /* Step 1: Set MUX OUT to readback mode */
    max2870SetMUXOut(driver, 0xC);
 800836a:	210c      	movs	r1, #12
{
 800836c:	4604      	mov	r4, r0
    max2870SetMUXOut(driver, 0xC);
 800836e:	f7ff ffdd 	bl	800832c <max2870SetMUXOut>

    /* Step 2: Ask to read the register */
    uint8_t data[5]= {0, 0, 0, 0x6};
 8008372:	4b25      	ldr	r3, [pc, #148]	; (8008408 <max2870ReadRegister6+0xa0>)
 8008374:	6818      	ldr	r0, [r3, #0]
 8008376:	791b      	ldrb	r3, [r3, #4]
 8008378:	9000      	str	r0, [sp, #0]
 800837a:	4668      	mov	r0, sp
 800837c:	f88d 3004 	strb.w	r3, [sp, #4]
    spiSelect(&SPID1);
 8008380:	f7ff ff5c 	bl	800823c <spiSelect.constprop.0>
 8008384:	f7ff ff70 	bl	8008268 <spiSend.part.0.constprop.0>
    spiSend(&SPID1, 4, data);
    spiUnselect(&SPID1);
 8008388:	f7ff ff42 	bl	8008210 <spiUnselect.constprop.0>

    /* Step 3: Read in the data, note that the device should be unselected(!) */
    data[3] = 0;
 800838c:	2300      	movs	r3, #0
 800838e:	f88d 3003 	strb.w	r3, [sp, #3]
  osalSysLock();
 8008392:	f7fc faff 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8008396:	4b1d      	ldr	r3, [pc, #116]	; (800840c <max2870ReadRegister6+0xa4>)
 8008398:	781a      	ldrb	r2, [r3, #0]
 800839a:	2a02      	cmp	r2, #2
 800839c:	d002      	beq.n	80083a4 <max2870ReadRegister6+0x3c>
 800839e:	f7fc fb09 	bl	80049b4 <vTaskEndScheduler>
 80083a2:	e7fe      	b.n	80083a2 <max2870ReadRegister6+0x3a>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 80083a4:	685a      	ldr	r2, [r3, #4]
 80083a6:	6812      	ldr	r2, [r2, #0]
 80083a8:	b112      	cbz	r2, 80083b0 <max2870ReadRegister6+0x48>
 80083aa:	f7fc fb03 	bl	80049b4 <vTaskEndScheduler>
 80083ae:	e7fe      	b.n	80083ae <max2870ReadRegister6+0x46>
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 80083b0:	2203      	movs	r2, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80083b2:	2004      	movs	r0, #4
 80083b4:	701a      	strb	r2, [r3, #0]
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80083b6:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80083b8:	6851      	ldr	r1, [r2, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80083ba:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 80083bc:	f8c1 d00c 	str.w	sp, [r1, #12]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80083c0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  dmaStreamSetTransactionSize(spip->dmarx, n);
 80083c4:	6048      	str	r0, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 80083c6:	600a      	str	r2, [r1, #0]
  dmaStreamSetMemory0(spip->dmatx, txbuf);
 80083c8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80083ca:	6852      	ldr	r2, [r2, #4]
 80083cc:	f8c2 d00c 	str.w	sp, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 80083d0:	6050      	str	r0, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 80083d2:	6f18      	ldr	r0, [r3, #112]	; 0x70
 80083d4:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 80083d8:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(spip->dmarx);
 80083da:	6808      	ldr	r0, [r1, #0]
 80083dc:	f040 0001 	orr.w	r0, r0, #1
 80083e0:	6008      	str	r0, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 80083e2:	6811      	ldr	r1, [r2, #0]
 80083e4:	f103 0008 	add.w	r0, r3, #8
 80083e8:	f041 0101 	orr.w	r1, r1, #1
 80083ec:	6011      	str	r1, [r2, #0]
 80083ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80083f2:	f7fe f8e3 	bl	80065bc <osalThreadSuspendTimeoutS>
  osalSysUnlock();
 80083f6:	f7fc fcf1 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    spiExchange(&SPID1, 4, data, data);

    driver->registers[6] = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
 80083fa:	9800      	ldr	r0, [sp, #0]
 80083fc:	ba00      	rev	r0, r0
 80083fe:	f8c4 00e0 	str.w	r0, [r4, #224]	; 0xe0
    return driver->registers[6];
}
 8008402:	b002      	add	sp, #8
 8008404:	bd10      	pop	{r4, pc}
 8008406:	bf00      	nop
 8008408:	0800ba44 	.word	0x0800ba44
 800840c:	20000ee0 	.word	0x20000ee0

08008410 <max2870Disable>:

static void max2870Disable(MAX2870Driver* driver)
{
    if(driver->config->gpioChipEnable != 0xffff) {
 8008410:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008414:	6803      	ldr	r3, [r0, #0]
{
 8008416:	b510      	push	{r4, lr}
    if(driver->config->gpioChipEnable != 0xffff) {
 8008418:	891b      	ldrh	r3, [r3, #8]
{
 800841a:	4604      	mov	r4, r0
    if(driver->config->gpioChipEnable != 0xffff) {
 800841c:	4293      	cmp	r3, r2
 800841e:	d00b      	beq.n	8008438 <max2870Disable+0x28>
        gpioSetPin(driver->config->gpioChipEnable, false);
 8008420:	2100      	movs	r1, #0
 8008422:	4618      	mov	r0, r3
 8008424:	f7ff f882 	bl	800752c <gpioSetPin.isra.0>
    } else {
        max2870WriteRegister(driver, 2, _BV(MAX2870_REG2_SHDN_OFFSET), true);
    }

    if(driver->config->lockStatus) {
 8008428:	6823      	ldr	r3, [r4, #0]
 800842a:	69db      	ldr	r3, [r3, #28]
 800842c:	b10b      	cbz	r3, 8008432 <max2870Disable+0x22>
        driver->config->lockStatus(false);
 800842e:	2000      	movs	r0, #0
 8008430:	4798      	blx	r3
    }
    driver->enabled = false;
 8008432:	2300      	movs	r3, #0
 8008434:	7123      	strb	r3, [r4, #4]
}
 8008436:	bd10      	pop	{r4, pc}
        max2870WriteRegister(driver, 2, _BV(MAX2870_REG2_SHDN_OFFSET), true);
 8008438:	2301      	movs	r3, #1
 800843a:	2220      	movs	r2, #32
 800843c:	2102      	movs	r1, #2
 800843e:	f7ff ff4b 	bl	80082d8 <max2870WriteRegister>
 8008442:	e7f1      	b.n	8008428 <max2870Disable+0x18>

08008444 <max2870WriteAllRegisters.isra.0>:
static bool max2870WriteAllRegisters(MAX2870Driver* driver, uint32_t* registers, bool force)
 8008444:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008448:	4606      	mov	r6, r0
 800844a:	460f      	mov	r7, r1
 800844c:	4690      	mov	r8, r2
    bool anyChanged = false;
 800844e:	2500      	movs	r5, #0
    for(int i = 5; i>=0; i--) {
 8008450:	2405      	movs	r4, #5
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 8008452:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
 8008456:	f1b8 0f00 	cmp.w	r8, #0
 800845a:	d110      	bne.n	800847e <max2870WriteAllRegisters.isra.0+0x3a>
 800845c:	2c00      	cmp	r4, #0
 800845e:	bf0c      	ite	eq
 8008460:	462b      	moveq	r3, r5
 8008462:	2300      	movne	r3, #0
 8008464:	4621      	mov	r1, r4
 8008466:	4630      	mov	r0, r6
 8008468:	f003 0301 	and.w	r3, r3, #1
 800846c:	f7ff ff34 	bl	80082d8 <max2870WriteRegister>
    for(int i = 5; i>=0; i--) {
 8008470:	3c01      	subs	r4, #1
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 8008472:	ea45 0500 	orr.w	r5, r5, r0
 8008476:	b2ed      	uxtb	r5, r5
    for(int i = 5; i>=0; i--) {
 8008478:	d2eb      	bcs.n	8008452 <max2870WriteAllRegisters.isra.0+0xe>
}
 800847a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        anyChanged |= max2870WriteRegister(driver, i, registers[i], force || (i==0 && anyChanged));
 800847e:	2301      	movs	r3, #1
 8008480:	e7f0      	b.n	8008464 <max2870WriteAllRegisters.isra.0+0x20>
	...

08008484 <xQueueGenericSend.constprop.0>:
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
 8008484:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8008488:	2300      	movs	r3, #0
	configASSERT( pxQueue );
 800848a:	4604      	mov	r4, r0
 800848c:	9301      	str	r3, [sp, #4]
 800848e:	b900      	cbnz	r0, 8008492 <xQueueGenericSend.constprop.0+0xe>
 8008490:	e7fe      	b.n	8008490 <xQueueGenericSend.constprop.0+0xc>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8008492:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8008494:	b105      	cbz	r5, 8008498 <xQueueGenericSend.constprop.0+0x14>
 8008496:	e7fe      	b.n	8008496 <xQueueGenericSend.constprop.0+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8008498:	4e7e      	ldr	r6, [pc, #504]	; (8008694 <xQueueGenericSend.constprop.0+0x210>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 800849a:	4f7f      	ldr	r7, [pc, #508]	; (8008698 <xQueueGenericSend.constprop.0+0x214>)
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800849c:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 800869c <xQueueGenericSend.constprop.0+0x218>
 80084a0:	e0bb      	b.n	800861a <xQueueGenericSend.constprop.0+0x196>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80084a2:	6865      	ldr	r5, [r4, #4]
		if( pxMutexHolder != NULL )
 80084a4:	bb5d      	cbnz	r5, 80084fe <xQueueGenericSend.constprop.0+0x7a>
	BaseType_t xReturn = pdFALSE;
 80084a6:	2500      	movs	r5, #0
				pxQueue->pxMutexHolder = NULL;
 80084a8:	2200      	movs	r2, #0
 80084aa:	6062      	str	r2, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80084ac:	3601      	adds	r6, #1
 80084ae:	63a6      	str	r6, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80084b0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80084b2:	2a00      	cmp	r2, #0
 80084b4:	d068      	beq.n	8008588 <xQueueGenericSend.constprop.0+0x104>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80084b6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80084ba:	f7fc f9bf 	bl	800483c <xTaskRemoveFromEventList>
 80084be:	2800      	cmp	r0, #0
 80084c0:	d064      	beq.n	800858c <xQueueGenericSend.constprop.0+0x108>
						queueYIELD_IF_USING_PREEMPTION();
 80084c2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80084c6:	4a76      	ldr	r2, [pc, #472]	; (80086a0 <xQueueGenericSend.constprop.0+0x21c>)
 80084c8:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 80084cc:	6011      	str	r1, [r2, #0]
 80084ce:	4a75      	ldr	r2, [pc, #468]	; (80086a4 <xQueueGenericSend.constprop.0+0x220>)
 80084d0:	6812      	ldr	r2, [r2, #0]
 80084d2:	b14a      	cbz	r2, 80084e8 <xQueueGenericSend.constprop.0+0x64>
 80084d4:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80084d8:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80084dc:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80084e0:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 80084e4:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 80084e8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80084ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80084f0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80084f4:	f3bf 8f4f 	dsb	sy
 80084f8:	f3bf 8f6f 	isb	sy
 80084fc:	e046      	b.n	800858c <xQueueGenericSend.constprop.0+0x108>
			configASSERT( pxTCB == pxCurrentTCB );
 80084fe:	4b67      	ldr	r3, [pc, #412]	; (800869c <xQueueGenericSend.constprop.0+0x218>)
 8008500:	681b      	ldr	r3, [r3, #0]
 8008502:	429d      	cmp	r5, r3
 8008504:	d000      	beq.n	8008508 <xQueueGenericSend.constprop.0+0x84>
 8008506:	e7fe      	b.n	8008506 <xQueueGenericSend.constprop.0+0x82>
			configASSERT( pxTCB->uxMutexesHeld );
 8008508:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800850a:	b903      	cbnz	r3, 800850e <xQueueGenericSend.constprop.0+0x8a>
 800850c:	e7fe      	b.n	800850c <xQueueGenericSend.constprop.0+0x88>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800850e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8008510:	6cea      	ldr	r2, [r5, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8008512:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8008514:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8008516:	652b      	str	r3, [r5, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8008518:	d0c5      	beq.n	80084a6 <xQueueGenericSend.constprop.0+0x22>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800851a:	2b00      	cmp	r3, #0
 800851c:	d1c3      	bne.n	80084a6 <xQueueGenericSend.constprop.0+0x22>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800851e:	f105 0804 	add.w	r8, r5, #4
 8008522:	4640      	mov	r0, r8
 8008524:	f7fc f8b7 	bl	8004696 <uxListRemove>
 8008528:	f8df c17c 	ldr.w	ip, [pc, #380]	; 80086a8 <xQueueGenericSend.constprop.0+0x224>
 800852c:	4a5f      	ldr	r2, [pc, #380]	; (80086ac <xQueueGenericSend.constprop.0+0x228>)
 800852e:	b958      	cbnz	r0, 8008548 <xQueueGenericSend.constprop.0+0xc4>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8008530:	2014      	movs	r0, #20
 8008532:	6aef      	ldr	r7, [r5, #44]	; 0x2c
 8008534:	4378      	muls	r0, r7
 8008536:	f85c 3000 	ldr.w	r3, [ip, r0]
 800853a:	b92b      	cbnz	r3, 8008548 <xQueueGenericSend.constprop.0+0xc4>
 800853c:	2101      	movs	r1, #1
 800853e:	6813      	ldr	r3, [r2, #0]
 8008540:	40b9      	lsls	r1, r7
 8008542:	ea23 0301 	bic.w	r3, r3, r1
 8008546:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8008548:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
					prvAddTaskToReadyList( pxTCB );
 800854a:	2014      	movs	r0, #20
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800854c:	f1c3 0105 	rsb	r1, r3, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8008550:	62eb      	str	r3, [r5, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8008552:	61a9      	str	r1, [r5, #24]
					prvAddTaskToReadyList( pxTCB );
 8008554:	2501      	movs	r5, #1
 8008556:	6811      	ldr	r1, [r2, #0]
 8008558:	fa05 f703 	lsl.w	r7, r5, r3
 800855c:	430f      	orrs	r7, r1
 800855e:	fb00 c003 	mla	r0, r0, r3, ip
 8008562:	4641      	mov	r1, r8
 8008564:	6017      	str	r7, [r2, #0]
 8008566:	f7fc f873 	bl	8004650 <vListInsertEnd>
 800856a:	e79d      	b.n	80084a8 <xQueueGenericSend.constprop.0+0x24>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800856c:	2100      	movs	r1, #0
 800856e:	68a0      	ldr	r0, [r4, #8]
 8008570:	f7fb fab0 	bl	8003ad4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8008574:	68a3      	ldr	r3, [r4, #8]
 8008576:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008578:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800857a:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800857c:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800857e:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8008580:	bf24      	itt	cs
 8008582:	6823      	ldrcs	r3, [r4, #0]
 8008584:	60a3      	strcs	r3, [r4, #8]
 8008586:	e056      	b.n	8008636 <xQueueGenericSend.constprop.0+0x1b2>
					else if( xYieldRequired != pdFALSE )
 8008588:	2d00      	cmp	r5, #0
 800858a:	d19a      	bne.n	80084c2 <xQueueGenericSend.constprop.0+0x3e>
				taskEXIT_CRITICAL();
 800858c:	f7fc fc1a 	bl	8004dc4 <vPortExitCritical>
				return pdPASS;
 8008590:	2001      	movs	r0, #1
}
 8008592:	b004      	add	sp, #16
 8008594:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 8008598:	9801      	ldr	r0, [sp, #4]
 800859a:	b910      	cbnz	r0, 80085a2 <xQueueGenericSend.constprop.0+0x11e>
					taskEXIT_CRITICAL();
 800859c:	f7fc fc12 	bl	8004dc4 <vPortExitCritical>
					return errQUEUE_FULL;
 80085a0:	e7f7      	b.n	8008592 <xQueueGenericSend.constprop.0+0x10e>
				else if( xEntryTimeSet == pdFALSE )
 80085a2:	b91d      	cbnz	r5, 80085ac <xQueueGenericSend.constprop.0+0x128>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80085a4:	6833      	ldr	r3, [r6, #0]
 80085a6:	9302      	str	r3, [sp, #8]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80085a8:	683b      	ldr	r3, [r7, #0]
 80085aa:	9303      	str	r3, [sp, #12]
		taskEXIT_CRITICAL();
 80085ac:	f7fc fc0a 	bl	8004dc4 <vPortExitCritical>
		vTaskSuspendAll();
 80085b0:	f7fc f882 	bl	80046b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80085b4:	f7fc f9ee 	bl	8004994 <vPortEnterCritical>
 80085b8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80085bc:	a901      	add	r1, sp, #4
		prvLockQueue( pxQueue );
 80085be:	2bff      	cmp	r3, #255	; 0xff
 80085c0:	bf04      	itt	eq
 80085c2:	2300      	moveq	r3, #0
 80085c4:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 80085c8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80085cc:	a802      	add	r0, sp, #8
		prvLockQueue( pxQueue );
 80085ce:	2bff      	cmp	r3, #255	; 0xff
 80085d0:	bf04      	itt	eq
 80085d2:	2300      	moveq	r3, #0
 80085d4:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 80085d8:	f7fc fbf4 	bl	8004dc4 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80085dc:	f7fc ff04 	bl	80053e8 <xTaskCheckForTimeOut>
 80085e0:	2800      	cmp	r0, #0
 80085e2:	d150      	bne.n	8008686 <xQueueGenericSend.constprop.0+0x202>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80085e4:	f7fc f9d6 	bl	8004994 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80085e8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80085ea:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80085ec:	429a      	cmp	r2, r3
 80085ee:	d124      	bne.n	800863a <xQueueGenericSend.constprop.0+0x1b6>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80085f0:	f7fc fbe8 	bl	8004dc4 <vPortExitCritical>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80085f4:	f8d8 1000 	ldr.w	r1, [r8]
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80085f8:	9d01      	ldr	r5, [sp, #4]
 80085fa:	3118      	adds	r1, #24
 80085fc:	f104 0010 	add.w	r0, r4, #16
 8008600:	f7fc f832 	bl	8004668 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8008604:	2101      	movs	r1, #1
 8008606:	4628      	mov	r0, r5
 8008608:	f7fc f954 	bl	80048b4 <prvAddCurrentTaskToDelayedList>
				prvUnlockQueue( pxQueue );
 800860c:	4620      	mov	r0, r4
 800860e:	f7fc fc7f 	bl	8004f10 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8008612:	f7fc fd73 	bl	80050fc <xTaskResumeAll>
 8008616:	b1c0      	cbz	r0, 800864a <xQueueGenericSend.constprop.0+0x1c6>
BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
 8008618:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
 800861a:	f7fc f9bb 	bl	8004994 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800861e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8008620:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008622:	429a      	cmp	r2, r3
 8008624:	d2b8      	bcs.n	8008598 <xQueueGenericSend.constprop.0+0x114>
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8008626:	6c22      	ldr	r2, [r4, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8008628:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800862a:	2a00      	cmp	r2, #0
 800862c:	d19e      	bne.n	800856c <xQueueGenericSend.constprop.0+0xe8>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800862e:	6823      	ldr	r3, [r4, #0]
 8008630:	2b00      	cmp	r3, #0
 8008632:	f43f af36 	beq.w	80084a2 <xQueueGenericSend.constprop.0+0x1e>
BaseType_t xReturn = pdFALSE;
 8008636:	2500      	movs	r5, #0
 8008638:	e738      	b.n	80084ac <xQueueGenericSend.constprop.0+0x28>
				prvUnlockQueue( pxQueue );
 800863a:	4620      	mov	r0, r4
	taskEXIT_CRITICAL();
 800863c:	f7fc fbc2 	bl	8004dc4 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8008640:	f7fc fc66 	bl	8004f10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8008644:	f7fc fd5a 	bl	80050fc <xTaskResumeAll>
 8008648:	e7e6      	b.n	8008618 <xQueueGenericSend.constprop.0+0x194>
					portYIELD_WITHIN_API();
 800864a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800864e:	4a14      	ldr	r2, [pc, #80]	; (80086a0 <xQueueGenericSend.constprop.0+0x21c>)
 8008650:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 8008654:	6011      	str	r1, [r2, #0]
 8008656:	4a13      	ldr	r2, [pc, #76]	; (80086a4 <xQueueGenericSend.constprop.0+0x220>)
 8008658:	6812      	ldr	r2, [r2, #0]
 800865a:	b14a      	cbz	r2, 8008670 <xQueueGenericSend.constprop.0+0x1ec>
 800865c:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 8008660:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8008664:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8008668:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800866c:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 8008670:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8008674:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008678:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800867c:	f3bf 8f4f 	dsb	sy
 8008680:	f3bf 8f6f 	isb	sy
 8008684:	e7c8      	b.n	8008618 <xQueueGenericSend.constprop.0+0x194>
			prvUnlockQueue( pxQueue );
 8008686:	4620      	mov	r0, r4
 8008688:	f7fc fc42 	bl	8004f10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800868c:	f7fc fd36 	bl	80050fc <xTaskResumeAll>
			return errQUEUE_FULL;
 8008690:	2000      	movs	r0, #0
 8008692:	e77e      	b.n	8008592 <xQueueGenericSend.constprop.0+0x10e>
 8008694:	200015fc 	.word	0x200015fc
 8008698:	20001648 	.word	0x20001648
 800869c:	200011a8 	.word	0x200011a8
 80086a0:	2000134c 	.word	0x2000134c
 80086a4:	20001358 	.word	0x20001358
 80086a8:	200011b8 	.word	0x200011b8
 80086ac:	20001374 	.word	0x20001374

080086b0 <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
 80086b0:	b508      	push	{r3, lr}

  osalDbgCheck(i2cp != NULL);
 80086b2:	b910      	cbnz	r0, 80086ba <i2cReleaseBus+0xa>
 80086b4:	f7fc f97e 	bl	80049b4 <vTaskEndScheduler>
 80086b8:	e7fe      	b.n	80086b8 <i2cReleaseBus+0x8>
    xSemaphoreGive(mutex->handle);
 80086ba:	68c0      	ldr	r0, [r0, #12]

  osalMutexUnlock(&i2cp->mutex);
}
 80086bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80086c0:	f7ff bee0 	b.w	8008484 <xQueueGenericSend.constprop.0>

080086c4 <max2870SpiState.part.0>:
static void max2870SpiState(MAX2870Driver* driver, bool enable)
 80086c4:	b510      	push	{r4, lr}
 80086c6:	4604      	mov	r4, r0
        max2870SetMUXOut(driver, 0x0);
 80086c8:	2100      	movs	r1, #0
 80086ca:	f7ff fe2f 	bl	800832c <max2870SetMUXOut>
        monitorKick(&driver->pllMon, driver->enabled);
 80086ce:	7921      	ldrb	r1, [r4, #4]
 80086d0:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
 80086d4:	f7fc fbba 	bl	8004e4c <monitorKick>
        spiReleaseBus(driver->config->spiPort);
 80086d8:	6823      	ldr	r3, [r4, #0]
 80086da:	681b      	ldr	r3, [r3, #0]
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 80086dc:	b913      	cbnz	r3, 80086e4 <max2870SpiState.part.0+0x20>
 80086de:	f7fc f969 	bl	80049b4 <vTaskEndScheduler>
 80086e2:	e7fe      	b.n	80086e2 <max2870SpiState.part.0+0x1e>
 80086e4:	68d8      	ldr	r0, [r3, #12]
}
 80086e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80086ea:	f7ff becb 	b.w	8008484 <xQueueGenericSend.constprop.0>

080086ee <prvInitialiseMutex.part.0>:
			pxNewQueue->pxMutexHolder = NULL;
 80086ee:	2200      	movs	r2, #0
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 80086f0:	e9c0 2200 	strd	r2, r2, [r0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 80086f4:	60c2      	str	r2, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 80086f6:	f7ff bec5 	b.w	8008484 <xQueueGenericSend.constprop.0>

080086fa <xQueueGenericReset.constprop.0.isra.0>:
BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 80086fa:	b510      	push	{r4, lr}
	configASSERT( pxQueue );
 80086fc:	b900      	cbnz	r0, 8008700 <xQueueGenericReset.constprop.0.isra.0+0x6>
 80086fe:	e7fe      	b.n	80086fe <xQueueGenericReset.constprop.0.isra.0+0x4>
	taskENTER_CRITICAL();
 8008700:	f7fc f948 	bl	8004994 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8008704:	e9d0 340f 	ldrd	r3, r4, [r0, #60]	; 0x3c
 8008708:	4363      	muls	r3, r4
 800870a:	6802      	ldr	r2, [r0, #0]
 800870c:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800870e:	1b1b      	subs	r3, r3, r4
 8008710:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8008712:	6041      	str	r1, [r0, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8008714:	60c3      	str	r3, [r0, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8008716:	2100      	movs	r1, #0
}
 8008718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		pxQueue->cRxLock = queueUNLOCKED;
 800871c:	23ff      	movs	r3, #255	; 0xff
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800871e:	6082      	str	r2, [r0, #8]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8008720:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8008724:	6381      	str	r1, [r0, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 8008726:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800872a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800872e:	f100 0318 	add.w	r3, r0, #24
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008732:	e9c0 2306 	strd	r2, r3, [r0, #24]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008736:	6143      	str	r3, [r0, #20]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008738:	6203      	str	r3, [r0, #32]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800873a:	f100 032c 	add.w	r3, r0, #44	; 0x2c
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800873e:	6101      	str	r1, [r0, #16]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8008740:	e9c0 320a 	strd	r3, r2, [r0, #40]	; 0x28
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8008744:	e9c0 330c 	strd	r3, r3, [r0, #48]	; 0x30
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8008748:	6241      	str	r1, [r0, #36]	; 0x24
	taskEXIT_CRITICAL();
 800874a:	f7fc bb3b 	b.w	8004dc4 <vPortExitCritical>

0800874e <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800874e:	b40e      	push	{r1, r2, r3}
 8008750:	b503      	push	{r0, r1, lr}
 8008752:	aa03      	add	r2, sp, #12
 8008754:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8008758:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800875a:	f7fe f9c7 	bl	8006aec <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800875e:	b002      	add	sp, #8
 8008760:	f85d eb04 	ldr.w	lr, [sp], #4
 8008764:	b003      	add	sp, #12
 8008766:	4770      	bx	lr

08008768 <cmd_exit>:
#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)user;
  (void)argv;
  if (argc > 0) {
 8008768:	2a00      	cmp	r2, #0
static void cmd_exit(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 800876a:	4608      	mov	r0, r1
 800876c:	b508      	push	{r3, lr}
  if (argc > 0) {
 800876e:	dd05      	ble.n	800877c <cmd_exit+0x14>
    shellUsage(chp, "exit");
    return;
  }

  shellExit(MSG_OK);
}
 8008770:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shellUsage(chp, "exit");
 8008774:	4a06      	ldr	r2, [pc, #24]	; (8008790 <cmd_exit+0x28>)
 8008776:	4907      	ldr	r1, [pc, #28]	; (8008794 <cmd_exit+0x2c>)
 8008778:	f7ff bfe9 	b.w	800874e <chprintf>
 */
void shellExit(msg_t msg) {

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 800877c:	f7fc f90a 	bl	8004994 <vPortEnterCritical>
}
static inline void chEvtBroadcast(event_source_t* event_source){
    osalEventBroadcastFlags(event_source, 1);
}
static inline void chEvtBroadcastI(event_source_t* event_source){
    osalEventBroadcastFlagsI(event_source, 1);
 8008780:	4805      	ldr	r0, [pc, #20]	; (8008798 <cmd_exit+0x30>)
 8008782:	2101      	movs	r1, #1
 8008784:	f7fe fba6 	bl	8006ed4 <osalEventBroadcastFlagsI>
}
 8008788:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vTaskDelete(NULL);
 800878c:	f7fd bc70 	b.w	8006070 <vTaskDelete.constprop.0>
 8008790:	0800bac5 	.word	0x0800bac5
 8008794:	0800baca 	.word	0x0800baca
 8008798:	200012b8 	.word	0x200012b8

0800879c <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)user;
  (void)argv;
  if (argc > 0) {
 800879c:	2a00      	cmp	r2, #0
static void cmd_info(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 800879e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80087a0:	460c      	mov	r4, r1
  if (argc > 0) {
 80087a2:	dd07      	ble.n	80087b4 <cmd_info+0x18>
    shellUsage(chp, "info");
 80087a4:	4620      	mov	r0, r4
 80087a6:	4a1d      	ldr	r2, [pc, #116]	; (800881c <cmd_info+0x80>)
 80087a8:	491d      	ldr	r1, [pc, #116]	; (8008820 <cmd_info+0x84>)
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
    chprintf(chp, "%02x", *i);
  }
  chprintf(chp, SHELL_NEWLINE_STR);
#endif
}
 80087aa:	b003      	add	sp, #12
 80087ac:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    shellUsage(chp, "info");
 80087b0:	f7ff bfcd 	b.w	800874e <chprintf>
  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 80087b4:	4a1b      	ldr	r2, [pc, #108]	; (8008824 <cmd_info+0x88>)
 80087b6:	491c      	ldr	r1, [pc, #112]	; (8008828 <cmd_info+0x8c>)
 80087b8:	4620      	mov	r0, r4
 80087ba:	f7ff ffc8 	bl	800874e <chprintf>
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 80087be:	4a1b      	ldr	r2, [pc, #108]	; (800882c <cmd_info+0x90>)
 80087c0:	491b      	ldr	r1, [pc, #108]	; (8008830 <cmd_info+0x94>)
 80087c2:	4620      	mov	r0, r4
 80087c4:	f7ff ffc3 	bl	800874e <chprintf>
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
 80087c8:	4a1a      	ldr	r2, [pc, #104]	; (8008834 <cmd_info+0x98>)
 80087ca:	491b      	ldr	r1, [pc, #108]	; (8008838 <cmd_info+0x9c>)
 80087cc:	4620      	mov	r0, r4
 80087ce:	f7ff ffbe 	bl	800874e <chprintf>
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
 80087d2:	4a1a      	ldr	r2, [pc, #104]	; (800883c <cmd_info+0xa0>)
 80087d4:	491a      	ldr	r1, [pc, #104]	; (8008840 <cmd_info+0xa4>)
 80087d6:	4620      	mov	r0, r4
 80087d8:	f7ff ffb9 	bl	800874e <chprintf>
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 80087dc:	4b19      	ldr	r3, [pc, #100]	; (8008844 <cmd_info+0xa8>)
 80087de:	4a1a      	ldr	r2, [pc, #104]	; (8008848 <cmd_info+0xac>)
 80087e0:	491a      	ldr	r1, [pc, #104]	; (800884c <cmd_info+0xb0>)
 80087e2:	9300      	str	r3, [sp, #0]
 80087e4:	4620      	mov	r0, r4
 80087e6:	4b1a      	ldr	r3, [pc, #104]	; (8008850 <cmd_info+0xb4>)
 80087e8:	f7ff ffb1 	bl	800874e <chprintf>
  chprintf(chp, "Build ID:     ");
 80087ec:	4620      	mov	r0, r4
 80087ee:	4919      	ldr	r1, [pc, #100]	; (8008854 <cmd_info+0xb8>)
 80087f0:	f7ff ffad 	bl	800874e <chprintf>
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 80087f4:	4d18      	ldr	r5, [pc, #96]	; (8008858 <cmd_info+0xbc>)
 80087f6:	4e19      	ldr	r6, [pc, #100]	; (800885c <cmd_info+0xc0>)
    chprintf(chp, "%02x", *i);
 80087f8:	4f19      	ldr	r7, [pc, #100]	; (8008860 <cmd_info+0xc4>)
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 80087fa:	42b5      	cmp	r5, r6
 80087fc:	d306      	bcc.n	800880c <cmd_info+0x70>
  chprintf(chp, SHELL_NEWLINE_STR);
 80087fe:	4620      	mov	r0, r4
 8008800:	4918      	ldr	r1, [pc, #96]	; (8008864 <cmd_info+0xc8>)
}
 8008802:	b003      	add	sp, #12
 8008804:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chprintf(chp, SHELL_NEWLINE_STR);
 8008808:	f7ff bfa1 	b.w	800874e <chprintf>
    chprintf(chp, "%02x", *i);
 800880c:	4639      	mov	r1, r7
 800880e:	4620      	mov	r0, r4
 8008810:	f815 2b01 	ldrb.w	r2, [r5], #1
 8008814:	f7ff ff9b 	bl	800874e <chprintf>
  for(uint8_t* i=&__buildid_base__+16; i<&__buildid_end__; i++){
 8008818:	e7ef      	b.n	80087fa <cmd_info+0x5e>
 800881a:	bf00      	nop
 800881c:	0800bad6 	.word	0x0800bad6
 8008820:	0800baca 	.word	0x0800baca
 8008824:	0800badb 	.word	0x0800badb
 8008828:	0800bae8 	.word	0x0800bae8
 800882c:	0800bafb 	.word	0x0800bafb
 8008830:	0800bb08 	.word	0x0800bb08
 8008834:	0800bb1b 	.word	0x0800bb1b
 8008838:	0800bb45 	.word	0x0800bb45
 800883c:	0800bb58 	.word	0x0800bb58
 8008840:	0800bb7f 	.word	0x0800bb7f
 8008844:	0800bbb9 	.word	0x0800bbb9
 8008848:	0800bb96 	.word	0x0800bb96
 800884c:	0800bba2 	.word	0x0800bba2
 8008850:	0800bb92 	.word	0x0800bb92
 8008854:	0800bbc2 	.word	0x0800bbc2
 8008858:	0800cd68 	.word	0x0800cd68
 800885c:	0800cd7c 	.word	0x0800cd7c
 8008860:	0800bbd1 	.word	0x0800bbd1
 8008864:	0800be60 	.word	0x0800be60

08008868 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;
  (void)user;
  if (argc != 1) {
 8008868:	2a01      	cmp	r2, #1
static void cmd_echo(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 800886a:	4608      	mov	r0, r1
    shellUsage(chp, "echo \"message\"");
 800886c:	bf19      	ittee	ne
 800886e:	4a03      	ldrne	r2, [pc, #12]	; (800887c <cmd_echo+0x14>)
 8008870:	4903      	ldrne	r1, [pc, #12]	; (8008880 <cmd_echo+0x18>)
    return;
  }
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
 8008872:	681a      	ldreq	r2, [r3, #0]
 8008874:	4903      	ldreq	r1, [pc, #12]	; (8008884 <cmd_echo+0x1c>)
 8008876:	f7ff bf6a 	b.w	800874e <chprintf>
 800887a:	bf00      	nop
 800887c:	0800bbd6 	.word	0x0800bbd6
 8008880:	0800baca 	.word	0x0800baca
 8008884:	0800bb8d 	.word	0x0800bb8d

08008888 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;
  (void)user;
  if (argc > 0) {
 8008888:	2a00      	cmp	r2, #0
static void cmd_systime(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 800888a:	4608      	mov	r0, r1
 800888c:	b508      	push	{r3, lr}
  if (argc > 0) {
 800888e:	dd05      	ble.n	800889c <cmd_systime+0x14>
    shellUsage(chp, "systime");
 8008890:	4a05      	ldr	r2, [pc, #20]	; (80088a8 <cmd_systime+0x20>)
 8008892:	4906      	ldr	r1, [pc, #24]	; (80088ac <cmd_systime+0x24>)
    return;
  }
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
 8008894:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8008898:	f7ff bf59 	b.w	800874e <chprintf>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800889c:	f7fd fb36 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 80088a0:	4b03      	ldr	r3, [pc, #12]	; (80088b0 <cmd_systime+0x28>)
 80088a2:	4904      	ldr	r1, [pc, #16]	; (80088b4 <cmd_systime+0x2c>)
 80088a4:	681a      	ldr	r2, [r3, #0]
 80088a6:	e7f5      	b.n	8008894 <cmd_systime+0xc>
 80088a8:	0800bbe5 	.word	0x0800bbe5
 80088ac:	0800baca 	.word	0x0800baca
 80088b0:	20001648 	.word	0x20001648
 80088b4:	0800bbed 	.word	0x0800bbed

080088b8 <cmd_mem>:
#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, total, largest;
  (void)argv;
  (void)user;
  if (argc > 0) {
 80088b8:	2a00      	cmp	r2, #0
static void cmd_mem(void* user, BaseSequentialStream *chp, int argc, char *argv[]) {
 80088ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80088bc:	460c      	mov	r4, r1
  if (argc > 0) {
 80088be:	dd06      	ble.n	80088ce <cmd_mem+0x16>
    shellUsage(chp, "mem");
 80088c0:	4a14      	ldr	r2, [pc, #80]	; (8008914 <cmd_mem+0x5c>)
 80088c2:	4915      	ldr	r1, [pc, #84]	; (8008918 <cmd_mem+0x60>)
  }
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 80088c4:	4620      	mov	r0, r4
}
 80088c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 80088ca:	f7ff bf40 	b.w	800874e <chprintf>

/* ChibiOS style memory info function */
size_t chHeapStatus  (void* ignore, size_t* memFree, size_t* largestBlock){
    size_t blocks = 0;
    *memFree = xFreeBytesRemaining;
    *largestBlock = 0;
 80088ce:	2500      	movs	r5, #0
    size_t blocks = 0;
 80088d0:	462e      	mov	r6, r5
    *memFree = xFreeBytesRemaining;
 80088d2:	4b12      	ldr	r3, [pc, #72]	; (800891c <cmd_mem+0x64>)
 80088d4:	681f      	ldr	r7, [r3, #0]

    /* Count blocks */
    BlockLink_t *pxIterator;
    for(pxIterator = xStart.pxNextFreeBlock; pxIterator->pxNextFreeBlock; pxIterator = pxIterator->pxNextFreeBlock ){
 80088d6:	4b12      	ldr	r3, [pc, #72]	; (8008920 <cmd_mem+0x68>)
 80088d8:	681b      	ldr	r3, [r3, #0]
 80088da:	681a      	ldr	r2, [r3, #0]
 80088dc:	b98a      	cbnz	r2, 8008902 <cmd_mem+0x4a>
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 80088de:	463a      	mov	r2, r7
 80088e0:	4910      	ldr	r1, [pc, #64]	; (8008924 <cmd_mem+0x6c>)
 80088e2:	4620      	mov	r0, r4
 80088e4:	f7ff ff33 	bl	800874e <chprintf>
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
 80088e8:	4632      	mov	r2, r6
 80088ea:	490f      	ldr	r1, [pc, #60]	; (8008928 <cmd_mem+0x70>)
 80088ec:	4620      	mov	r0, r4
 80088ee:	f7ff ff2e 	bl	800874e <chprintf>
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
 80088f2:	463a      	mov	r2, r7
 80088f4:	490d      	ldr	r1, [pc, #52]	; (800892c <cmd_mem+0x74>)
 80088f6:	4620      	mov	r0, r4
 80088f8:	f7ff ff29 	bl	800874e <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 80088fc:	462a      	mov	r2, r5
 80088fe:	490c      	ldr	r1, [pc, #48]	; (8008930 <cmd_mem+0x78>)
 8008900:	e7e0      	b.n	80088c4 <cmd_mem+0xc>
        if(pxIterator->xBlockSize){
 8008902:	685b      	ldr	r3, [r3, #4]
 8008904:	b103      	cbz	r3, 8008908 <cmd_mem+0x50>
            blocks++;
 8008906:	3601      	adds	r6, #1
 8008908:	429d      	cmp	r5, r3
 800890a:	bf38      	it	cc
 800890c:	461d      	movcc	r5, r3
 800890e:	4613      	mov	r3, r2
 8008910:	e7e3      	b.n	80088da <cmd_mem+0x22>
 8008912:	bf00      	nop
 8008914:	0800bbf3 	.word	0x0800bbf3
 8008918:	0800baca 	.word	0x0800baca
 800891c:	200013a4 	.word	0x200013a4
 8008920:	20001618 	.word	0x20001618
 8008924:	0800bbf7 	.word	0x0800bbf7
 8008928:	0800bc15 	.word	0x0800bc15
 800892c:	0800bc2d 	.word	0x0800bc2d
 8008930:	0800bc4b 	.word	0x0800bc4b

08008934 <cmdMco>:
    if(argc != 1) {
 8008934:	2a01      	cmp	r2, #1
{
 8008936:	b510      	push	{r4, lr}
 8008938:	460c      	mov	r4, r1
    if(argc != 1) {
 800893a:	d009      	beq.n	8008950 <cmdMco+0x1c>
        chprintf(chp,"Usage:"SHELL_NEWLINE_STR);
 800893c:	4620      	mov	r0, r4
 800893e:	490a      	ldr	r1, [pc, #40]	; (8008968 <cmdMco+0x34>)
 8008940:	f7ff ff05 	bl	800874e <chprintf>
        chprintf(chp,"\t mco [1/0]"SHELL_NEWLINE_STR);
 8008944:	4620      	mov	r0, r4
}
 8008946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        chprintf(chp,"\t mco [1/0]"SHELL_NEWLINE_STR);
 800894a:	4908      	ldr	r1, [pc, #32]	; (800896c <cmdMco+0x38>)
 800894c:	f7ff beff 	b.w	800874e <chprintf>
        systemEnableMCO(argv[0][0] == '1');
 8008950:	681b      	ldr	r3, [r3, #0]
    if(enable) {
 8008952:	781b      	ldrb	r3, [r3, #0]
 8008954:	2b31      	cmp	r3, #49	; 0x31
 8008956:	4b06      	ldr	r3, [pc, #24]	; (8008970 <cmdMco+0x3c>)
        RCC->CFGR |=STM32_MCOSEL_PLLDIV2;
 8008958:	685a      	ldr	r2, [r3, #4]
 800895a:	bf0c      	ite	eq
 800895c:	f042 62e0 	orreq.w	r2, r2, #117440512	; 0x7000000
    } else {
        //RCC->CFGR &=~ STM32_MCOSEL_SYSCLK;
        RCC->CFGR &=~STM32_MCOSEL_PLLDIV2;
 8008960:	f022 62e0 	bicne.w	r2, r2, #117440512	; 0x7000000
 8008964:	605a      	str	r2, [r3, #4]
}
 8008966:	bd10      	pop	{r4, pc}
 8008968:	0800bc69 	.word	0x0800bc69
 800896c:	0800bc72 	.word	0x0800bc72
 8008970:	40021000 	.word	0x40021000

08008974 <cmdLicense>:
{
 8008974:	4608      	mov	r0, r1
    chprintf(chp,"%s", &_binary_data_license_bin_start);
 8008976:	4a02      	ldr	r2, [pc, #8]	; (8008980 <cmdLicense+0xc>)
 8008978:	4902      	ldr	r1, [pc, #8]	; (8008984 <cmdLicense+0x10>)
 800897a:	f7ff bee8 	b.w	800874e <chprintf>
 800897e:	bf00      	nop
 8008980:	08002234 	.word	0x08002234
 8008984:	0800bc80 	.word	0x0800bc80

08008988 <cmdMaxUsage>:
#include <string.h>
#include <stdlib.h>


static void cmdMaxUsage(BaseSequentialStream* chp)
{
 8008988:	b510      	push	{r4, lr}
 800898a:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 800898c:	490e      	ldr	r1, [pc, #56]	; (80089c8 <cmdMaxUsage+0x40>)
 800898e:	f7ff fede 	bl	800874e <chprintf>
    chprintf(chp, "\tmax tune [freqkHz] [power] [forceVAS]"SHELL_NEWLINE_STR);
 8008992:	4620      	mov	r0, r4
 8008994:	490d      	ldr	r1, [pc, #52]	; (80089cc <cmdMaxUsage+0x44>)
 8008996:	f7ff feda 	bl	800874e <chprintf>
    chprintf(chp, "\tmax status"SHELL_NEWLINE_STR);
 800899a:	4620      	mov	r0, r4
 800899c:	490c      	ldr	r1, [pc, #48]	; (80089d0 <cmdMaxUsage+0x48>)
 800899e:	f7ff fed6 	bl	800874e <chprintf>
    chprintf(chp, "\tmax vcocache"SHELL_NEWLINE_STR);
 80089a2:	4620      	mov	r0, r4
 80089a4:	490b      	ldr	r1, [pc, #44]	; (80089d4 <cmdMaxUsage+0x4c>)
 80089a6:	f7ff fed2 	bl	800874e <chprintf>
    chprintf(chp, "\tmax vcocache calibrate"SHELL_NEWLINE_STR);
 80089aa:	4620      	mov	r0, r4
 80089ac:	490a      	ldr	r1, [pc, #40]	; (80089d8 <cmdMaxUsage+0x50>)
 80089ae:	f7ff fece 	bl	800874e <chprintf>
    chprintf(chp, "\tmax vcocache set index value"SHELL_NEWLINE_STR);
 80089b2:	4620      	mov	r0, r4
 80089b4:	4909      	ldr	r1, [pc, #36]	; (80089dc <cmdMaxUsage+0x54>)
 80089b6:	f7ff feca 	bl	800874e <chprintf>
    chprintf(chp, "\tmax dld"SHELL_NEWLINE_STR);
 80089ba:	4620      	mov	r0, r4
}
 80089bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\tmax dld"SHELL_NEWLINE_STR);
 80089c0:	4907      	ldr	r1, [pc, #28]	; (80089e0 <cmdMaxUsage+0x58>)
 80089c2:	f7ff bec4 	b.w	800874e <chprintf>
 80089c6:	bf00      	nop
 80089c8:	0800bc69 	.word	0x0800bc69
 80089cc:	0800bc83 	.word	0x0800bc83
 80089d0:	0800bcac 	.word	0x0800bcac
 80089d4:	0800bcba 	.word	0x0800bcba
 80089d8:	0800bcca 	.word	0x0800bcca
 80089dc:	0800bce4 	.word	0x0800bce4
 80089e0:	0800bd04 	.word	0x0800bd04

080089e4 <cmdI2CUsage>:

#include <string.h>
#include <stdlib.h>

static void cmdI2CUsage(BaseSequentialStream *chp)
{
 80089e4:	b510      	push	{r4, lr}
 80089e6:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 80089e8:	490c      	ldr	r1, [pc, #48]	; (8008a1c <cmdI2CUsage+0x38>)
 80089ea:	f7ff feb0 	bl	800874e <chprintf>
    chprintf(chp, "\ti2c test"SHELL_NEWLINE_STR);
 80089ee:	4620      	mov	r0, r4
 80089f0:	490b      	ldr	r1, [pc, #44]	; (8008a20 <cmdI2CUsage+0x3c>)
 80089f2:	f7ff feac 	bl	800874e <chprintf>
    chprintf(chp, "\ti2c scan"SHELL_NEWLINE_STR);
 80089f6:	4620      	mov	r0, r4
 80089f8:	490a      	ldr	r1, [pc, #40]	; (8008a24 <cmdI2CUsage+0x40>)
 80089fa:	f7ff fea8 	bl	800874e <chprintf>
    chprintf(chp, "\ti2c errors"SHELL_NEWLINE_STR);
 80089fe:	4620      	mov	r0, r4
 8008a00:	4909      	ldr	r1, [pc, #36]	; (8008a28 <cmdI2CUsage+0x44>)
 8008a02:	f7ff fea4 	bl	800874e <chprintf>
    chprintf(chp, "\ti2c get devAddr regAddr [stress]"SHELL_NEWLINE_STR);
 8008a06:	4620      	mov	r0, r4
 8008a08:	4908      	ldr	r1, [pc, #32]	; (8008a2c <cmdI2CUsage+0x48>)
 8008a0a:	f7ff fea0 	bl	800874e <chprintf>
    chprintf(chp, "\ti2c set devAddr regAddr regValue [stress]"SHELL_NEWLINE_STR);
 8008a0e:	4620      	mov	r0, r4
}
 8008a10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\ti2c set devAddr regAddr regValue [stress]"SHELL_NEWLINE_STR);
 8008a14:	4906      	ldr	r1, [pc, #24]	; (8008a30 <cmdI2CUsage+0x4c>)
 8008a16:	f7ff be9a 	b.w	800874e <chprintf>
 8008a1a:	bf00      	nop
 8008a1c:	0800bc69 	.word	0x0800bc69
 8008a20:	0800bd0f 	.word	0x0800bd0f
 8008a24:	0800bd1b 	.word	0x0800bd1b
 8008a28:	0800bd27 	.word	0x0800bd27
 8008a2c:	0800bd35 	.word	0x0800bd35
 8008a30:	0800bd59 	.word	0x0800bd59

08008a34 <cmdGPIOUsage>:

#include <string.h>
#include <stdlib.h>

static void cmdGPIOUsage(BaseSequentialStream *chp)
{
 8008a34:	b510      	push	{r4, lr}
 8008a36:	4604      	mov	r4, r0
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 8008a38:	4910      	ldr	r1, [pc, #64]	; (8008a7c <cmdGPIOUsage+0x48>)
 8008a3a:	f7ff fe88 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio status"SHELL_NEWLINE_STR);
 8008a3e:	4620      	mov	r0, r4
 8008a40:	490f      	ldr	r1, [pc, #60]	; (8008a80 <cmdGPIOUsage+0x4c>)
 8008a42:	f7ff fe84 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] [pin] output"SHELL_NEWLINE_STR);
 8008a46:	4620      	mov	r0, r4
 8008a48:	490e      	ldr	r1, [pc, #56]	; (8008a84 <cmdGPIOUsage+0x50>)
 8008a4a:	f7ff fe80 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] [pin] input"SHELL_NEWLINE_STR);
 8008a4e:	4620      	mov	r0, r4
 8008a50:	490d      	ldr	r1, [pc, #52]	; (8008a88 <cmdGPIOUsage+0x54>)
 8008a52:	f7ff fe7c 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] [pin] set"SHELL_NEWLINE_STR);
 8008a56:	4620      	mov	r0, r4
 8008a58:	490c      	ldr	r1, [pc, #48]	; (8008a8c <cmdGPIOUsage+0x58>)
 8008a5a:	f7ff fe78 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] [pin] clear"SHELL_NEWLINE_STR);
 8008a5e:	4620      	mov	r0, r4
 8008a60:	490b      	ldr	r1, [pc, #44]	; (8008a90 <cmdGPIOUsage+0x5c>)
 8008a62:	f7ff fe74 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] [pin] get"SHELL_NEWLINE_STR);
 8008a66:	4620      	mov	r0, r4
 8008a68:	490a      	ldr	r1, [pc, #40]	; (8008a94 <cmdGPIOUsage+0x60>)
 8008a6a:	f7ff fe70 	bl	800874e <chprintf>
    chprintf(chp, "\tgpio [port] bus [on/off]"SHELL_NEWLINE_STR);
 8008a6e:	4620      	mov	r0, r4

}
 8008a70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "\tgpio [port] bus [on/off]"SHELL_NEWLINE_STR);
 8008a74:	4908      	ldr	r1, [pc, #32]	; (8008a98 <cmdGPIOUsage+0x64>)
 8008a76:	f7ff be6a 	b.w	800874e <chprintf>
 8008a7a:	bf00      	nop
 8008a7c:	0800bc69 	.word	0x0800bc69
 8008a80:	0800bd86 	.word	0x0800bd86
 8008a84:	0800bd95 	.word	0x0800bd95
 8008a88:	0800bdb1 	.word	0x0800bdb1
 8008a8c:	0800bdcc 	.word	0x0800bdcc
 8008a90:	0800bde5 	.word	0x0800bde5
 8008a94:	0800be00 	.word	0x0800be00
 8008a98:	0800be19 	.word	0x0800be19

08008a9c <gpioDummyStatus>:

    return false;
}

void gpioDummyStatus(const GPIOPort* driver, BaseSequentialStream* chp)
{
 8008a9c:	4608      	mov	r0, r1
    (void)driver;

    chprintf(chp, "\tDriver: Dummy"SHELL_NEWLINE_STR);
 8008a9e:	4901      	ldr	r1, [pc, #4]	; (8008aa4 <gpioDummyStatus+0x8>)
 8008aa0:	f7ff be55 	b.w	800874e <chprintf>
 8008aa4:	0800be35 	.word	0x0800be35

08008aa8 <printfFixed>:
{
 8008aa8:	b40c      	push	{r2, r3}
 8008aaa:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8008aae:	aa08      	add	r2, sp, #32
 8008ab0:	460d      	mov	r5, r1
 8008ab2:	f852 1b04 	ldr.w	r1, [r2], #4
 8008ab6:	4606      	mov	r6, r0
    va_start(args, format);
 8008ab8:	9201      	str	r2, [sp, #4]
    int result = chvprintf(chn, format, args);
 8008aba:	f7fe f817 	bl	8006aec <chvprintf>
 8008abe:	4604      	mov	r4, r0
 8008ac0:	4607      	mov	r7, r0
        chnWrite(chn, (unsigned char*)" ", 1);
 8008ac2:	f8df 802c 	ldr.w	r8, [pc, #44]	; 8008af0 <printfFixed+0x48>
    for(; result<minLength; result++) {
 8008ac6:	42af      	cmp	r7, r5
 8008ac8:	db09      	blt.n	8008ade <printfFixed+0x36>
 8008aca:	1b28      	subs	r0, r5, r4
 8008acc:	42ac      	cmp	r4, r5
 8008ace:	bfc8      	it	gt
 8008ad0:	2000      	movgt	r0, #0
}
 8008ad2:	4420      	add	r0, r4
 8008ad4:	b002      	add	sp, #8
 8008ad6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8008ada:	b002      	add	sp, #8
 8008adc:	4770      	bx	lr
        chnWrite(chn, (unsigned char*)" ", 1);
 8008ade:	6833      	ldr	r3, [r6, #0]
 8008ae0:	2201      	movs	r2, #1
 8008ae2:	4641      	mov	r1, r8
 8008ae4:	4630      	mov	r0, r6
 8008ae6:	681b      	ldr	r3, [r3, #0]
 8008ae8:	4798      	blx	r3
    for(; result<minLength; result++) {
 8008aea:	3701      	adds	r7, #1
 8008aec:	e7eb      	b.n	8008ac6 <printfFixed+0x1e>
 8008aee:	bf00      	nop
 8008af0:	0800bbcf 	.word	0x0800bbcf

08008af4 <max2870StatusPrint>:

    return allGood;
}

void max2870StatusPrint(MAX2870Driver* driver, BaseSequentialStream* stdout)
{
 8008af4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008af8:	4605      	mov	r5, r0
 8008afa:	460c      	mov	r4, r1
    max2870SpiState(driver, true);
 8008afc:	f7ff fb14 	bl	8008128 <max2870SpiState.constprop.0>
    if(driver->enabled) {
 8008b00:	792b      	ldrb	r3, [r5, #4]
 8008b02:	2b00      	cmp	r3, #0
 8008b04:	f000 80c8 	beq.w	8008c98 <max2870StatusPrint+0x1a4>
        if(driver->currentTune.isLocked) {
 8008b08:	7f2b      	ldrb	r3, [r5, #28]
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	f000 8092 	beq.w	8008c34 <max2870StatusPrint+0x140>
            chprintf(stdout, "PLL Locked"SHELL_NEWLINE_STR);
 8008b10:	4964      	ldr	r1, [pc, #400]	; (8008ca4 <max2870StatusPrint+0x1b0>)
        } else {
            chprintf(stdout, "PLL UNLOCK!!!"SHELL_NEWLINE_STR);
 8008b12:	4620      	mov	r0, r4
 8008b14:	f7ff fe1b 	bl	800874e <chprintf>
        }

        printfFixed(stdout, 30, "Divided VCO Frequency:");
 8008b18:	211e      	movs	r1, #30
 8008b1a:	4a63      	ldr	r2, [pc, #396]	; (8008ca8 <max2870StatusPrint+0x1b4>)
 8008b1c:	4620      	mov	r0, r4
 8008b1e:	f7ff ffc3 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u kHz"SHELL_NEWLINE_STR, driver->currentTune.frequency/1000);
 8008b22:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 8008b26:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8008b2a:	2300      	movs	r3, #0
 8008b2c:	f7fa fe4e 	bl	80037cc <__aeabi_uldivmod>
 8008b30:	4602      	mov	r2, r0
 8008b32:	460b      	mov	r3, r1
 8008b34:	4620      	mov	r0, r4
 8008b36:	495d      	ldr	r1, [pc, #372]	; (8008cac <max2870StatusPrint+0x1b8>)
 8008b38:	f7ff fe09 	bl	800874e <chprintf>
        printfFixed(stdout, 30, "Output A Power:");
 8008b3c:	4a5c      	ldr	r2, [pc, #368]	; (8008cb0 <max2870StatusPrint+0x1bc>)
 8008b3e:	211e      	movs	r1, #30
 8008b40:	4620      	mov	r0, r4
 8008b42:	f7ff ffb1 	bl	8008aa8 <printfFixed>
        if(driver->currentTune.powerA != -127) {
 8008b46:	f995 2010 	ldrsb.w	r2, [r5, #16]
 8008b4a:	f112 0f7f 	cmn.w	r2, #127	; 0x7f
 8008b4e:	d073      	beq.n	8008c38 <max2870StatusPrint+0x144>
            chprintf(stdout, "%d dBm"SHELL_NEWLINE_STR, driver->currentTune.powerA);
 8008b50:	4620      	mov	r0, r4
 8008b52:	4958      	ldr	r1, [pc, #352]	; (8008cb4 <max2870StatusPrint+0x1c0>)
 8008b54:	f7ff fdfb 	bl	800874e <chprintf>
        } else {
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
        }
        printfFixed(stdout, 30, "Output B Power:");
 8008b58:	4a57      	ldr	r2, [pc, #348]	; (8008cb8 <max2870StatusPrint+0x1c4>)
 8008b5a:	211e      	movs	r1, #30
 8008b5c:	4620      	mov	r0, r4
 8008b5e:	f7ff ffa3 	bl	8008aa8 <printfFixed>
        if(driver->currentTune.powerB != -127) {
 8008b62:	f995 2011 	ldrsb.w	r2, [r5, #17]
 8008b66:	f112 0f7f 	cmn.w	r2, #127	; 0x7f
 8008b6a:	d06a      	beq.n	8008c42 <max2870StatusPrint+0x14e>
            chprintf(stdout, "%d dBm"SHELL_NEWLINE_STR, driver->currentTune.powerB);
 8008b6c:	4620      	mov	r0, r4
 8008b6e:	4951      	ldr	r1, [pc, #324]	; (8008cb4 <max2870StatusPrint+0x1c0>)
 8008b70:	f7ff fded 	bl	800874e <chprintf>
        } else {
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
        }
        if(driver->currentTune.isLocked) {
 8008b74:	7f2b      	ldrb	r3, [r5, #28]
 8008b76:	b14b      	cbz	r3, 8008b8c <max2870StatusPrint+0x98>
            printfFixed(stdout, 30, "Lock Time:");
 8008b78:	211e      	movs	r1, #30
 8008b7a:	4a50      	ldr	r2, [pc, #320]	; (8008cbc <max2870StatusPrint+0x1c8>)
 8008b7c:	4620      	mov	r0, r4
 8008b7e:	f7ff ff93 	bl	8008aa8 <printfFixed>
            chprintf(stdout, "%u cycles"SHELL_NEWLINE_STR, driver->currentTune.lockTime);
 8008b82:	4620      	mov	r0, r4
 8008b84:	7eea      	ldrb	r2, [r5, #27]
 8008b86:	494e      	ldr	r1, [pc, #312]	; (8008cc0 <max2870StatusPrint+0x1cc>)
 8008b88:	f7ff fde1 	bl	800874e <chprintf>
        }
        printfFixed(stdout, 30, "PFD Frequency:");
 8008b8c:	211e      	movs	r1, #30
 8008b8e:	4a4d      	ldr	r2, [pc, #308]	; (8008cc4 <max2870StatusPrint+0x1d0>)
 8008b90:	4620      	mov	r0, r4
 8008b92:	f7ff ff89 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u kHz"SHELL_NEWLINE_STR, driver->pfdFrequency/1000);
 8008b96:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008b9a:	f8d5 20b8 	ldr.w	r2, [r5, #184]	; 0xb8
 8008b9e:	4943      	ldr	r1, [pc, #268]	; (8008cac <max2870StatusPrint+0x1b8>)
 8008ba0:	fbb2 f2f3 	udiv	r2, r2, r3
 8008ba4:	4620      	mov	r0, r4
 8008ba6:	f7ff fdd2 	bl	800874e <chprintf>
        printfFixed(stdout, 30, "Step Frequency:");
 8008baa:	211e      	movs	r1, #30
 8008bac:	4a46      	ldr	r2, [pc, #280]	; (8008cc8 <max2870StatusPrint+0x1d4>)
 8008bae:	4620      	mov	r0, r4
 8008bb0:	f7ff ff7a 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u Hz"SHELL_NEWLINE_STR, driver->config->stepFrequency);
 8008bb4:	682b      	ldr	r3, [r5, #0]
 8008bb6:	4945      	ldr	r1, [pc, #276]	; (8008ccc <max2870StatusPrint+0x1d8>)
 8008bb8:	699a      	ldr	r2, [r3, #24]
 8008bba:	4620      	mov	r0, r4
 8008bbc:	f7ff fdc7 	bl	800874e <chprintf>
        printfFixed(stdout, 30, "BS Divider:");
 8008bc0:	211e      	movs	r1, #30
 8008bc2:	4a43      	ldr	r2, [pc, #268]	; (8008cd0 <max2870StatusPrint+0x1dc>)
 8008bc4:	4620      	mov	r0, r4
 8008bc6:	f7ff ff6f 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->bsValue);
 8008bca:	f8b5 20c4 	ldrh.w	r2, [r5, #196]	; 0xc4
 8008bce:	4941      	ldr	r1, [pc, #260]	; (8008cd4 <max2870StatusPrint+0x1e0>)
 8008bd0:	4620      	mov	r0, r4
 8008bd2:	f7ff fdbc 	bl	800874e <chprintf>
        printfFixed(stdout, 30, "Reload Counter:");
 8008bd6:	211e      	movs	r1, #30
 8008bd8:	4a3f      	ldr	r2, [pc, #252]	; (8008cd8 <max2870StatusPrint+0x1e4>)
 8008bda:	4620      	mov	r0, r4
 8008bdc:	f7ff ff64 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->pllMonReloadCounter);
 8008be0:	f895 20e4 	ldrb.w	r2, [r5, #228]	; 0xe4
 8008be4:	493b      	ldr	r1, [pc, #236]	; (8008cd4 <max2870StatusPrint+0x1e0>)
 8008be6:	4620      	mov	r0, r4
 8008be8:	f7ff fdb1 	bl	800874e <chprintf>

        printfFixed(stdout, 30, "Current VCO Band From Cache:");
 8008bec:	211e      	movs	r1, #30
 8008bee:	4a3b      	ldr	r2, [pc, #236]	; (8008cdc <max2870StatusPrint+0x1e8>)
 8008bf0:	4620      	mov	r0, r4
 8008bf2:	f7ff ff59 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, !driver->currentTune.usedVCOAutotune);
 8008bf6:	7f6a      	ldrb	r2, [r5, #29]
 8008bf8:	4936      	ldr	r1, [pc, #216]	; (8008cd4 <max2870StatusPrint+0x1e0>)
 8008bfa:	f082 0201 	eor.w	r2, r2, #1
 8008bfe:	4620      	mov	r0, r4
 8008c00:	f7ff fda5 	bl	800874e <chprintf>
        printfFixed(stdout, 30, "Current VCO Band:");
 8008c04:	211e      	movs	r1, #30
 8008c06:	4a36      	ldr	r2, [pc, #216]	; (8008ce0 <max2870StatusPrint+0x1ec>)
 8008c08:	4620      	mov	r0, r4
 8008c0a:	f7ff ff4d 	bl	8008aa8 <printfFixed>
        chprintf(stdout, "%u"SHELL_NEWLINE_STR, driver->currentTune.usedVCO);
 8008c0e:	7e6a      	ldrb	r2, [r5, #25]
 8008c10:	4930      	ldr	r1, [pc, #192]	; (8008cd4 <max2870StatusPrint+0x1e0>)
 8008c12:	4620      	mov	r0, r4
 8008c14:	f7ff fd9b 	bl	800874e <chprintf>

        printfFixed(stdout, 30, "Current VCO Tuning Voltage:");
 8008c18:	211e      	movs	r1, #30
 8008c1a:	4620      	mov	r0, r4
 8008c1c:	4a31      	ldr	r2, [pc, #196]	; (8008ce4 <max2870StatusPrint+0x1f0>)
 8008c1e:	f7ff ff43 	bl	8008aa8 <printfFixed>
        switch(driver->currentTune.adcVoltage) {
 8008c22:	7eab      	ldrb	r3, [r5, #26]
 8008c24:	2b06      	cmp	r3, #6
 8008c26:	d835      	bhi.n	8008c94 <max2870StatusPrint+0x1a0>
 8008c28:	e8df f003 	tbb	[pc, r3]
 8008c2c:	2e2e2c10 	.word	0x2e2e2c10
 8008c30:	3030      	.short	0x3030
 8008c32:	32          	.byte	0x32
 8008c33:	00          	.byte	0x00
            chprintf(stdout, "PLL UNLOCK!!!"SHELL_NEWLINE_STR);
 8008c34:	492c      	ldr	r1, [pc, #176]	; (8008ce8 <max2870StatusPrint+0x1f4>)
 8008c36:	e76c      	b.n	8008b12 <max2870StatusPrint+0x1e>
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
 8008c38:	4620      	mov	r0, r4
 8008c3a:	492c      	ldr	r1, [pc, #176]	; (8008cec <max2870StatusPrint+0x1f8>)
 8008c3c:	f7ff fd87 	bl	800874e <chprintf>
 8008c40:	e78a      	b.n	8008b58 <max2870StatusPrint+0x64>
            chprintf(stdout, "Off"SHELL_NEWLINE_STR);
 8008c42:	4620      	mov	r0, r4
 8008c44:	4929      	ldr	r1, [pc, #164]	; (8008cec <max2870StatusPrint+0x1f8>)
 8008c46:	f7ff fd82 	bl	800874e <chprintf>
 8008c4a:	e793      	b.n	8008b74 <max2870StatusPrint+0x80>
            case 0:
                chprintf(stdout, "0.2");
 8008c4c:	4928      	ldr	r1, [pc, #160]	; (8008cf0 <max2870StatusPrint+0x1fc>)
                break;
            case 6:
                chprintf(stdout, "2.3");
                break;
            default:
                chprintf(stdout, "3");
 8008c4e:	4620      	mov	r0, r4
 8008c50:	f7ff fd7d 	bl	800874e <chprintf>
                break;
        }
        chprintf(stdout, "V"SHELL_NEWLINE_STR"Registers:"SHELL_NEWLINE_STR);
 8008c54:	4620      	mov	r0, r4
 8008c56:	4927      	ldr	r1, [pc, #156]	; (8008cf4 <max2870StatusPrint+0x200>)
 8008c58:	f7ff fd79 	bl	800874e <chprintf>
        for(int i=0; i<7; i++) {
 8008c5c:	2600      	movs	r6, #0
            chprintf(stdout, "\t%u: %08x"SHELL_NEWLINE_STR, i, driver->registers[i]);
 8008c5e:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8008cf8 <max2870StatusPrint+0x204>
 8008c62:	f105 07c8 	add.w	r7, r5, #200	; 0xc8
 8008c66:	4632      	mov	r2, r6
 8008c68:	4641      	mov	r1, r8
 8008c6a:	4620      	mov	r0, r4
 8008c6c:	f857 3b04 	ldr.w	r3, [r7], #4
        for(int i=0; i<7; i++) {
 8008c70:	3601      	adds	r6, #1
            chprintf(stdout, "\t%u: %08x"SHELL_NEWLINE_STR, i, driver->registers[i]);
 8008c72:	f7ff fd6c 	bl	800874e <chprintf>
        for(int i=0; i<7; i++) {
 8008c76:	2e07      	cmp	r6, #7
 8008c78:	d1f5      	bne.n	8008c66 <max2870StatusPrint+0x172>
    if(enable) {
 8008c7a:	4628      	mov	r0, r5
        }
    } else {
        chprintf(stdout, "Low power mode"SHELL_NEWLINE_STR);
    }
    max2870SpiState(driver, false);
}
 8008c7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8008c80:	f7ff bd20 	b.w	80086c4 <max2870SpiState.part.0>
                chprintf(stdout, "0.6");
 8008c84:	491d      	ldr	r1, [pc, #116]	; (8008cfc <max2870StatusPrint+0x208>)
 8008c86:	e7e2      	b.n	8008c4e <max2870StatusPrint+0x15a>
                chprintf(stdout, "1");
 8008c88:	491d      	ldr	r1, [pc, #116]	; (8008d00 <max2870StatusPrint+0x20c>)
 8008c8a:	e7e0      	b.n	8008c4e <max2870StatusPrint+0x15a>
                chprintf(stdout, "1.7");
 8008c8c:	491d      	ldr	r1, [pc, #116]	; (8008d04 <max2870StatusPrint+0x210>)
 8008c8e:	e7de      	b.n	8008c4e <max2870StatusPrint+0x15a>
                chprintf(stdout, "2.3");
 8008c90:	491d      	ldr	r1, [pc, #116]	; (8008d08 <max2870StatusPrint+0x214>)
 8008c92:	e7dc      	b.n	8008c4e <max2870StatusPrint+0x15a>
                chprintf(stdout, "3");
 8008c94:	491d      	ldr	r1, [pc, #116]	; (8008d0c <max2870StatusPrint+0x218>)
 8008c96:	e7da      	b.n	8008c4e <max2870StatusPrint+0x15a>
        chprintf(stdout, "Low power mode"SHELL_NEWLINE_STR);
 8008c98:	4620      	mov	r0, r4
 8008c9a:	491d      	ldr	r1, [pc, #116]	; (8008d10 <max2870StatusPrint+0x21c>)
 8008c9c:	f7ff fd57 	bl	800874e <chprintf>
 8008ca0:	e7eb      	b.n	8008c7a <max2870StatusPrint+0x186>
 8008ca2:	bf00      	nop
 8008ca4:	0800be46 	.word	0x0800be46
 8008ca8:	0800be63 	.word	0x0800be63
 8008cac:	0800c13a 	.word	0x0800c13a
 8008cb0:	0800be7a 	.word	0x0800be7a
 8008cb4:	0800be8a 	.word	0x0800be8a
 8008cb8:	0800be99 	.word	0x0800be99
 8008cbc:	0800bea9 	.word	0x0800bea9
 8008cc0:	0800beb4 	.word	0x0800beb4
 8008cc4:	0800bec0 	.word	0x0800bec0
 8008cc8:	0800becf 	.word	0x0800becf
 8008ccc:	0800bedf 	.word	0x0800bedf
 8008cd0:	0800bee7 	.word	0x0800bee7
 8008cd4:	0800c18d 	.word	0x0800c18d
 8008cd8:	0800bef3 	.word	0x0800bef3
 8008cdc:	0800bf03 	.word	0x0800bf03
 8008ce0:	0800bf20 	.word	0x0800bf20
 8008ce4:	0800bf32 	.word	0x0800bf32
 8008ce8:	0800be53 	.word	0x0800be53
 8008cec:	0800be93 	.word	0x0800be93
 8008cf0:	0800bf4e 	.word	0x0800bf4e
 8008cf4:	0800bf5e 	.word	0x0800bf5e
 8008cf8:	0800bf6e 	.word	0x0800bf6e
 8008cfc:	0800bf52 	.word	0x0800bf52
 8008d00:	0800bbc0 	.word	0x0800bbc0
 8008d04:	0800bf56 	.word	0x0800bf56
 8008d08:	0800bf5a 	.word	0x0800bf5a
 8008d0c:	0800bf5c 	.word	0x0800bf5c
 8008d10:	0800bf7a 	.word	0x0800bf7a

08008d14 <gpioCPUStatus>:
{
 8008d14:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8008d18:	460d      	mov	r5, r1
    chprintf(chp, "\tDriver: HAL (MM 0x%08x)"SHELL_NEWLINE_STR, (uint32_t)driver->driver);
 8008d1a:	6802      	ldr	r2, [r0, #0]
{
 8008d1c:	4606      	mov	r6, r0
    chprintf(chp, "\tDriver: HAL (MM 0x%08x)"SHELL_NEWLINE_STR, (uint32_t)driver->driver);
 8008d1e:	4915      	ldr	r1, [pc, #84]	; (8008d74 <gpioCPUStatus+0x60>)
 8008d20:	4628      	mov	r0, r5
 8008d22:	f7ff fd14 	bl	800874e <chprintf>
 8008d26:	2400      	movs	r4, #0
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008d28:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8008d78 <gpioCPUStatus+0x64>
 8008d2c:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8008d7c <gpioCPUStatus+0x68>
        printfFixed(chp, 32, "\tPin %u (%s):",
 8008d30:	4f13      	ldr	r7, [pc, #76]	; (8008d80 <gpioCPUStatus+0x6c>)
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008d32:	4621      	mov	r1, r4
 8008d34:	4630      	mov	r0, r6
 8008d36:	f7fd f87b 	bl	8005e30 <gpioCPUGetPinMode>
    switch(mode) {
 8008d3a:	1e43      	subs	r3, r0, #1
 8008d3c:	b2db      	uxtb	r3, r3
 8008d3e:	2b10      	cmp	r3, #16
    uint8_t mode = gpioCPUGetPinMode(driver, pin);
 8008d40:	bf8c      	ite	hi
 8008d42:	4643      	movhi	r3, r8
 8008d44:	f859 3023 	ldrls.w	r3, [r9, r3, lsl #2]
        printfFixed(chp, 32, "\tPin %u (%s):",
 8008d48:	463a      	mov	r2, r7
 8008d4a:	2120      	movs	r1, #32
 8008d4c:	9300      	str	r3, [sp, #0]
 8008d4e:	4628      	mov	r0, r5
 8008d50:	4623      	mov	r3, r4
 8008d52:	f7ff fea9 	bl	8008aa8 <printfFixed>
        chprintf(chp,  "%u"SHELL_NEWLINE_STR, palReadPad((ioportid_t)driver->driver, i));
 8008d56:	6833      	ldr	r3, [r6, #0]
 8008d58:	4628      	mov	r0, r5
 8008d5a:	689a      	ldr	r2, [r3, #8]
 8008d5c:	4909      	ldr	r1, [pc, #36]	; (8008d84 <gpioCPUStatus+0x70>)
 8008d5e:	40e2      	lsrs	r2, r4
 8008d60:	f002 0201 	and.w	r2, r2, #1
    for(uint8_t i=0; i<16; i++) {
 8008d64:	3401      	adds	r4, #1
        chprintf(chp,  "%u"SHELL_NEWLINE_STR, palReadPad((ioportid_t)driver->driver, i));
 8008d66:	f7ff fcf2 	bl	800874e <chprintf>
    for(uint8_t i=0; i<16; i++) {
 8008d6a:	2c10      	cmp	r4, #16
 8008d6c:	d1e1      	bne.n	8008d32 <gpioCPUStatus+0x1e>
}
 8008d6e:	b003      	add	sp, #12
 8008d70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008d74:	0800bf8b 	.word	0x0800bf8b
 8008d78:	0800bab6 	.word	0x0800bab6
 8008d7c:	0800c7fc 	.word	0x0800c7fc
 8008d80:	0800bfa6 	.word	0x0800bfa6
 8008d84:	0800c18d 	.word	0x0800c18d

08008d88 <syslog>:
};
static const BaseSequentialStream syslogStream = {.vmt = &syslogVMT};


void syslog(const char *format, ...)
{
 8008d88:	b40f      	push	{r0, r1, r2, r3}
 8008d8a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    va_list args;
    va_start(args, format);

    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d8c:	4d16      	ldr	r5, [pc, #88]	; (8008de8 <syslog+0x60>)
{
 8008d8e:	ab06      	add	r3, sp, #24
 8008d90:	f853 6b04 	ldr.w	r6, [r3], #4
    queue->lenHeaderStart = queue->writePtr;
 8008d94:	4c15      	ldr	r4, [pc, #84]	; (8008dec <syslog+0x64>)
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d96:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008d9a:	6828      	ldr	r0, [r5, #0]
    va_start(args, format);
 8008d9c:	9301      	str	r3, [sp, #4]
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8008d9e:	f7fc fb4b 	bl	8005438 <xQueueSemaphoreTake>
 8008da2:	6923      	ldr	r3, [r4, #16]
    packetQueueWriteByte(queue, 0x00);
 8008da4:	2000      	movs	r0, #0
    queue->lenHeaderStart = queue->writePtr;
 8008da6:	61e3      	str	r3, [r4, #28]
    packetQueueWriteByte(queue, 0x00);
 8008da8:	f7fd f8e4 	bl	8005f74 <packetQueueWriteByte.constprop.0>
    packetQueueWriteByte(queue, 0x00);
 8008dac:	2000      	movs	r0, #0
 8008dae:	f7fd f8e1 	bl	8005f74 <packetQueueWriteByte.constprop.0>
    queue->pktLen = 0;
 8008db2:	2300      	movs	r3, #0
 8008db4:	61a3      	str	r3, [r4, #24]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8008db6:	f7fd f8a9 	bl	8005f0c <vPortValidateInterruptPriority>
    packetQueueStartWritePacket(&syslogQueue);
    chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] ", osalOsGetSystemTimeX());
 8008dba:	4c0d      	ldr	r4, [pc, #52]	; (8008df0 <syslog+0x68>)
		xReturn = xTickCount;
 8008dbc:	4b0d      	ldr	r3, [pc, #52]	; (8008df4 <syslog+0x6c>)
 8008dbe:	4620      	mov	r0, r4
 8008dc0:	681a      	ldr	r2, [r3, #0]
 8008dc2:	490d      	ldr	r1, [pc, #52]	; (8008df8 <syslog+0x70>)
 8008dc4:	f7ff fcc3 	bl	800874e <chprintf>
    chvprintf((BaseSequentialStream*)&syslogStream, format, args);
 8008dc8:	4631      	mov	r1, r6
 8008dca:	9a01      	ldr	r2, [sp, #4]
 8008dcc:	4620      	mov	r0, r4
 8008dce:	f7fd fe8d 	bl	8006aec <chvprintf>
    packetQueueEndWritePacket(&syslogQueue);
 8008dd2:	f7fd f923 	bl	800601c <packetQueueEndWritePacket.constprop.0>
    xSemaphoreGive(syslogSemaphore);
 8008dd6:	6828      	ldr	r0, [r5, #0]
 8008dd8:	f7ff fb54 	bl	8008484 <xQueueGenericSend.constprop.0>

    va_end(args);
}
 8008ddc:	b002      	add	sp, #8
 8008dde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8008de2:	b004      	add	sp, #16
 8008de4:	4770      	bx	lr
 8008de6:	bf00      	nop
 8008de8:	20001334 	.word	0x20001334
 8008dec:	20001310 	.word	0x20001310
 8008df0:	0800cbbc 	.word	0x0800cbbc
 8008df4:	20001648 	.word	0x20001648
 8008df8:	0800bfb4 	.word	0x0800bfb4

08008dfc <shellTerminationCallback>:
			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 8008dfc:	4b0e      	ldr	r3, [pc, #56]	; (8008e38 <shellTerminationCallback+0x3c>)
{
 8008dfe:	b570      	push	{r4, r5, r6, lr}
 8008e00:	681b      	ldr	r3, [r3, #0]
			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
 8008e02:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
    if(activeShell) {
 8008e04:	b1bc      	cbz	r4, 8008e36 <shellTerminationCallback+0x3a>
        if(activeShell->shellCfg.sc_histbuf) {
 8008e06:	68e0      	ldr	r0, [r4, #12]
 8008e08:	b108      	cbz	r0, 8008e0e <shellTerminationCallback+0x12>
            vPortFree(activeShell->shellCfg.sc_histbuf);
 8008e0a:	f7fc fa7f 	bl	800530c <vPortFree>
        chprintf(activeShell->stream, "Shell 0x%08x closed.", activeShell);
 8008e0e:	4622      	mov	r2, r4
 8008e10:	490a      	ldr	r1, [pc, #40]	; (8008e3c <shellTerminationCallback+0x40>)
 8008e12:	6960      	ldr	r0, [r4, #20]
 8008e14:	f7ff fc9b 	bl	800874e <chprintf>
        syslog("Shell 0x%08x closed.", activeShell);
 8008e18:	4808      	ldr	r0, [pc, #32]	; (8008e3c <shellTerminationCallback+0x40>)
 8008e1a:	4621      	mov	r1, r4
 8008e1c:	f7ff ffb4 	bl	8008d88 <syslog>
        void *param = activeShell->param;
 8008e20:	e9d4 5606 	ldrd	r5, r6, [r4, #24]
        vPortFree(activeShell);
 8008e24:	4620      	mov	r0, r4
 8008e26:	f7fc fa71 	bl	800530c <vPortFree>
        if(callback) {
 8008e2a:	b125      	cbz	r5, 8008e36 <shellTerminationCallback+0x3a>
            callback(param);
 8008e2c:	4630      	mov	r0, r6
 8008e2e:	462b      	mov	r3, r5
}
 8008e30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            callback(param);
 8008e34:	4718      	bx	r3
}
 8008e36:	bd70      	pop	{r4, r5, r6, pc}
 8008e38:	200011a8 	.word	0x200011a8
 8008e3c:	0800bfbd 	.word	0x0800bfbd

08008e40 <max2870TuneNoLock>:
{
 8008e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008e44:	460c      	mov	r4, r1
 8008e46:	b08b      	sub	sp, #44	; 0x2c
 8008e48:	4605      	mov	r5, r0
    uint32_t registers[6] = {};
 8008e4a:	2218      	movs	r2, #24
 8008e4c:	2100      	movs	r1, #0
 8008e4e:	a804      	add	r0, sp, #16
 8008e50:	f002 fcdc 	bl	800b80c <memset>
    uint64_t frequency = tune->frequency;
 8008e54:	e9d4 6800 	ldrd	r6, r8, [r4]
    if(frequency == 0) {
 8008e58:	ea56 0308 	orrs.w	r3, r6, r8
 8008e5c:	d107      	bne.n	8008e6e <max2870TuneNoLock+0x2e>
        max2870Disable(driver);
 8008e5e:	4628      	mov	r0, r5
 8008e60:	f7ff fad6 	bl	8008410 <max2870Disable>
        return TUNE_OK;
 8008e64:	2700      	movs	r7, #0
}
 8008e66:	4638      	mov	r0, r7
 8008e68:	b00b      	add	sp, #44	; 0x2c
 8008e6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(frequency > MAX2870_VCO_MAX_FREQUENCY || frequency < MAX2870_VCO_MIN_FREQUENCY/128) {
 8008e6e:	4bae      	ldr	r3, [pc, #696]	; (8009128 <max2870TuneNoLock+0x2e8>)
 8008e70:	49ae      	ldr	r1, [pc, #696]	; (800912c <max2870TuneNoLock+0x2ec>)
 8008e72:	18f3      	adds	r3, r6, r3
 8008e74:	f168 0200 	sbc.w	r2, r8, #0
 8008e78:	4299      	cmp	r1, r3
 8008e7a:	f04f 0301 	mov.w	r3, #1
 8008e7e:	4193      	sbcs	r3, r2
 8008e80:	f0c0 81c5 	bcc.w	800920e <max2870TuneNoLock+0x3ce>
 8008e84:	2700      	movs	r7, #0
    while(frequency < MAX2870_VCO_MIN_FREQUENCY) {
 8008e86:	463b      	mov	r3, r7
 8008e88:	4aa9      	ldr	r2, [pc, #676]	; (8009130 <max2870TuneNoLock+0x2f0>)
 8008e8a:	42b2      	cmp	r2, r6
 8008e8c:	eb73 0008 	sbcs.w	r0, r3, r8
 8008e90:	f107 0101 	add.w	r1, r7, #1
 8008e94:	f080 80fd 	bcs.w	8009092 <max2870TuneNoLock+0x252>
    uint32_t steps = frequency / driver->config->stepFrequency;
 8008e98:	f8d5 a000 	ldr.w	sl, [r5]
 8008e9c:	2300      	movs	r3, #0
 8008e9e:	f8da 2018 	ldr.w	r2, [sl, #24]
 8008ea2:	4630      	mov	r0, r6
 8008ea4:	4641      	mov	r1, r8
 8008ea6:	f7fa fc91 	bl	80037cc <__aeabi_uldivmod>
    uint32_t pllN = steps / driver->fracDivider;
 8008eaa:	f8b5 90bc 	ldrh.w	r9, [r5, #188]	; 0xbc
    if(pllN < 16 || pllN > 4091) {
 8008eae:	f640 73eb 	movw	r3, #4075	; 0xfeb
    uint32_t pllN = steps / driver->fracDivider;
 8008eb2:	fbb0 f1f9 	udiv	r1, r0, r9
    if(pllN < 16 || pllN > 4091) {
 8008eb6:	f1a1 0c10 	sub.w	ip, r1, #16
 8008eba:	459c      	cmp	ip, r3
    uint32_t pllN = steps / driver->fracDivider;
 8008ebc:	464a      	mov	r2, r9
    uint32_t steps = frequency / driver->config->stepFrequency;
 8008ebe:	9001      	str	r0, [sp, #4]
    if(pllN < 16 || pllN > 4091) {
 8008ec0:	f200 81a8 	bhi.w	8009214 <max2870TuneNoLock+0x3d4>
    uint16_t pllFracF = steps - (pllN * driver->fracDivider);
 8008ec4:	fb01 0019 	mls	r0, r1, r9, r0
 8008ec8:	b280      	uxth	r0, r0
    if(pllFracF) {
 8008eca:	2800      	cmp	r0, #0
 8008ecc:	f000 80ef 	beq.w	80090ae <max2870TuneNoLock+0x26e>
        uint16_t pllFracGcd = gcd(pllFracF, pllFracM);
 8008ed0:	4603      	mov	r3, r0
    if (v == 0) return u;
 8008ed2:	f1b9 0f00 	cmp.w	r9, #0
 8008ed6:	d018      	beq.n	8008f0a <max2870TuneNoLock+0xca>
    for (shift = 0; ((u | v) & 1) == 0; ++shift) {
 8008ed8:	f04f 0c00 	mov.w	ip, #0
 8008edc:	ea43 0e02 	orr.w	lr, r3, r2
 8008ee0:	f01e 0f01 	tst.w	lr, #1
 8008ee4:	f000 80da 	beq.w	800909c <max2870TuneNoLock+0x25c>
    while ((u & 1) == 0) {
 8008ee8:	f013 0f01 	tst.w	r3, #1
 8008eec:	f000 80db 	beq.w	80090a6 <max2870TuneNoLock+0x266>
        while ((v & 1) == 0) {
 8008ef0:	f012 0f01 	tst.w	r2, #1
 8008ef4:	f000 80d9 	beq.w	80090aa <max2870TuneNoLock+0x26a>
        if (u > v) {
 8008ef8:	429a      	cmp	r2, r3
 8008efa:	bf3e      	ittt	cc
 8008efc:	469e      	movcc	lr, r3
 8008efe:	4613      	movcc	r3, r2
 8008f00:	4672      	movcc	r2, lr
    } while (v != 0);
 8008f02:	1ad2      	subs	r2, r2, r3
 8008f04:	d1f4      	bne.n	8008ef0 <max2870TuneNoLock+0xb0>
    return u << shift;
 8008f06:	fa03 f30c 	lsl.w	r3, r3, ip
 8008f0a:	b29b      	uxth	r3, r3
        pllFracM /= pllFracGcd;
 8008f0c:	fbb9 f9f3 	udiv	r9, r9, r3
        pllFracF /= pllFracGcd;
 8008f10:	fbb0 f0f3 	udiv	r0, r0, r3
        registers[1] |= _BV(MAX2870_REG1_CPL_OFFSET);
 8008f14:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8008f18:	9305      	str	r3, [sp, #20]
    registers[0] |= pllN << MAX2870_REG0_N_OFFSET;
 8008f1a:	9b04      	ldr	r3, [sp, #16]
    registers[2] |= driver->refDividerRegister2;
 8008f1c:	f8d5 20c0 	ldr.w	r2, [r5, #192]	; 0xc0
    registers[0] |= pllN << MAX2870_REG0_N_OFFSET;
 8008f20:	ea43 33c1 	orr.w	r3, r3, r1, lsl #15
    registers[0] |= pllFracF << MAX2870_REG0_FRAC_OFFSET;
 8008f24:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
    registers[1] |= pllFracM << MAX2870_REG1_M_OFFSET;
 8008f28:	9b05      	ldr	r3, [sp, #20]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008f2a:	b2ff      	uxtb	r7, r7
    registers[1] |= pllFracM << MAX2870_REG1_M_OFFSET;
 8008f2c:	ea43 03c9 	orr.w	r3, r3, r9, lsl #3
 8008f30:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008f34:	9305      	str	r3, [sp, #20]
    registers[2] |= driver->refDividerRegister2;
 8008f36:	9b06      	ldr	r3, [sp, #24]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008f38:	ea4f 5b07 	mov.w	fp, r7, lsl #20
    registers[2] |= driver->refDividerRegister2;
 8008f3c:	4313      	orrs	r3, r2
    registers[2] |= 0x6 <<  MAX2870_REG2_MUX_OFFSET;
 8008f3e:	f043 52c0 	orr.w	r2, r3, #402653184	; 0x18000000
 8008f42:	9206      	str	r2, [sp, #24]
    if(!driver->config->invertingLoopFilter) {
 8008f44:	f89a 200a 	ldrb.w	r2, [sl, #10]
    registers[0] |= pllFracF << MAX2870_REG0_FRAC_OFFSET;
 8008f48:	9004      	str	r0, [sp, #16]
    registers[4] |= outDivide << MAX2870_REG4_DIVA_OFFSET;
 8008f4a:	f8cd b020 	str.w	fp, [sp, #32]
    if(!driver->config->invertingLoopFilter) {
 8008f4e:	b922      	cbnz	r2, 8008f5a <max2870TuneNoLock+0x11a>
        registers[2] |= _BV(MAX2870_REG2_PDP_OFFSET);
 8008f50:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8008f54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008f58:	9306      	str	r3, [sp, #24]
    registers[2] |= driver->config->chargePumpCurrent << MAX2870_REG2_CP_OFFSET;
 8008f5a:	f89a 200b 	ldrb.w	r2, [sl, #11]
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008f5e:	f89a 100c 	ldrb.w	r1, [sl, #12]
    registers[2] |= driver->config->chargePumpCurrent << MAX2870_REG2_CP_OFFSET;
 8008f62:	0253      	lsls	r3, r2, #9
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008f64:	ea43 7341 	orr.w	r3, r3, r1, lsl #29
 8008f68:	9906      	ldr	r1, [sp, #24]
    if(driver->pfdFrequency > 32000000) {
 8008f6a:	4872      	ldr	r0, [pc, #456]	; (8009134 <max2870TuneNoLock+0x2f4>)
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008f6c:	430b      	orrs	r3, r1
    if(driver->pfdFrequency > 32000000) {
 8008f6e:	f8d5 10b8 	ldr.w	r1, [r5, #184]	; 0xb8
    registers[2] |= driver->config->spurMode << MAX2870_REG2_SDN_OFFSET;
 8008f72:	9306      	str	r3, [sp, #24]
    if(driver->pfdFrequency > 32000000) {
 8008f74:	4281      	cmp	r1, r0
    if(tune->fastLockDurationMicroseconds) {
 8008f76:	68e0      	ldr	r0, [r4, #12]
        registers[2] |= _BV(MAX2870_REG2_LDS_OFFSET);
 8008f78:	bf84      	itt	hi
 8008f7a:	f043 4300 	orrhi.w	r3, r3, #2147483648	; 0x80000000
 8008f7e:	9306      	strhi	r3, [sp, #24]
    if(tune->fastLockDurationMicroseconds) {
 8008f80:	b1a0      	cbz	r0, 8008fac <max2870TuneNoLock+0x16c>
        if(driver->config->chargePumpCurrent) {
 8008f82:	2a00      	cmp	r2, #0
 8008f84:	f040 8149 	bne.w	800921a <max2870TuneNoLock+0x3da>
        uint32_t tmp = (uint64_t)driver->pfdFrequency * (uint64_t)tune->fastLockDurationMicroseconds / 1000000;
 8008f88:	2300      	movs	r3, #0
 8008f8a:	fba1 0100 	umull	r0, r1, r1, r0
 8008f8e:	4a6a      	ldr	r2, [pc, #424]	; (8009138 <max2870TuneNoLock+0x2f8>)
 8008f90:	f7fa fc1c 	bl	80037cc <__aeabi_uldivmod>
        tmp /= pllFracM;
 8008f94:	fbb0 f3f9 	udiv	r3, r0, r9
        if(tmp>4095) {
 8008f98:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8008f9c:	f080 808f 	bcs.w	80090be <max2870TuneNoLock+0x27e>
        if(tmp) {
 8008fa0:	4581      	cmp	r9, r0
 8008fa2:	d803      	bhi.n	8008fac <max2870TuneNoLock+0x16c>
            registers[3] |= tmp << MAX2870_REG3_CDIV_OFFSET;
 8008fa4:	00db      	lsls	r3, r3, #3
 8008fa6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008faa:	9307      	str	r3, [sp, #28]
    if(!tune->outBfundamental) {
 8008fac:	7aa3      	ldrb	r3, [r4, #10]
 8008fae:	b913      	cbnz	r3, 8008fb6 <max2870TuneNoLock+0x176>
        registers[4] |= _BV(MAX2870_REG4_BDIV_OFFSET);
 8008fb0:	f44b 7300 	orr.w	r3, fp, #512	; 0x200
 8008fb4:	9308      	str	r3, [sp, #32]
    registers[4] |= (driver->bsValue & 0xFF) << MAX2870_REG4_BS_OFFSET;
 8008fb6:	f8b5 20c4 	ldrh.w	r2, [r5, #196]	; 0xc4
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008fba:	4860      	ldr	r0, [pc, #384]	; (800913c <max2870TuneNoLock+0x2fc>)
    registers[4] |= (driver->bsValue & 0xFF) << MAX2870_REG4_BS_OFFSET;
 8008fbc:	0313      	lsls	r3, r2, #12
 8008fbe:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
    registers[4] |= (driver->bsValue >> 8) << MAX2870_REG4_BS_MSB_OFFSET;
 8008fc2:	0a12      	lsrs	r2, r2, #8
 8008fc4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8008fc8:	9a08      	ldr	r2, [sp, #32]
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008fca:	1830      	adds	r0, r6, r0
    registers[4] |= (driver->bsValue >> 8) << MAX2870_REG4_BS_MSB_OFFSET;
 8008fcc:	ea43 0302 	orr.w	r3, r3, r2
    registers[4] |= _BV(MAX2870_REG4_FB_OFFSET);
 8008fd0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8008fd4:	9308      	str	r3, [sp, #32]
    uint16_t vcoIndex = (frequency - MAX2870_VCO_MIN_FREQUENCY) / MAX2870_VCO_INCREMENT;
 8008fd6:	f168 0100 	sbc.w	r1, r8, #0
 8008fda:	a351      	add	r3, pc, #324	; (adr r3, 8009120 <max2870TuneNoLock+0x2e0>)
 8008fdc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008fe0:	f7fa fbf4 	bl	80037cc <__aeabi_uldivmod>
    if((driver->vcoCache[vcoIndex] & 0x80) && !tune->useVCOAutotune) {
 8008fe4:	eb05 0900 	add.w	r9, r5, r0
 8008fe8:	f999 3020 	ldrsb.w	r3, [r9, #32]
 8008fec:	f899 2020 	ldrb.w	r2, [r9, #32]
 8008ff0:	2b00      	cmp	r3, #0
 8008ff2:	da67      	bge.n	80090c4 <max2870TuneNoLock+0x284>
 8008ff4:	7c26      	ldrb	r6, [r4, #16]
 8008ff6:	b92e      	cbnz	r6, 8009004 <max2870TuneNoLock+0x1c4>
        registers[3] |= (driver->vcoCache[vcoIndex] & 0x3F) << MAX2870_REG3_VCO_OFFSET;
 8008ff8:	9b07      	ldr	r3, [sp, #28]
 8008ffa:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
        registers[3] |= _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 8008ffe:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8009002:	9307      	str	r3, [sp, #28]
    if(!driver->enabled) {
 8009004:	792b      	ldrb	r3, [r5, #4]
 8009006:	b99b      	cbnz	r3, 8009030 <max2870TuneNoLock+0x1f0>
        if(driver->config->gpioChipEnable != 0xffff) {
 8009008:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800900c:	f8ba 0008 	ldrh.w	r0, [sl, #8]
 8009010:	4298      	cmp	r0, r3
 8009012:	d005      	beq.n	8009020 <max2870TuneNoLock+0x1e0>
            gpioSetPin(driver->config->gpioChipEnable, true);
 8009014:	2101      	movs	r1, #1
 8009016:	f7fe fa89 	bl	800752c <gpioSetPin.isra.0>
            osalThreadSleepMilliseconds(20);
 800901a:	2014      	movs	r0, #20
 800901c:	f7fc f9b0 	bl	8005380 <vTaskDelay>
        max2870WriteAllRegisters(driver, registers, true);
 8009020:	4628      	mov	r0, r5
 8009022:	2201      	movs	r2, #1
 8009024:	a904      	add	r1, sp, #16
 8009026:	f7ff fa0d 	bl	8008444 <max2870WriteAllRegisters.isra.0>
        osalThreadSleepMilliseconds(20);
 800902a:	2014      	movs	r0, #20
 800902c:	f7fc f9a8 	bl	8005380 <vTaskDelay>
        *power = -4;
 8009030:	f04f 0afc 	mov.w	sl, #252	; 0xfc
        *power = 2;
 8009034:	f04f 0b02 	mov.w	fp, #2
    if(*power < -4) {
 8009038:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800903c:	1d18      	adds	r0, r3, #4
 800903e:	da43      	bge.n	80090c8 <max2870TuneNoLock+0x288>
        *power = -127;
 8009040:	2381      	movs	r3, #129	; 0x81
        return registerValue;
 8009042:	2200      	movs	r2, #0
        *power = -127;
 8009044:	7223      	strb	r3, [r4, #8]
        registers[4] |= max2870PowerToRegister(&tune->powerA) << MAX2870_REG4_APWR_OFFSET;
 8009046:	9b08      	ldr	r3, [sp, #32]
 8009048:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
    if(*power < -4) {
 800904c:	f994 2009 	ldrsb.w	r2, [r4, #9]
 8009050:	1d11      	adds	r1, r2, #4
 8009052:	da4f      	bge.n	80090f4 <max2870TuneNoLock+0x2b4>
        *power = -127;
 8009054:	2281      	movs	r2, #129	; 0x81
 8009056:	7262      	strb	r2, [r4, #9]
        return registerValue;
 8009058:	2200      	movs	r2, #0
        registers[4] |= max2870PowerToRegister(&tune->powerB) << MAX2870_REG4_BPWR_OFFSET;
 800905a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 800905e:	9308      	str	r3, [sp, #32]
        if(driver->pllMonReloadCounter >= 20) {
 8009060:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 8009064:	4628      	mov	r0, r5
        if(driver->pllMonReloadCounter >= 20) {
 8009066:	2b13      	cmp	r3, #19
            driver->pllMonReloadCounter = 0;
 8009068:	bf89      	itett	hi
 800906a:	2300      	movhi	r3, #0
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 800906c:	792a      	ldrbls	r2, [r5, #4]
            max2870WriteAllRegisters(driver, registers, true);
 800906e:	2201      	movhi	r2, #1
            driver->pllMonReloadCounter = 0;
 8009070:	f885 30e4 	strbhi.w	r3, [r5, #228]	; 0xe4
            max2870WriteAllRegisters(driver, registers, !driver->enabled);
 8009074:	bf98      	it	ls
 8009076:	f082 0201 	eorls.w	r2, r2, #1
 800907a:	a904      	add	r1, sp, #16
 800907c:	f7ff f9e2 	bl	8008444 <max2870WriteAllRegisters.isra.0>
    registerValue = _BV(2); /* Output enabled */
 8009080:	f04f 0800 	mov.w	r8, #0
            spiReceive(driver->config->spiPort, sizeof(lock), &lock);
 8009084:	682a      	ldr	r2, [r5, #0]
 8009086:	6810      	ldr	r0, [r2, #0]
  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));
 8009088:	2800      	cmp	r0, #0
 800908a:	d159      	bne.n	8009140 <max2870TuneNoLock+0x300>
 800908c:	f7fb fc92 	bl	80049b4 <vTaskEndScheduler>
 8009090:	e7fe      	b.n	8009090 <max2870TuneNoLock+0x250>
        frequency *= 2;
 8009092:	19b6      	adds	r6, r6, r6
 8009094:	460f      	mov	r7, r1
 8009096:	eb48 0808 	adc.w	r8, r8, r8
        outDivide++;
 800909a:	e6f6      	b.n	8008e8a <max2870TuneNoLock+0x4a>
        u >>= 1;
 800909c:	085b      	lsrs	r3, r3, #1
        v >>= 1;
 800909e:	0852      	lsrs	r2, r2, #1
    for (shift = 0; ((u | v) & 1) == 0; ++shift) {
 80090a0:	f10c 0c01 	add.w	ip, ip, #1
 80090a4:	e71a      	b.n	8008edc <max2870TuneNoLock+0x9c>
        u >>= 1;
 80090a6:	085b      	lsrs	r3, r3, #1
 80090a8:	e71e      	b.n	8008ee8 <max2870TuneNoLock+0xa8>
            v >>= 1;
 80090aa:	0852      	lsrs	r2, r2, #1
 80090ac:	e720      	b.n	8008ef0 <max2870TuneNoLock+0xb0>
        registers[0] |= _BV(MAX2870_REG0_INT_OFFSET);
 80090ae:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
        registers[1] |= _BV(MAX2870_REG1_CPOC_OFFSET);
 80090b2:	e9cd 3304 	strd	r3, r3, [sp, #16]
        registers[2] |= _BV(MAX2870_REG2_LDF_OFFSET);
 80090b6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80090ba:	9306      	str	r3, [sp, #24]
 80090bc:	e72d      	b.n	8008f1a <max2870TuneNoLock+0xda>
            tmp = 4095;
 80090be:	f640 73ff 	movw	r3, #4095	; 0xfff
 80090c2:	e76f      	b.n	8008fa4 <max2870TuneNoLock+0x164>
    bool vcoAutoTune = true;
 80090c4:	2601      	movs	r6, #1
 80090c6:	e79d      	b.n	8009004 <max2870TuneNoLock+0x1c4>
    if(*power >= 5) {
 80090c8:	2b04      	cmp	r3, #4
 80090ca:	dd03      	ble.n	80090d4 <max2870TuneNoLock+0x294>
        *power = 5;
 80090cc:	2305      	movs	r3, #5
        registerValue |= 3;
 80090ce:	2207      	movs	r2, #7
        *power = 5;
 80090d0:	7223      	strb	r3, [r4, #8]
        registerValue |= 3;
 80090d2:	e7b8      	b.n	8009046 <max2870TuneNoLock+0x206>
    } else if(*power >= 2) {
 80090d4:	2b01      	cmp	r3, #1
 80090d6:	dd03      	ble.n	80090e0 <max2870TuneNoLock+0x2a0>
        registerValue |= 2;
 80090d8:	2206      	movs	r2, #6
        *power = 2;
 80090da:	f884 b008 	strb.w	fp, [r4, #8]
        registerValue |= 2;
 80090de:	e7b2      	b.n	8009046 <max2870TuneNoLock+0x206>
    } else if(*power >= -1) {
 80090e0:	3301      	adds	r3, #1
        *power = -1;
 80090e2:	bfa5      	ittet	ge
 80090e4:	23ff      	movge	r3, #255	; 0xff
        registerValue |= 1;
 80090e6:	2205      	movge	r2, #5
    registerValue = _BV(2); /* Output enabled */
 80090e8:	2204      	movlt	r2, #4
        *power = -1;
 80090ea:	7223      	strbge	r3, [r4, #8]
        *power = -4;
 80090ec:	bfb8      	it	lt
 80090ee:	f884 a008 	strblt.w	sl, [r4, #8]
 80090f2:	e7a8      	b.n	8009046 <max2870TuneNoLock+0x206>
    if(*power >= 5) {
 80090f4:	2a04      	cmp	r2, #4
 80090f6:	dd03      	ble.n	8009100 <max2870TuneNoLock+0x2c0>
        *power = 5;
 80090f8:	2205      	movs	r2, #5
 80090fa:	7262      	strb	r2, [r4, #9]
        registerValue |= 3;
 80090fc:	2207      	movs	r2, #7
 80090fe:	e7ac      	b.n	800905a <max2870TuneNoLock+0x21a>
    } else if(*power >= 2) {
 8009100:	2a01      	cmp	r2, #1
 8009102:	dd03      	ble.n	800910c <max2870TuneNoLock+0x2cc>
        registerValue |= 2;
 8009104:	2206      	movs	r2, #6
        *power = 2;
 8009106:	f884 b009 	strb.w	fp, [r4, #9]
        registerValue |= 2;
 800910a:	e7a6      	b.n	800905a <max2870TuneNoLock+0x21a>
    } else if(*power >= -1) {
 800910c:	3201      	adds	r2, #1
        *power = -1;
 800910e:	bfab      	itete	ge
 8009110:	22ff      	movge	r2, #255	; 0xff
    registerValue = _BV(2); /* Output enabled */
 8009112:	2204      	movlt	r2, #4
        *power = -1;
 8009114:	7262      	strbge	r2, [r4, #9]
        *power = -4;
 8009116:	f884 a009 	strblt.w	sl, [r4, #9]
        registerValue |= 1;
 800911a:	bfa8      	it	ge
 800911c:	2205      	movge	r2, #5
        *power = -4;
 800911e:	e79c      	b.n	800905a <max2870TuneNoLock+0x21a>
 8009120:	01312d00 	.word	0x01312d00
 8009124:	00000000 	.word	0x00000000
 8009128:	fe9a5f44 	.word	0xfe9a5f44
 800912c:	643b1b44 	.word	0x643b1b44
 8009130:	b2d05dff 	.word	0xb2d05dff
 8009134:	01e84800 	.word	0x01e84800
 8009138:	000f4240 	.word	0x000f4240
 800913c:	4d2fa200 	.word	0x4d2fa200
 8009140:	2102      	movs	r1, #2
 8009142:	f10d 020e 	add.w	r2, sp, #14
 8009146:	f7fd fa63 	bl	8006610 <spiReceive.part.0>
            if(timeoutCnt == 255) {
 800914a:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 800914e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009152:	d148      	bne.n	80091e6 <max2870TuneNoLock+0x3a6>
                if(!vcoAutoTune) {
 8009154:	b9d6      	cbnz	r6, 800918c <max2870TuneNoLock+0x34c>
                    registers[3] &=~ _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 8009156:	9b07      	ldr	r3, [sp, #28]
    } while(lock != 0xFFFF);
 8009158:	f8bd 200e 	ldrh.w	r2, [sp, #14]
                    registers[3] &=~ _BV(MAX2870_REG3_VAS_SHDN_OFFSET);
 800915c:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8009160:	9307      	str	r3, [sp, #28]
    } while(lock != 0xFFFF);
 8009162:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009166:	429a      	cmp	r2, r3
                    driver->vcoCache[vcoIndex] = 0;
 8009168:	f889 6020 	strb.w	r6, [r9, #32]
                    vcoAutoTune = true;
 800916c:	f04f 0601 	mov.w	r6, #1
    } while(lock != 0xFFFF);
 8009170:	f47f af62 	bne.w	8009038 <max2870TuneNoLock+0x1f8>
    for(int i=0; i<outDivide; i++) {
 8009174:	2100      	movs	r1, #0
    tune->frequency = ((uint64_t)steps * (uint64_t)driver->config->stepFrequency);
 8009176:	682b      	ldr	r3, [r5, #0]
 8009178:	9a01      	ldr	r2, [sp, #4]
 800917a:	699b      	ldr	r3, [r3, #24]
 800917c:	fba3 2302 	umull	r2, r3, r3, r2
 8009180:	e9c4 2300 	strd	r2, r3, [r4]
    for(int i=0; i<outDivide; i++) {
 8009184:	428f      	cmp	r7, r1
 8009186:	dc38      	bgt.n	80091fa <max2870TuneNoLock+0x3ba>
    MAX2870TuneResult result = TUNE_OK;
 8009188:	2700      	movs	r7, #0
 800918a:	e004      	b.n	8009196 <max2870TuneNoLock+0x356>
                    syslog("MAX2870 Tuning failed.");
 800918c:	4824      	ldr	r0, [pc, #144]	; (8009220 <max2870TuneNoLock+0x3e0>)
 800918e:	f7ff fdfb 	bl	8008d88 <syslog>
                    result = TUNE_NOT_LOCKED;
 8009192:	f06f 0703 	mvn.w	r7, #3
    reg6 = max2870ReadRegister6(driver);
 8009196:	4628      	mov	r0, r5
 8009198:	f7ff f8e6 	bl	8008368 <max2870ReadRegister6>
    if(vcoAutoTune && result==TUNE_OK) {
 800919c:	0843      	lsrs	r3, r0, #1
 800919e:	b136      	cbz	r6, 80091ae <max2870TuneNoLock+0x36e>
 80091a0:	b92f      	cbnz	r7, 80091ae <max2870TuneNoLock+0x36e>
        driver->vcoCache[vcoIndex] = 0x80 | ((reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F);
 80091a2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 80091a6:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80091aa:	f889 2020 	strb.w	r2, [r9, #32]
    tune->adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 80091ae:	f3c0 4082 	ubfx	r0, r0, #18, #3
 80091b2:	74a0      	strb	r0, [r4, #18]
    tune->isLocked = (result == TUNE_OK);
 80091b4:	fab7 f087 	clz	r0, r7
    tune->usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 80091b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80091bc:	7463      	strb	r3, [r4, #17]
    tune->lockTime = timeoutCnt;
 80091be:	f884 8013 	strb.w	r8, [r4, #19]
    if(driver->config->lockStatus) {
 80091c2:	682b      	ldr	r3, [r5, #0]
    tune->isLocked = (result == TUNE_OK);
 80091c4:	0940      	lsrs	r0, r0, #5
    if(driver->config->lockStatus) {
 80091c6:	69db      	ldr	r3, [r3, #28]
    tune->usedVCOAutotune = vcoAutoTune;
 80091c8:	7566      	strb	r6, [r4, #21]
    tune->isLocked = (result == TUNE_OK);
 80091ca:	7520      	strb	r0, [r4, #20]
    if(driver->config->lockStatus) {
 80091cc:	b103      	cbz	r3, 80091d0 <max2870TuneNoLock+0x390>
        driver->config->lockStatus(tune->isLocked);
 80091ce:	4798      	blx	r3
    driver->enabled = true;
 80091d0:	2301      	movs	r3, #1
    driver->currentTune = *tune;
 80091d2:	3508      	adds	r5, #8
    driver->enabled = true;
 80091d4:	f805 3c04 	strb.w	r3, [r5, #-4]
    driver->currentTune = *tune;
 80091d8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80091da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80091dc:	e894 0003 	ldmia.w	r4, {r0, r1}
 80091e0:	e885 0003 	stmia.w	r5, {r0, r1}
    return result;
 80091e4:	e63f      	b.n	8008e66 <max2870TuneNoLock+0x26>
        } while(lock != 0xFFFF);
 80091e6:	f8bd 200e 	ldrh.w	r2, [sp, #14]
            timeoutCnt++;
 80091ea:	f108 0801 	add.w	r8, r8, #1
        } while(lock != 0xFFFF);
 80091ee:	429a      	cmp	r2, r3
            timeoutCnt++;
 80091f0:	fa5f f888 	uxtb.w	r8, r8
        } while(lock != 0xFFFF);
 80091f4:	f47f af46 	bne.w	8009084 <max2870TuneNoLock+0x244>
 80091f8:	e7bc      	b.n	8009174 <max2870TuneNoLock+0x334>
        tune->frequency /= 2;
 80091fa:	e9d4 3200 	ldrd	r3, r2, [r4]
 80091fe:	085b      	lsrs	r3, r3, #1
 8009200:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
 8009204:	0852      	lsrs	r2, r2, #1
 8009206:	e9c4 3200 	strd	r3, r2, [r4]
    for(int i=0; i<outDivide; i++) {
 800920a:	3101      	adds	r1, #1
 800920c:	e7ba      	b.n	8009184 <max2870TuneNoLock+0x344>
        return TUNE_FREQUENCY_OUT_OF_RANGE;
 800920e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8009212:	e628      	b.n	8008e66 <max2870TuneNoLock+0x26>
        return TUNE_PLL_N_OUT_OF_RANGE;
 8009214:	f06f 0701 	mvn.w	r7, #1
 8009218:	e625      	b.n	8008e66 <max2870TuneNoLock+0x26>
            return TUNE_CANT_FASTLOCK;
 800921a:	f06f 0702 	mvn.w	r7, #2
 800921e:	e622      	b.n	8008e66 <max2870TuneNoLock+0x26>
 8009220:	0800bfd2 	.word	0x0800bfd2

08009224 <max2870DoMonitorTask>:
{
 8009224:	b538      	push	{r3, r4, r5, lr}
 8009226:	4604      	mov	r4, r0
    max2870SpiState(driver, true);
 8009228:	f7fe ff7e 	bl	8008128 <max2870SpiState.constprop.0>
    if(driver->enabled) {
 800922c:	7925      	ldrb	r5, [r4, #4]
 800922e:	b165      	cbz	r5, 800924a <max2870DoMonitorTask+0x26>
        if(driver->pllMonReloadCounter >= 29) {
 8009230:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
 8009234:	2b1c      	cmp	r3, #28
 8009236:	d90d      	bls.n	8009254 <max2870DoMonitorTask+0x30>
            max2870WriteAllRegisters(driver, driver->registers, true);
 8009238:	2201      	movs	r2, #1
 800923a:	4620      	mov	r0, r4
 800923c:	f104 01c8 	add.w	r1, r4, #200	; 0xc8
 8009240:	f7ff f900 	bl	8008444 <max2870WriteAllRegisters.isra.0>
            driver->pllMonReloadCounter = 0;
 8009244:	2300      	movs	r3, #0
 8009246:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
    if(enable) {
 800924a:	4620      	mov	r0, r4
 800924c:	f7ff fa3a 	bl	80086c4 <max2870SpiState.part.0>
}
 8009250:	4628      	mov	r0, r5
 8009252:	bd38      	pop	{r3, r4, r5, pc}
            driver->pllMonReloadCounter++;
 8009254:	3301      	adds	r3, #1
 8009256:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
            uint32_t reg6 = max2870ReadRegister6(driver);
 800925a:	4620      	mov	r0, r4
 800925c:	f7ff f884 	bl	8008368 <max2870ReadRegister6>
            driver->currentTune.adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 8009260:	f3c0 4382 	ubfx	r3, r0, #18, #3
            driver->currentTune.usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 8009264:	f3c0 0045 	ubfx	r0, r0, #1, #6
            driver->currentTune.adcVoltage = (reg6 >>MAX2870_REG6_ADC_OFFSET) & 7;
 8009268:	76a3      	strb	r3, [r4, #26]
            driver->currentTune.usedVCO = (reg6 >> MAX2870_REG6_V_OFFSET) & 0x3F;
 800926a:	7660      	strb	r0, [r4, #25]
            if(driver->currentTune.adcVoltage == 0 ||
 800926c:	b11b      	cbz	r3, 8009276 <max2870DoMonitorTask+0x52>
 800926e:	2b07      	cmp	r3, #7
 8009270:	d001      	beq.n	8009276 <max2870DoMonitorTask+0x52>
                    !driver->currentTune.isLocked) {
 8009272:	7f23      	ldrb	r3, [r4, #28]
                    driver->currentTune.adcVoltage == 7 ||
 8009274:	b953      	cbnz	r3, 800928c <max2870DoMonitorTask+0x68>
                syslog("MAX2870 Lost lock, retuning.");
 8009276:	4806      	ldr	r0, [pc, #24]	; (8009290 <max2870DoMonitorTask+0x6c>)
 8009278:	f7ff fd86 	bl	8008d88 <syslog>
                driver->currentTune.useVCOAutotune = true;
 800927c:	2301      	movs	r3, #1
                max2870TuneNoLock(driver, &driver->currentTune);
 800927e:	4620      	mov	r0, r4
                driver->currentTune.useVCOAutotune = true;
 8009280:	7623      	strb	r3, [r4, #24]
                max2870TuneNoLock(driver, &driver->currentTune);
 8009282:	f104 0108 	add.w	r1, r4, #8
 8009286:	f7ff fddb 	bl	8008e40 <max2870TuneNoLock>
 800928a:	e7de      	b.n	800924a <max2870DoMonitorTask+0x26>
        didWork = true;
 800928c:	461d      	mov	r5, r3
 800928e:	e7dc      	b.n	800924a <max2870DoMonitorTask+0x26>
 8009290:	0800bfe9 	.word	0x0800bfe9

08009294 <max2870Tune>:
{
 8009294:	b538      	push	{r3, r4, r5, lr}
 8009296:	4604      	mov	r4, r0
 8009298:	460d      	mov	r5, r1
    max2870SpiState(driver, true);
 800929a:	f7fe ff45 	bl	8008128 <max2870SpiState.constprop.0>
    MAX2870TuneResult result = max2870TuneNoLock(driver, tune);
 800929e:	4629      	mov	r1, r5
 80092a0:	4620      	mov	r0, r4
 80092a2:	f7ff fdcd 	bl	8008e40 <max2870TuneNoLock>
 80092a6:	4605      	mov	r5, r0
    if(enable) {
 80092a8:	4620      	mov	r0, r4
 80092aa:	f7ff fa0b 	bl	80086c4 <max2870SpiState.part.0>
}
 80092ae:	4628      	mov	r0, r5
 80092b0:	bd38      	pop	{r3, r4, r5, pc}
	...

080092b4 <converterSHFLoTune>:
{
 80092b4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    tune.fastLockDurationMicroseconds = 0;
 80092b6:	2300      	movs	r3, #0
 80092b8:	9303      	str	r3, [sp, #12]
    tune.useVCOAutotune = false;
 80092ba:	f88d 3010 	strb.w	r3, [sp, #16]
    tune.powerB = -127;
 80092be:	2381      	movs	r3, #129	; 0x81
 80092c0:	f88d 3009 	strb.w	r3, [sp, #9]
    tune.frequency = (uint64_t)freqKHz * 1000;
 80092c4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80092c8:	fba0 0303 	umull	r0, r3, r0, r3
    tune.powerA = power;
 80092cc:	f88d 1008 	strb.w	r1, [sp, #8]
    tune.frequency = (uint64_t)freqKHz * 1000;
 80092d0:	e9cd 0300 	strd	r0, r3, [sp]
    return max2870Tune(&loPLL, &tune) == TUNE_OK;
 80092d4:	4669      	mov	r1, sp
 80092d6:	4804      	ldr	r0, [pc, #16]	; (80092e8 <converterSHFLoTune+0x34>)
 80092d8:	f7ff ffdc 	bl	8009294 <max2870Tune>
}
 80092dc:	fab0 f080 	clz	r0, r0
 80092e0:	0940      	lsrs	r0, r0, #5
 80092e2:	b007      	add	sp, #28
 80092e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80092e8:	20001098 	.word	0x20001098
 80092ec:	00000000 	.word	0x00000000

080092f0 <max2870VcoPrecal>:
{
 80092f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80092f4:	b08d      	sub	sp, #52	; 0x34
    MAX2870TuneRequest previousTune = driver->currentTune;
 80092f6:	ad06      	add	r5, sp, #24
 80092f8:	f100 0608 	add.w	r6, r0, #8
{
 80092fc:	4604      	mov	r4, r0
    bool pllWasEnabled = driver->enabled;
 80092fe:	7907      	ldrb	r7, [r0, #4]
    MAX2870TuneRequest previousTune = driver->currentTune;
 8009300:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8009302:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8009304:	e896 0003 	ldmia.w	r6, {r0, r1}
 8009308:	e885 0003 	stmia.w	r5, {r0, r1}
    tune.useVCOAutotune = true;
 800930c:	2501      	movs	r5, #1
    MAX2870TuneRequest tune = {};
 800930e:	2218      	movs	r2, #24
 8009310:	2100      	movs	r1, #0
 8009312:	4668      	mov	r0, sp
 8009314:	f002 fa7a 	bl	800b80c <memset>
    tune.powerA = -127;
 8009318:	f248 1381 	movw	r3, #33153	; 0x8181
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 800931c:	46a8      	mov	r8, r5
    max2870SpiState(driver, true);
 800931e:	4620      	mov	r0, r4
    tune.powerA = -127;
 8009320:	f8ad 3008 	strh.w	r3, [sp, #8]
    tune.useVCOAutotune = true;
 8009324:	f88d 5010 	strb.w	r5, [sp, #16]
    max2870SpiState(driver, true);
 8009328:	f7fe fefe 	bl	8008128 <max2870SpiState.constprop.0>
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 800932c:	a31c      	add	r3, pc, #112	; (adr r3, 80093a0 <max2870VcoPrecal+0xb0>)
 800932e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009332:	e9cd 2300 	strd	r2, r3, [sp]
            tune.frequency += MAX2870_VCO_INCREMENT) {
 8009336:	4e18      	ldr	r6, [pc, #96]	; (8009398 <max2870VcoPrecal+0xa8>)
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 8009338:	f8df 9060 	ldr.w	r9, [pc, #96]	; 800939c <max2870VcoPrecal+0xac>
        if(max2870TuneNoLock(driver, &tune)) {
 800933c:	4669      	mov	r1, sp
 800933e:	4620      	mov	r0, r4
 8009340:	f7ff fd7e 	bl	8008e40 <max2870TuneNoLock>
            tune.frequency += MAX2870_VCO_INCREMENT) {
 8009344:	9b00      	ldr	r3, [sp, #0]
 8009346:	9a01      	ldr	r2, [sp, #4]
            allGood = false;
 8009348:	2800      	cmp	r0, #0
 800934a:	bf18      	it	ne
 800934c:	2500      	movne	r5, #0
            tune.frequency += MAX2870_VCO_INCREMENT) {
 800934e:	199b      	adds	r3, r3, r6
 8009350:	f142 0200 	adc.w	r2, r2, #0
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 8009354:	4599      	cmp	r9, r3
            tune.frequency += MAX2870_VCO_INCREMENT) {
 8009356:	e9cd 3200 	strd	r3, r2, [sp]
    for(tune.frequency = MAX2870_VCO_MIN_FREQUENCY + MAX2870_VCO_INCREMENT/2;
 800935a:	eb78 0302 	sbcs.w	r3, r8, r2
 800935e:	d2ed      	bcs.n	800933c <max2870VcoPrecal+0x4c>
    if(!pllWasEnabled) {
 8009360:	b997      	cbnz	r7, 8009388 <max2870VcoPrecal+0x98>
        max2870Disable(driver);
 8009362:	4620      	mov	r0, r4
 8009364:	f7ff f854 	bl	8008410 <max2870Disable>
    if(driver->vcoCache[0] >= 0x9f ||
 8009368:	f894 3020 	ldrb.w	r3, [r4, #32]
 800936c:	2b9e      	cmp	r3, #158	; 0x9e
 800936e:	d810      	bhi.n	8009392 <max2870VcoPrecal+0xa2>
 8009370:	f894 30b5 	ldrb.w	r3, [r4, #181]	; 0xb5
    	allGood = false;
 8009374:	2b9f      	cmp	r3, #159	; 0x9f
 8009376:	bf98      	it	ls
 8009378:	2500      	movls	r5, #0
    if(enable) {
 800937a:	4620      	mov	r0, r4
 800937c:	f7ff f9a2 	bl	80086c4 <max2870SpiState.part.0>
}
 8009380:	4628      	mov	r0, r5
 8009382:	b00d      	add	sp, #52	; 0x34
 8009384:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        max2870TuneNoLock(driver, &previousTune);
 8009388:	4620      	mov	r0, r4
 800938a:	a906      	add	r1, sp, #24
 800938c:	f7ff fd58 	bl	8008e40 <max2870TuneNoLock>
 8009390:	e7ea      	b.n	8009368 <max2870VcoPrecal+0x78>
    	allGood = false;
 8009392:	2500      	movs	r5, #0
 8009394:	e7f1      	b.n	800937a <max2870VcoPrecal+0x8a>
 8009396:	bf00      	nop
 8009398:	01312d00 	.word	0x01312d00
 800939c:	65a0bbff 	.word	0x65a0bbff
 80093a0:	b368f480 	.word	0xb368f480
 80093a4:	00000000 	.word	0x00000000

080093a8 <gpioDummySetPinMode>:
{
 80093a8:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 80093aa:	6801      	ldr	r1, [r0, #0]
 80093ac:	4802      	ldr	r0, [pc, #8]	; (80093b8 <gpioDummySetPinMode+0x10>)
 80093ae:	f7ff fceb 	bl	8008d88 <syslog>
}
 80093b2:	2000      	movs	r0, #0
 80093b4:	bd08      	pop	{r3, pc}
 80093b6:	bf00      	nop
 80093b8:	0800c006 	.word	0x0800c006

080093bc <gpioDummyGetPinMode>:
{
 80093bc:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 80093be:	6801      	ldr	r1, [r0, #0]
 80093c0:	4802      	ldr	r0, [pc, #8]	; (80093cc <gpioDummyGetPinMode+0x10>)
 80093c2:	f7ff fce1 	bl	8008d88 <syslog>
}
 80093c6:	2002      	movs	r0, #2
 80093c8:	bd08      	pop	{r3, pc}
 80093ca:	bf00      	nop
 80093cc:	0800c006 	.word	0x0800c006

080093d0 <gpioDummySetValue>:
{
 80093d0:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 80093d2:	6801      	ldr	r1, [r0, #0]
 80093d4:	4802      	ldr	r0, [pc, #8]	; (80093e0 <gpioDummySetValue+0x10>)
 80093d6:	f7ff fcd7 	bl	8008d88 <syslog>
}
 80093da:	2000      	movs	r0, #0
 80093dc:	bd08      	pop	{r3, pc}
 80093de:	bf00      	nop
 80093e0:	0800c006 	.word	0x0800c006

080093e4 <gpioDummyGetValue>:
{
 80093e4:	b508      	push	{r3, lr}
    syslog("Use of dummy GPIO %u!", (uint32_t)driver->driver);
 80093e6:	6801      	ldr	r1, [r0, #0]
 80093e8:	4802      	ldr	r0, [pc, #8]	; (80093f4 <gpioDummyGetValue+0x10>)
 80093ea:	f7ff fccd 	bl	8008d88 <syslog>
}
 80093ee:	2000      	movs	r0, #0
 80093f0:	bd08      	pop	{r3, pc}
 80093f2:	bf00      	nop
 80093f4:	0800c006 	.word	0x0800c006

080093f8 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>:
i2c_result i2cSafeMasterTransmitTimeoutWithRetry (
 80093f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80093fc:	4604      	mov	r4, r0
 80093fe:	4617      	mov	r7, r2
    if(!devAddr) return MSG_RESET;
 8009400:	460d      	mov	r5, r1
i2c_result i2cSafeMasterTransmitTimeoutWithRetry (
 8009402:	9301      	str	r3, [sp, #4]
    if(!devAddr) return MSG_RESET;
 8009404:	2900      	cmp	r1, #0
 8009406:	d07f      	beq.n	8009508 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x110>
    memset(rxbuf, 0xFE, rxbytes);
 8009408:	21fe      	movs	r1, #254	; 0xfe
 800940a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800940c:	980c      	ldr	r0, [sp, #48]	; 0x30
 800940e:	f002 f9fd 	bl	800b80c <memset>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8009412:	2603      	movs	r6, #3
  i2cp->errors = I2C_NO_ERROR;
 8009414:	f04f 0900 	mov.w	r9, #0
 8009418:	006d      	lsls	r5, r5, #1
		xReturn = xTickCount;
 800941a:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 8009514 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x11c>
 800941e:	fa1f f885 	uxth.w	r8, r5
  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 8009422:	b914      	cbnz	r4, 800942a <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x32>
 8009424:	f7fb fac6 	bl	80049b4 <vTaskEndScheduler>
 8009428:	e7fe      	b.n	8009428 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x30>
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 800942a:	7825      	ldrb	r5, [r4, #0]
 800942c:	2d02      	cmp	r5, #2
 800942e:	d002      	beq.n	8009436 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x3e>
 8009430:	f7fb fac0 	bl	80049b4 <vTaskEndScheduler>
 8009434:	e7fe      	b.n	8009434 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x3c>
  osalSysLock();
 8009436:	f7fb faad 	bl	8004994 <vPortEnterCritical>
  i2cp->state = I2C_ACTIVE_TX;
 800943a:	2303      	movs	r3, #3
  i2cp->errors = I2C_NO_ERROR;
 800943c:	f8c4 9008 	str.w	r9, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8009440:	7023      	strb	r3, [r4, #0]
  i2cp->numInterrupts = 0;
 8009442:	f8c4 9080 	str.w	r9, [r4, #128]	; 0x80
  i2cp->addr = (addr << 1);
 8009446:	f8a4 8064 	strh.w	r8, [r4, #100]	; 0x64
  I2C_TypeDef *dp = i2cp->i2c;
 800944a:	6fa0      	ldr	r0, [r4, #120]	; 0x78

  /* Releases the lock from high level driver.*/
  osalSysUnlock();
 800944c:	f7fb fcc6 	bl	8004ddc <osalSysUnlock.lto_priv.0>

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8009450:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009452:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8009454:	685b      	ldr	r3, [r3, #4]
 8009456:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8009458:	9a01      	ldr	r2, [sp, #4]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 800945a:	60df      	str	r7, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 800945c:	605a      	str	r2, [r3, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800945e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8009460:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8009462:	685b      	ldr	r3, [r3, #4]
 8009464:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8009466:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009468:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800946a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800946c:	605a      	str	r2, [r3, #4]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800946e:	f7fc fd4d 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8009472:	f8da b000 	ldr.w	fp, [sl]
  end = start + OSAL_MS2ST(STM32_I2C_BUSY_TIMEOUT);

  /* Waits until BUSY flag is reset or, alternatively, for a timeout
     condition.*/
  while (true) {
    osalSysLock();
 8009476:	f7fb fa8d 	bl	8004994 <vPortEnterCritical>

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 800947a:	6983      	ldr	r3, [r0, #24]
 800947c:	0799      	lsls	r1, r3, #30
 800947e:	d402      	bmi.n	8009486 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x8e>
 8009480:	6803      	ldr	r3, [r0, #0]
 8009482:	059a      	lsls	r2, r3, #22
 8009484:	d50a      	bpl.n	800949c <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xa4>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8009486:	f7fc fd41 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800948a:	f8da 3000 	ldr.w	r3, [sl]
    systime_t past = now - begin;
 800948e:	eba3 030b 	sub.w	r3, r3, fp
    if(past < duration) return true;
 8009492:	2b31      	cmp	r3, #49	; 0x31
 8009494:	d82e      	bhi.n	80094f4 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xfc>
    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
      return MSG_TIMEOUT;

    osalSysUnlock();
 8009496:	f7fb fca1 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    osalSysLock();
 800949a:	e7ec      	b.n	8009476 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x7e>
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800949c:	6843      	ldr	r3, [r0, #4]
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 800949e:	2105      	movs	r1, #5
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80094a0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80094a4:	6043      	str	r3, [r0, #4]
  dp->CR1 |= I2C_CR1_START;
 80094a6:	6803      	ldr	r3, [r0, #0]
 80094a8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80094ac:	6003      	str	r3, [r0, #0]
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 80094ae:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80094b2:	f7fd f883 	bl	80065bc <osalThreadSuspendTimeoutS>
    i2cp->state = I2C_LOCKED;
 80094b6:	1c43      	adds	r3, r0, #1
 80094b8:	bf08      	it	eq
 80094ba:	2505      	moveq	r5, #5
 80094bc:	7025      	strb	r5, [r4, #0]
  osalSysUnlock();
 80094be:	f7fb fc8d 	bl	8004ddc <osalSysUnlock.lto_priv.0>
        if(status == MSG_OK){
 80094c2:	b320      	cbz	r0, 800950e <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x116>
        osalSysLock();
 80094c4:	f7fb fa66 	bl	8004994 <vPortEnterCritical>
        i2c->i2cErrors++;
 80094c8:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
        if((retVal = i2cSafeRawUnclogBus(i2c))) {
 80094cc:	4620      	mov	r0, r4
        i2c->i2cErrors++;
 80094ce:	3301      	adds	r3, #1
 80094d0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        osalSysUnlock();
 80094d4:	f7fb fc82 	bl	8004ddc <osalSysUnlock.lto_priv.0>
        if((retVal = i2cSafeRawUnclogBus(i2c))) {
 80094d8:	f7fe fd66 	bl	8007fa8 <i2cSafeRawUnclogBus>
 80094dc:	4605      	mov	r5, r0
 80094de:	b168      	cbz	r0, 80094fc <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x104>
            syslog("I2C error, bus failure: %s.", i2cSafeResultToString(retVal));
 80094e0:	f7fa ff36 	bl	8004350 <i2cSafeResultToString>
 80094e4:	4601      	mov	r1, r0
 80094e6:	480c      	ldr	r0, [pc, #48]	; (8009518 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x120>)
 80094e8:	f7ff fc4e 	bl	8008d88 <syslog>
}
 80094ec:	4628      	mov	r0, r5
 80094ee:	b003      	add	sp, #12
 80094f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    i2cp->state = I2C_LOCKED;
 80094f4:	2505      	movs	r5, #5
      return MSG_TIMEOUT;
 80094f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80094fa:	e7df      	b.n	80094bc <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xc4>
    for(i=0; i<maxTries; i++) {
 80094fc:	3e01      	subs	r6, #1
 80094fe:	d190      	bne.n	8009422 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x2a>
    syslog("I2C error, %u failed attempts.", maxTries);
 8009500:	2103      	movs	r1, #3
 8009502:	4806      	ldr	r0, [pc, #24]	; (800951c <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0x124>)
 8009504:	f7ff fc40 	bl	8008d88 <syslog>
    if(!devAddr) return MSG_RESET;
 8009508:	f06f 0501 	mvn.w	r5, #1
 800950c:	e7ee      	b.n	80094ec <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xf4>
            retVal = status;
 800950e:	4605      	mov	r5, r0
 8009510:	e7ec      	b.n	80094ec <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0+0xf4>
 8009512:	bf00      	nop
 8009514:	20001648 	.word	0x20001648
 8009518:	0800c01c 	.word	0x0800c01c
 800951c:	0800c038 	.word	0x0800c038

08009520 <i2cSafeReadRegBulkStandard.constprop.0>:
i2c_result i2cSafeReadRegBulkStandard(I2CDriver* i2c,
 8009520:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8009522:	460d      	mov	r5, r1
 8009524:	461e      	mov	r6, r3
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 8009526:	4604      	mov	r4, r0
 8009528:	b910      	cbnz	r0, 8009530 <i2cSafeReadRegBulkStandard.constprop.0+0x10>
 800952a:	f7fb fa43 	bl	80049b4 <vTaskEndScheduler>
 800952e:	e7fe      	b.n	800952e <i2cSafeReadRegBulkStandard.constprop.0+0xe>
    uint8_t txBuf[1] = {addr};
 8009530:	f88d 200c 	strb.w	r2, [sp, #12]
    i2cAcquireBus(i2c);
 8009534:	f7fc f8fc 	bl	8005730 <i2cAcquireBus>
    i2c_status = i2cSafeMasterTransmitTimeoutWithRetry(i2c, devAddr, txBuf,
 8009538:	2302      	movs	r3, #2
 800953a:	4629      	mov	r1, r5
 800953c:	e9cd 6300 	strd	r6, r3, [sp]
 8009540:	aa03      	add	r2, sp, #12
 8009542:	2301      	movs	r3, #1
 8009544:	4620      	mov	r0, r4
 8009546:	f7ff ff57 	bl	80093f8 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>
 800954a:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 800954c:	4620      	mov	r0, r4
 800954e:	f7ff f8af 	bl	80086b0 <i2cReleaseBus>
}
 8009552:	4628      	mov	r0, r5
 8009554:	b004      	add	sp, #16
 8009556:	bd70      	pop	{r4, r5, r6, pc}

08009558 <i2cSafeReadRegStandard>:
{
 8009558:	b513      	push	{r0, r1, r4, lr}
 800955a:	461c      	mov	r4, r3
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 800955c:	b910      	cbnz	r0, 8009564 <i2cSafeReadRegStandard+0xc>
 800955e:	f7fb fa29 	bl	80049b4 <vTaskEndScheduler>
 8009562:	e7fe      	b.n	8009562 <i2cSafeReadRegStandard+0xa>
    i2c_result result = i2cSafeReadRegBulkStandard(i2c, devAddr, addr, values, sizeof(values));
 8009564:	ab01      	add	r3, sp, #4
 8009566:	f7ff ffdb 	bl	8009520 <i2cSafeReadRegBulkStandard.constprop.0>
    *value=values[0];
 800956a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800956e:	7023      	strb	r3, [r4, #0]
}
 8009570:	b002      	add	sp, #8
 8009572:	bd10      	pop	{r4, pc}

08009574 <MCP9804MeasureTemperature.part.0>:
#include "mcp9804.h"
#include "../i2csafe/i2csafe.h"
#include <string.h>
#include "../system.h"

int16_t MCP9804MeasureTemperature(MCP9804Driver* driver, bool newMeasurement)
 8009574:	b513      	push	{r0, r1, r4, lr}
 8009576:	4604      	mov	r4, r0
    if(!newMeasurement) {
        return driver->temperature;
    }

    uint8_t data[2];
    i2c_result result = i2cSafeReadRegBulkStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x5, data, 2);
 8009578:	6800      	ldr	r0, [r0, #0]
 800957a:	2205      	movs	r2, #5
 800957c:	7901      	ldrb	r1, [r0, #4]
 800957e:	ab01      	add	r3, sp, #4
 8009580:	6800      	ldr	r0, [r0, #0]
 8009582:	f7ff ffcd 	bl	8009520 <i2cSafeReadRegBulkStandard.constprop.0>

    if(result != I2C_BUS_OK) {
 8009586:	b130      	cbz	r0, 8009596 <MCP9804MeasureTemperature.part.0+0x22>
        driver->temperature = 0x7FFF;
 8009588:	f647 73ff 	movw	r3, #32767	; 0x7fff

        driver->temperature = temp;

        /* Check sign */
        if(data[0] & 0x10) {
            driver->temperature = 4096 - temp;
 800958c:	80a3      	strh	r3, [r4, #4]
        }
    }

    return driver->temperature;
}
 800958e:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 8009592:	b002      	add	sp, #8
 8009594:	bd10      	pop	{r4, pc}
        uint16_t temp = ((data[0] & 0xF) << 8) | data[1];
 8009596:	f89d 1004 	ldrb.w	r1, [sp, #4]
 800959a:	020b      	lsls	r3, r1, #8
 800959c:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
 80095a0:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80095a4:	4313      	orrs	r3, r2
        if(data[0] & 0x10) {
 80095a6:	06ca      	lsls	r2, r1, #27
            driver->temperature = 4096 - temp;
 80095a8:	bf48      	it	mi
 80095aa:	f5c3 5380 	rsbmi	r3, r3, #4096	; 0x1000
 80095ae:	e7ed      	b.n	800958c <MCP9804MeasureTemperature.part.0+0x18>

080095b0 <cmdTemp>:

#include <string.h>


void cmdTemp(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 80095b0:	b510      	push	{r4, lr}
 80095b2:	460c      	mov	r4, r1
 80095b4:	f7ff ffde 	bl	8009574 <MCP9804MeasureTemperature.part.0>
    (void)argv;
    MCP9804Driver* tempSens = (MCP9804Driver*)user;

    int32_t temp = MCP9804MeasureTemperature(tempSens, true);

    chprintf(chp, "Temperature: %d mC"SHELL_NEWLINE_STR, temp*1000/16);
 80095b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80095bc:	4342      	muls	r2, r0
 80095be:	bf48      	it	mi
 80095c0:	320f      	addmi	r2, #15
 80095c2:	4620      	mov	r0, r4
}
 80095c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "Temperature: %d mC"SHELL_NEWLINE_STR, temp*1000/16);
 80095c8:	4901      	ldr	r1, [pc, #4]	; (80095d0 <cmdTemp+0x20>)
 80095ca:	1112      	asrs	r2, r2, #4
 80095cc:	f7ff b8bf 	b.w	800874e <chprintf>
 80095d0:	0800c057 	.word	0x0800c057

080095d4 <parse_arguments>:
static char *parse_arguments(char *str, char **saveptr) {
 80095d4:	b570      	push	{r4, r5, r6, lr}
 80095d6:	460d      	mov	r5, r1
  if (str != NULL)
 80095d8:	b100      	cbz	r0, 80095dc <parse_arguments+0x8>
    *saveptr = str;
 80095da:	6008      	str	r0, [r1, #0]
  p = *saveptr;
 80095dc:	682e      	ldr	r6, [r5, #0]
  if (!p) {
 80095de:	b17e      	cbz	r6, 8009600 <parse_arguments+0x2c>
  p += strspn(p, " \t");
 80095e0:	490e      	ldr	r1, [pc, #56]	; (800961c <parse_arguments+0x48>)
 80095e2:	4630      	mov	r0, r6
 80095e4:	f002 fa14 	bl	800ba10 <strspn>
  if (*p == '"') {
 80095e8:	5c31      	ldrb	r1, [r6, r0]
  p += strspn(p, " \t");
 80095ea:	1834      	adds	r4, r6, r0
  if (*p == '"') {
 80095ec:	2922      	cmp	r1, #34	; 0x22
 80095ee:	d10a      	bne.n	8009606 <parse_arguments+0x32>
    p++;
 80095f0:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
 80095f2:	4620      	mov	r0, r4
 80095f4:	f002 f95c 	bl	800b8b0 <strchr>
  if (*saveptr != NULL) {
 80095f8:	b950      	cbnz	r0, 8009610 <parse_arguments+0x3c>
 80095fa:	6028      	str	r0, [r5, #0]
  return *p != '\0' ? p : NULL;
 80095fc:	7823      	ldrb	r3, [r4, #0]
 80095fe:	b903      	cbnz	r3, 8009602 <parse_arguments+0x2e>
 8009600:	2400      	movs	r4, #0
}
 8009602:	4620      	mov	r0, r4
 8009604:	bd70      	pop	{r4, r5, r6, pc}
    *saveptr = strpbrk(p, " \t");
 8009606:	4620      	mov	r0, r4
 8009608:	4904      	ldr	r1, [pc, #16]	; (800961c <parse_arguments+0x48>)
 800960a:	f002 f9e5 	bl	800b9d8 <strpbrk>
 800960e:	e7f3      	b.n	80095f8 <parse_arguments+0x24>
    *(*saveptr)++ = '\0';
 8009610:	1c43      	adds	r3, r0, #1
 8009612:	602b      	str	r3, [r5, #0]
 8009614:	2300      	movs	r3, #0
 8009616:	7003      	strb	r3, [r0, #0]
 8009618:	e7f0      	b.n	80095fc <parse_arguments+0x28>
 800961a:	bf00      	nop
 800961c:	0800c06c 	.word	0x0800c06c

08009620 <cmdexec>:
                      char *name, int argc, char *argv[]) {
 8009620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009624:	4605      	mov	r5, r0
 8009626:	460e      	mov	r6, r1
 8009628:	4617      	mov	r7, r2
 800962a:	4698      	mov	r8, r3
  while (scp->sc_name != NULL) {
 800962c:	6828      	ldr	r0, [r5, #0]
 800962e:	b908      	cbnz	r0, 8009634 <cmdexec+0x14>
  return true;
 8009630:	2001      	movs	r0, #1
 8009632:	e00b      	b.n	800964c <cmdexec+0x2c>
    if (strcmp(scp->sc_name, name) == 0) {
 8009634:	4639      	mov	r1, r7
 8009636:	f7fa fac3 	bl	8003bc0 <strcmp>
 800963a:	4604      	mov	r4, r0
 800963c:	b940      	cbnz	r0, 8009650 <cmdexec+0x30>
      scp->sc_function(scp->sc_user, chp, argc, argv);
 800963e:	68a8      	ldr	r0, [r5, #8]
 8009640:	4642      	mov	r2, r8
 8009642:	4631      	mov	r1, r6
 8009644:	686f      	ldr	r7, [r5, #4]
 8009646:	9b06      	ldr	r3, [sp, #24]
 8009648:	47b8      	blx	r7
      return false;
 800964a:	4620      	mov	r0, r4
}
 800964c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    scp++;
 8009650:	350c      	adds	r5, #12
 8009652:	e7eb      	b.n	800962c <cmdexec+0xc>

08009654 <cmdGPIO>:

void cmdGPIO(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 8009654:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    (void) user;

    if(argc < 1) {
 8009658:	1e16      	subs	r6, r2, #0
{
 800965a:	460d      	mov	r5, r1
 800965c:	461f      	mov	r7, r3
    if(argc < 1) {
 800965e:	dc04      	bgt.n	800966a <cmdGPIO+0x16>
        cmdGPIOUsage(chp);
 8009660:	4628      	mov	r0, r5
    } else {
        cmdGPIOUsage(chp);
    }

    //TXA6408PrintStatus(&mixerControllerIO, chp);
}
 8009662:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        cmdGPIOUsage(chp);
 8009666:	f7ff b9e5 	b.w	8008a34 <cmdGPIOUsage>
    if(!strcmp(argv[0], "status")) {
 800966a:	f8d3 8000 	ldr.w	r8, [r3]
 800966e:	4944      	ldr	r1, [pc, #272]	; (8009780 <cmdGPIO+0x12c>)
 8009670:	4640      	mov	r0, r8
 8009672:	f7fa faa5 	bl	8003bc0 <strcmp>
 8009676:	4604      	mov	r4, r0
 8009678:	bb78      	cbnz	r0, 80096da <cmdGPIO+0x86>

void gpioPrintStatus(BaseSequentialStream* chp)
{
    for(uint8_t i=0; i<GPIODriverData.numPorts; i++) {
 800967a:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8009784 <cmdGPIO+0x130>
        const GPIOPort* port = gpioGetPortDriver(i);

        chprintf(chp, "Port %u: ", i);
 800967e:	f8df 9108 	ldr.w	r9, [pc, #264]	; 8009788 <cmdGPIO+0x134>
        if(GPIODriverData.registeredPorts & _BV(i)) {
            chprintf(chp, "(Active, %u pins)", port->numPins);
 8009682:	f8df a108 	ldr.w	sl, [pc, #264]	; 800978c <cmdGPIO+0x138>
 8009686:	e021      	b.n	80096cc <cmdGPIO+0x78>
        const GPIOPort* port = gpioGetPortDriver(i);
 8009688:	4630      	mov	r0, r6
 800968a:	f7fa fe95 	bl	80043b8 <gpioGetPortDriver>
        chprintf(chp, "Port %u: ", i);
 800968e:	4649      	mov	r1, r9
        const GPIOPort* port = gpioGetPortDriver(i);
 8009690:	4607      	mov	r7, r0
        chprintf(chp, "Port %u: ", i);
 8009692:	4632      	mov	r2, r6
 8009694:	4628      	mov	r0, r5
 8009696:	f7ff f85a 	bl	800874e <chprintf>
        if(GPIODriverData.registeredPorts & _BV(i)) {
 800969a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800969e:	40f3      	lsrs	r3, r6
 80096a0:	07db      	lsls	r3, r3, #31
 80096a2:	d504      	bpl.n	80096ae <cmdGPIO+0x5a>
            chprintf(chp, "(Active, %u pins)", port->numPins);
 80096a4:	4651      	mov	r1, sl
 80096a6:	4628      	mov	r0, r5
 80096a8:	687a      	ldr	r2, [r7, #4]
 80096aa:	f7ff f850 	bl	800874e <chprintf>
        }
        chprintf(chp, SHELL_NEWLINE_STR);
 80096ae:	4628      	mov	r0, r5
 80096b0:	4937      	ldr	r1, [pc, #220]	; (8009790 <cmdGPIO+0x13c>)
 80096b2:	f7ff f84c 	bl	800874e <chprintf>

        if(port->functions->status) {
 80096b6:	68bb      	ldr	r3, [r7, #8]
 80096b8:	695b      	ldr	r3, [r3, #20]
 80096ba:	b113      	cbz	r3, 80096c2 <cmdGPIO+0x6e>
            port->functions->status(port, chp);
 80096bc:	4629      	mov	r1, r5
 80096be:	4638      	mov	r0, r7
 80096c0:	4798      	blx	r3
        }
        chprintf(chp, SHELL_NEWLINE_STR);
 80096c2:	4628      	mov	r0, r5
 80096c4:	4932      	ldr	r1, [pc, #200]	; (8009790 <cmdGPIO+0x13c>)
 80096c6:	f7ff f842 	bl	800874e <chprintf>
    for(uint8_t i=0; i<GPIODriverData.numPorts; i++) {
 80096ca:	3401      	adds	r4, #1
 80096cc:	f898 3004 	ldrb.w	r3, [r8, #4]
 80096d0:	b2e6      	uxtb	r6, r4
 80096d2:	42b3      	cmp	r3, r6
 80096d4:	d8d8      	bhi.n	8009688 <cmdGPIO+0x34>
}
 80096d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(argc == 3) {
 80096da:	2e03      	cmp	r6, #3
 80096dc:	d1c0      	bne.n	8009660 <cmdGPIO+0xc>
        uint8_t portId = strToInt(argv[0], 10);
 80096de:	210a      	movs	r1, #10
 80096e0:	4640      	mov	r0, r8
 80096e2:	f7fa fd76 	bl	80041d2 <strToInt>
        if(!strcmp(argv[1], "bus")) {
 80096e6:	687c      	ldr	r4, [r7, #4]
        uint8_t portId = strToInt(argv[0], 10);
 80096e8:	4606      	mov	r6, r0
        if(!strcmp(argv[1], "bus")) {
 80096ea:	492a      	ldr	r1, [pc, #168]	; (8009794 <cmdGPIO+0x140>)
 80096ec:	4620      	mov	r0, r4
 80096ee:	f7fa fa67 	bl	8003bc0 <strcmp>
 80096f2:	4680      	mov	r8, r0
 80096f4:	b968      	cbnz	r0, 8009712 <cmdGPIO+0xbe>
            if(!strcmp(argv[2], "off")) {
 80096f6:	4928      	ldr	r1, [pc, #160]	; (8009798 <cmdGPIO+0x144>)
 80096f8:	68b8      	ldr	r0, [r7, #8]
        uint8_t portId = strToInt(argv[0], 10);
 80096fa:	b2f6      	uxtb	r6, r6
            if(!strcmp(argv[2], "off")) {
 80096fc:	f7fa fa60 	bl	8003bc0 <strcmp>
 8009700:	b928      	cbnz	r0, 800970e <cmdGPIO+0xba>
                gpioPortIoDisable(portId, true);
 8009702:	2101      	movs	r1, #1
                gpioPortIoDisable(portId, false);
 8009704:	4630      	mov	r0, r6
}
 8009706:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioPortIoDisable(portId, false);
 800970a:	f7fa be75 	b.w	80043f8 <gpioPortIoDisable>
 800970e:	4641      	mov	r1, r8
 8009710:	e7f8      	b.n	8009704 <cmdGPIO+0xb0>
            uint8_t pinId = strToInt(argv[1], 10);
 8009712:	210a      	movs	r1, #10
 8009714:	4620      	mov	r0, r4
 8009716:	f7fa fd5c 	bl	80041d2 <strToInt>
            uint16_t pin = MAKE_GPIO(portId, pinId);
 800971a:	b2c4      	uxtb	r4, r0
 800971c:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
            if(!strcmp(argv[2], "output")) {
 8009720:	68be      	ldr	r6, [r7, #8]
 8009722:	491e      	ldr	r1, [pc, #120]	; (800979c <cmdGPIO+0x148>)
 8009724:	4630      	mov	r0, r6
            uint16_t pin = MAKE_GPIO(portId, pinId);
 8009726:	b2a4      	uxth	r4, r4
            if(!strcmp(argv[2], "output")) {
 8009728:	f7fa fa4a 	bl	8003bc0 <strcmp>
 800972c:	b928      	cbnz	r0, 800973a <cmdGPIO+0xe6>
                gpioSetPinMode(pin, PAL_MODE_OUTPUT_PUSHPULL);
 800972e:	2106      	movs	r1, #6
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 8009730:	4620      	mov	r0, r4
}
 8009732:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 8009736:	f7fd bde5 	b.w	8007304 <gpioSetPinMode.isra.0>
            } else if(!strcmp(argv[2], "input")) {
 800973a:	4630      	mov	r0, r6
 800973c:	4918      	ldr	r1, [pc, #96]	; (80097a0 <cmdGPIO+0x14c>)
 800973e:	f7fa fa3f 	bl	8003bc0 <strcmp>
 8009742:	b908      	cbnz	r0, 8009748 <cmdGPIO+0xf4>
                gpioSetPinMode(pin, PAL_MODE_INPUT);
 8009744:	2102      	movs	r1, #2
 8009746:	e7f3      	b.n	8009730 <cmdGPIO+0xdc>
            } else if(!strcmp(argv[2], "set")) {
 8009748:	4630      	mov	r0, r6
 800974a:	4916      	ldr	r1, [pc, #88]	; (80097a4 <cmdGPIO+0x150>)
 800974c:	f7fa fa38 	bl	8003bc0 <strcmp>
 8009750:	b928      	cbnz	r0, 800975e <cmdGPIO+0x10a>
                gpioSetPin(pin, true);
 8009752:	2101      	movs	r1, #1
 8009754:	4620      	mov	r0, r4
}
 8009756:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                gpioSetPin(pin, false);
 800975a:	f7fd bee7 	b.w	800752c <gpioSetPin.isra.0>
            } else if(!strcmp(argv[2], "clear")) {
 800975e:	4912      	ldr	r1, [pc, #72]	; (80097a8 <cmdGPIO+0x154>)
 8009760:	4630      	mov	r0, r6
 8009762:	f7fa fa2d 	bl	8003bc0 <strcmp>
 8009766:	4601      	mov	r1, r0
                gpioSetPin(pin, false);
 8009768:	4620      	mov	r0, r4
            } else if(!strcmp(argv[2], "clear")) {
 800976a:	2900      	cmp	r1, #0
 800976c:	d0f3      	beq.n	8009756 <cmdGPIO+0x102>
                chprintf(chp, "Value: %u"SHELL_NEWLINE_STR, gpioGetPin(pin));
 800976e:	f7fa fe31 	bl	80043d4 <gpioGetPin>
 8009772:	490e      	ldr	r1, [pc, #56]	; (80097ac <cmdGPIO+0x158>)
 8009774:	4602      	mov	r2, r0
 8009776:	4628      	mov	r0, r5
}
 8009778:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                chprintf(chp, "Value: %u"SHELL_NEWLINE_STR, gpioGetPin(pin));
 800977c:	f7fe bfe7 	b.w	800874e <chprintf>
 8009780:	0800c06f 	.word	0x0800c06f
 8009784:	20000928 	.word	0x20000928
 8009788:	0800c076 	.word	0x0800c076
 800978c:	0800c080 	.word	0x0800c080
 8009790:	0800be60 	.word	0x0800be60
 8009794:	0800c092 	.word	0x0800c092
 8009798:	0800c096 	.word	0x0800c096
 800979c:	0800c09a 	.word	0x0800c09a
 80097a0:	0800c0a1 	.word	0x0800c0a1
 80097a4:	0800c0a7 	.word	0x0800c0a7
 80097a8:	0800c0ab 	.word	0x0800c0ab
 80097ac:	0800c0b1 	.word	0x0800c0b1

080097b0 <cmdConvert>:
    chprintf(chp, "\tconvert hs [shfband] [1/0]"SHELL_NEWLINE_STR);
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
}

void cmdConvert(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 80097b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ConverterManager* converter = (ConverterManager*)user;

    if(argc == 1) {
 80097b4:	2a01      	cmp	r2, #1
{
 80097b6:	4605      	mov	r5, r0
 80097b8:	460c      	mov	r4, r1
 80097ba:	4690      	mov	r8, r2
 80097bc:	461e      	mov	r6, r3
 80097be:	b088      	sub	sp, #32
    if(argc == 1) {
 80097c0:	d177      	bne.n	80098b2 <cmdConvert+0x102>
        if(!strcmp(argv[0], "status")) {
 80097c2:	4968      	ldr	r1, [pc, #416]	; (8009964 <cmdConvert+0x1b4>)
 80097c4:	6818      	ldr	r0, [r3, #0]
 80097c6:	f7fa f9fb 	bl	8003bc0 <strcmp>
 80097ca:	4606      	mov	r6, r0
 80097cc:	2800      	cmp	r0, #0
 80097ce:	f040 80bb 	bne.w	8009948 <cmdConvert+0x198>
    return true;
}

void converterStatus(BaseSequentialStream* chp, ConverterManager* converter)
{
    chprintf(chp, "Bands: [Disable mask: 0x%08x]"SHELL_NEWLINE_STR, converter->disabledBands);
 80097d2:	69ea      	ldr	r2, [r5, #28]
 80097d4:	4964      	ldr	r1, [pc, #400]	; (8009968 <cmdConvert+0x1b8>)
 80097d6:	4620      	mov	r0, r4
 80097d8:	f7fe ffb9 	bl	800874e <chprintf>
    printfFixed(chp, 9, "\tBand ID");
 80097dc:	2109      	movs	r1, #9
 80097de:	4a63      	ldr	r2, [pc, #396]	; (800996c <cmdConvert+0x1bc>)
 80097e0:	4620      	mov	r0, r4
 80097e2:	f7ff f961 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 7, "Name");
 80097e6:	2107      	movs	r1, #7
 80097e8:	4a61      	ldr	r2, [pc, #388]	; (8009970 <cmdConvert+0x1c0>)
 80097ea:	4620      	mov	r0, r4
 80097ec:	f7ff f95c 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 14, "FreqMin [kHz]");
 80097f0:	210e      	movs	r1, #14
 80097f2:	4a60      	ldr	r2, [pc, #384]	; (8009974 <cmdConvert+0x1c4>)
 80097f4:	4620      	mov	r0, r4
 80097f6:	f7ff f957 	bl	8008aa8 <printfFixed>
    chprintf(chp,	     "FreqMax [kHz]"SHELL_NEWLINE_STR);
 80097fa:	4620      	mov	r0, r4
 80097fc:	495e      	ldr	r1, [pc, #376]	; (8009978 <cmdConvert+0x1c8>)
 80097fe:	f7fe ffa6 	bl	800874e <chprintf>
        if(i == converter->activeBand) {
            printfFixed(chp, 9, "\t%u [*]", i);
        } else {
            printfFixed(chp, 9, "\t%u", i);
        }
        printfFixed(chp, 7, "%s", converter->bands[i].bandName);
 8009802:	f8df 8178 	ldr.w	r8, [pc, #376]	; 800997c <cmdConvert+0x1cc>
        printfFixed(chp, 14, "%u", converter->bands[i].minFrequencyKHz);
 8009806:	f8df 9178 	ldr.w	r9, [pc, #376]	; 8009980 <cmdConvert+0x1d0>
        chprintf(chp,	     "%u"SHELL_NEWLINE_STR, converter->bands[i].maxFrequencyKHz);
 800980a:	f8df a178 	ldr.w	sl, [pc, #376]	; 8009984 <cmdConvert+0x1d4>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 800980e:	2714      	movs	r7, #20
 8009810:	b2f3      	uxtb	r3, r6
 8009812:	435f      	muls	r7, r3
 8009814:	696a      	ldr	r2, [r5, #20]
 8009816:	443a      	add	r2, r7
 8009818:	6912      	ldr	r2, [r2, #16]
 800981a:	b96a      	cbnz	r2, 8009838 <cmdConvert+0x88>
    }

    chprintf(chp, SHELL_NEWLINE_STR);
 800981c:	4620      	mov	r0, r4
 800981e:	495a      	ldr	r1, [pc, #360]	; (8009988 <cmdConvert+0x1d8>)
 8009820:	f7fe ff95 	bl	800874e <chprintf>

    if(converter->activeBand == 0xff) {
 8009824:	7e2b      	ldrb	r3, [r5, #24]
 8009826:	2bff      	cmp	r3, #255	; 0xff
 8009828:	d12c      	bne.n	8009884 <cmdConvert+0xd4>
        chprintf(chp, "Converter disabled." SHELL_NEWLINE_STR);
 800982a:	4958      	ldr	r1, [pc, #352]	; (800998c <cmdConvert+0x1dc>)
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 800982c:	4620      	mov	r0, r4
            return;
        }
    }

    cmdConvertUsage(chp);
}
 800982e:	b008      	add	sp, #32
 8009830:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 8009834:	f7fe bf8b 	b.w	800874e <chprintf>
        if(_BV(i) & converter-> disabledBands) {
 8009838:	69ea      	ldr	r2, [r5, #28]
 800983a:	40da      	lsrs	r2, r3
 800983c:	07d1      	lsls	r1, r2, #31
 800983e:	d41f      	bmi.n	8009880 <cmdConvert+0xd0>
        if(i == converter->activeBand) {
 8009840:	7e2a      	ldrb	r2, [r5, #24]
            printfFixed(chp, 9, "\t%u", i);
 8009842:	2109      	movs	r1, #9
        if(i == converter->activeBand) {
 8009844:	429a      	cmp	r2, r3
            printfFixed(chp, 9, "\t%u [*]", i);
 8009846:	bf0a      	itet	eq
 8009848:	4613      	moveq	r3, r2
            printfFixed(chp, 9, "\t%u", i);
 800984a:	4a51      	ldrne	r2, [pc, #324]	; (8009990 <cmdConvert+0x1e0>)
            printfFixed(chp, 9, "\t%u [*]", i);
 800984c:	4a51      	ldreq	r2, [pc, #324]	; (8009994 <cmdConvert+0x1e4>)
            printfFixed(chp, 9, "\t%u", i);
 800984e:	4620      	mov	r0, r4
 8009850:	f7ff f92a 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 7, "%s", converter->bands[i].bandName);
 8009854:	696b      	ldr	r3, [r5, #20]
 8009856:	4642      	mov	r2, r8
 8009858:	2107      	movs	r1, #7
 800985a:	59db      	ldr	r3, [r3, r7]
 800985c:	4620      	mov	r0, r4
 800985e:	f7ff f923 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 14, "%u", converter->bands[i].minFrequencyKHz);
 8009862:	696b      	ldr	r3, [r5, #20]
 8009864:	464a      	mov	r2, r9
 8009866:	443b      	add	r3, r7
 8009868:	210e      	movs	r1, #14
 800986a:	685b      	ldr	r3, [r3, #4]
 800986c:	4620      	mov	r0, r4
 800986e:	f7ff f91b 	bl	8008aa8 <printfFixed>
        chprintf(chp,	     "%u"SHELL_NEWLINE_STR, converter->bands[i].maxFrequencyKHz);
 8009872:	696b      	ldr	r3, [r5, #20]
 8009874:	4651      	mov	r1, sl
 8009876:	443b      	add	r3, r7
 8009878:	4620      	mov	r0, r4
 800987a:	689a      	ldr	r2, [r3, #8]
 800987c:	f7fe ff67 	bl	800874e <chprintf>
    for(uint8_t i=0; converter->bands[i].functions; i++) {
 8009880:	3601      	adds	r6, #1
 8009882:	e7c4      	b.n	800980e <cmdConvert+0x5e>
    } else {
        chprintf(chp, "Input Frequency:    %u kHz" SHELL_NEWLINE_STR, converter->currentTune.inputFrequencyKHz);
 8009884:	682a      	ldr	r2, [r5, #0]
 8009886:	4620      	mov	r0, r4
 8009888:	4943      	ldr	r1, [pc, #268]	; (8009998 <cmdConvert+0x1e8>)
 800988a:	f7fe ff60 	bl	800874e <chprintf>
        chprintf(chp, "Output Frequency:   %u kHz" SHELL_NEWLINE_STR, converter->currentTune.outputFrequencyKHz);
 800988e:	68ea      	ldr	r2, [r5, #12]
 8009890:	4620      	mov	r0, r4
 8009892:	4942      	ldr	r1, [pc, #264]	; (800999c <cmdConvert+0x1ec>)
 8009894:	f7fe ff5b 	bl	800874e <chprintf>
        chprintf(chp, "Spectral inversion: %u" SHELL_NEWLINE_STR, converter->currentTune.spectrumInversion);
 8009898:	7c2a      	ldrb	r2, [r5, #16]
 800989a:	4620      	mov	r0, r4
 800989c:	4940      	ldr	r1, [pc, #256]	; (80099a0 <cmdConvert+0x1f0>)
 800989e:	f7fe ff56 	bl	800874e <chprintf>
        chprintf(chp, "Selected antenna:   %u" SHELL_NEWLINE_STR , converter->currentTune.antennaInput);
 80098a2:	4620      	mov	r0, r4
 80098a4:	686a      	ldr	r2, [r5, #4]
 80098a6:	493f      	ldr	r1, [pc, #252]	; (80099a4 <cmdConvert+0x1f4>)
}
 80098a8:	b008      	add	sp, #32
 80098aa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80098ae:	f7fe bf4e 	b.w	800874e <chprintf>
    } else if (argc >= 2) {
 80098b2:	dd49      	ble.n	8009948 <cmdConvert+0x198>
        if(argc == 3 && !strcmp(argv[0], "hs")) {
 80098b4:	2a03      	cmp	r2, #3
        if(!strcmp(argv[0], "status")) {
 80098b6:	681f      	ldr	r7, [r3, #0]
        if(argc == 3 && !strcmp(argv[0], "hs")) {
 80098b8:	d117      	bne.n	80098ea <cmdConvert+0x13a>
 80098ba:	4638      	mov	r0, r7
 80098bc:	493a      	ldr	r1, [pc, #232]	; (80099a8 <cmdConvert+0x1f8>)
 80098be:	f7fa f97f 	bl	8003bc0 <strcmp>
 80098c2:	b990      	cbnz	r0, 80098ea <cmdConvert+0x13a>
            uint32_t band = strToInt(argv[1], 10);
 80098c4:	210a      	movs	r1, #10
 80098c6:	6870      	ldr	r0, [r6, #4]
 80098c8:	f7fa fc83 	bl	80041d2 <strToInt>
            if(band < sizeof(converterSHFBandConfig)/sizeof(ConverterSHFConfig)) {
 80098cc:	2803      	cmp	r0, #3
 80098ce:	d80c      	bhi.n	80098ea <cmdConvert+0x13a>
                converterSHFBandConfig[band].useHighSideMixing = (argv[2][0] == '1');
 80098d0:	230c      	movs	r3, #12
 80098d2:	4358      	muls	r0, r3
 80098d4:	68b3      	ldr	r3, [r6, #8]
 80098d6:	781b      	ldrb	r3, [r3, #0]
 80098d8:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 80098dc:	4253      	negs	r3, r2
 80098de:	4153      	adcs	r3, r2
 80098e0:	4a32      	ldr	r2, [pc, #200]	; (80099ac <cmdConvert+0x1fc>)
 80098e2:	5413      	strb	r3, [r2, r0]
}
 80098e4:	b008      	add	sp, #32
 80098e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(!strcmp(argv[0], "setup")) {
 80098ea:	4638      	mov	r0, r7
 80098ec:	4930      	ldr	r1, [pc, #192]	; (80099b0 <cmdConvert+0x200>)
 80098ee:	f7fa f967 	bl	8003bc0 <strcmp>
 80098f2:	4607      	mov	r7, r0
 80098f4:	bb40      	cbnz	r0, 8009948 <cmdConvert+0x198>
            uint32_t frequency = strToInt(argv[1], 10);
 80098f6:	210a      	movs	r1, #10
 80098f8:	6870      	ldr	r0, [r6, #4]
 80098fa:	f7fa fc6a 	bl	80041d2 <strToInt>
            if(argc >= 3) {
 80098fe:	f1b8 0f02 	cmp.w	r8, #2
            tuneRequest.antennaInput = 0;
 8009902:	e9cd 0703 	strd	r0, r7, [sp, #12]
            if(argc >= 3) {
 8009906:	d111      	bne.n	800992c <cmdConvert+0x17c>
            tuneRequest.forceBand = false;
 8009908:	f88d 7014 	strb.w	r7, [sp, #20]
            bool result = converterTune(converter, &tuneRequest);
 800990c:	4628      	mov	r0, r5
 800990e:	a903      	add	r1, sp, #12
 8009910:	f7fa fde0 	bl	80044d4 <converterTune>
            if(result) {
 8009914:	b198      	cbz	r0, 800993e <cmdConvert+0x18e>
                chprintf(chp, "IF Frequency: %u kHz, inversion: %u (band %u)"SHELL_NEWLINE_STR, tuneRequest.outputFrequencyKHz, tuneRequest.spectrumInversion, tuneRequest.bandId);
 8009916:	f89d 3015 	ldrb.w	r3, [sp, #21]
 800991a:	4620      	mov	r0, r4
 800991c:	9300      	str	r3, [sp, #0]
 800991e:	9a06      	ldr	r2, [sp, #24]
 8009920:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8009924:	4923      	ldr	r1, [pc, #140]	; (80099b4 <cmdConvert+0x204>)
 8009926:	f7fe ff12 	bl	800874e <chprintf>
 800992a:	e7db      	b.n	80098e4 <cmdConvert+0x134>
                tuneRequest.forceBand = true;
 800992c:	2301      	movs	r3, #1
                tuneRequest.bandId = strToInt(argv[2], 10);
 800992e:	68b0      	ldr	r0, [r6, #8]
                tuneRequest.forceBand = true;
 8009930:	f88d 3014 	strb.w	r3, [sp, #20]
                tuneRequest.bandId = strToInt(argv[2], 10);
 8009934:	f7fa fc4d 	bl	80041d2 <strToInt>
 8009938:	f88d 0015 	strb.w	r0, [sp, #21]
 800993c:	e7e6      	b.n	800990c <cmdConvert+0x15c>
                chprintf(chp, "Error!"SHELL_NEWLINE_STR);
 800993e:	4620      	mov	r0, r4
 8009940:	491d      	ldr	r1, [pc, #116]	; (80099b8 <cmdConvert+0x208>)
 8009942:	f7fe ff04 	bl	800874e <chprintf>
            return;
 8009946:	e7cd      	b.n	80098e4 <cmdConvert+0x134>
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 8009948:	491c      	ldr	r1, [pc, #112]	; (80099bc <cmdConvert+0x20c>)
 800994a:	4620      	mov	r0, r4
 800994c:	f7fe feff 	bl	800874e <chprintf>
    chprintf(chp, "\tconvert setup [freqkHz] [forceBand]"SHELL_NEWLINE_STR);
 8009950:	491b      	ldr	r1, [pc, #108]	; (80099c0 <cmdConvert+0x210>)
 8009952:	4620      	mov	r0, r4
 8009954:	f7fe fefb 	bl	800874e <chprintf>
    chprintf(chp, "\tconvert hs [shfband] [1/0]"SHELL_NEWLINE_STR);
 8009958:	491a      	ldr	r1, [pc, #104]	; (80099c4 <cmdConvert+0x214>)
 800995a:	4620      	mov	r0, r4
 800995c:	f7fe fef7 	bl	800874e <chprintf>
    chprintf(chp, "\tconvert status"SHELL_NEWLINE_STR);
 8009960:	4919      	ldr	r1, [pc, #100]	; (80099c8 <cmdConvert+0x218>)
 8009962:	e763      	b.n	800982c <cmdConvert+0x7c>
 8009964:	0800c06f 	.word	0x0800c06f
 8009968:	0800c0bd 	.word	0x0800c0bd
 800996c:	0800c0dd 	.word	0x0800c0dd
 8009970:	0800c352 	.word	0x0800c352
 8009974:	0800c0e6 	.word	0x0800c0e6
 8009978:	0800c0f4 	.word	0x0800c0f4
 800997c:	0800bc80 	.word	0x0800bc80
 8009980:	0800c10d 	.word	0x0800c10d
 8009984:	0800c18d 	.word	0x0800c18d
 8009988:	0800be60 	.word	0x0800be60
 800998c:	0800c110 	.word	0x0800c110
 8009990:	0800c10c 	.word	0x0800c10c
 8009994:	0800c104 	.word	0x0800c104
 8009998:	0800c126 	.word	0x0800c126
 800999c:	0800c143 	.word	0x0800c143
 80099a0:	0800c160 	.word	0x0800c160
 80099a4:	0800c179 	.word	0x0800c179
 80099a8:	0800c192 	.word	0x0800c192
 80099ac:	2000080c 	.word	0x2000080c
 80099b0:	0800c195 	.word	0x0800c195
 80099b4:	0800c19b 	.word	0x0800c19b
 80099b8:	0800c1cb 	.word	0x0800c1cb
 80099bc:	0800bc69 	.word	0x0800bc69
 80099c0:	0800c1d4 	.word	0x0800c1d4
 80099c4:	0800c1fb 	.word	0x0800c1fb
 80099c8:	0800c219 	.word	0x0800c219

080099cc <cmdReboot>:
{
 80099cc:	b538      	push	{r3, r4, r5, lr}
 80099ce:	460c      	mov	r4, r1
    if(argc == 0) {
 80099d0:	b9ca      	cbnz	r2, 8009a06 <cmdReboot+0x3a>
        chprintf(chp,"Usage:"SHELL_NEWLINE_STR);
 80099d2:	4927      	ldr	r1, [pc, #156]	; (8009a70 <cmdReboot+0xa4>)
 80099d4:	4620      	mov	r0, r4
 80099d6:	f7fe feba 	bl	800874e <chprintf>
        chprintf(chp,"\t reboot nvic"SHELL_NEWLINE_STR);
 80099da:	4926      	ldr	r1, [pc, #152]	; (8009a74 <cmdReboot+0xa8>)
 80099dc:	4620      	mov	r0, r4
 80099de:	f7fe feb6 	bl	800874e <chprintf>
        chprintf(chp,"\t reboot loader"SHELL_NEWLINE_STR);
 80099e2:	4925      	ldr	r1, [pc, #148]	; (8009a78 <cmdReboot+0xac>)
 80099e4:	4620      	mov	r0, r4
 80099e6:	f7fe feb2 	bl	800874e <chprintf>
        chprintf(chp,"\t reboot loaderp"SHELL_NEWLINE_STR);
 80099ea:	4924      	ldr	r1, [pc, #144]	; (8009a7c <cmdReboot+0xb0>)
 80099ec:	4620      	mov	r0, r4
 80099ee:	f7fe feae 	bl	800874e <chprintf>
        chprintf(chp,"\t reboot crash"SHELL_NEWLINE_STR);
 80099f2:	4923      	ldr	r1, [pc, #140]	; (8009a80 <cmdReboot+0xb4>)
 80099f4:	4620      	mov	r0, r4
 80099f6:	f7fe feaa 	bl	800874e <chprintf>
        chprintf(chp,"\t reboot memexec"SHELL_NEWLINE_STR);
 80099fa:	4922      	ldr	r1, [pc, #136]	; (8009a84 <cmdReboot+0xb8>)
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 80099fc:	4620      	mov	r0, r4
}
 80099fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 8009a02:	f7fe bea4 	b.w	800874e <chprintf>
    } else if(argc == 1 && !strcmp(argv[0], "loaderp")) {
 8009a06:	2a01      	cmp	r2, #1
 8009a08:	d12f      	bne.n	8009a6a <cmdReboot+0x9e>
 8009a0a:	681d      	ldr	r5, [r3, #0]
 8009a0c:	491e      	ldr	r1, [pc, #120]	; (8009a88 <cmdReboot+0xbc>)
 8009a0e:	4628      	mov	r0, r5
 8009a10:	f7fa f8d6 	bl	8003bc0 <strcmp>
 8009a14:	b1f0      	cbz	r0, 8009a54 <cmdReboot+0x88>
    } else if(argc == 1 && !strcmp(argv[0], "loader")) {
 8009a16:	4628      	mov	r0, r5
 8009a18:	491c      	ldr	r1, [pc, #112]	; (8009a8c <cmdReboot+0xc0>)
 8009a1a:	f7fa f8d1 	bl	8003bc0 <strcmp>
 8009a1e:	b1d8      	cbz	r0, 8009a58 <cmdReboot+0x8c>
    } else if(argc == 1 && !strcmp(argv[0], "crash")) {
 8009a20:	4628      	mov	r0, r5
 8009a22:	491b      	ldr	r1, [pc, #108]	; (8009a90 <cmdReboot+0xc4>)
 8009a24:	f7fa f8cc 	bl	8003bc0 <strcmp>
 8009a28:	b910      	cbnz	r0, 8009a30 <cmdReboot+0x64>
        osalSysHalt("crash");
 8009a2a:	f7fa ffc3 	bl	80049b4 <vTaskEndScheduler>
 8009a2e:	e7fe      	b.n	8009a2e <cmdReboot+0x62>
    } else if(argc == 1 && !strcmp(argv[0], "memexec")) {
 8009a30:	4628      	mov	r0, r5
 8009a32:	4918      	ldr	r1, [pc, #96]	; (8009a94 <cmdReboot+0xc8>)
 8009a34:	f7fa f8c4 	bl	8003bc0 <strcmp>
 8009a38:	b9b8      	cbnz	r0, 8009a6a <cmdReboot+0x9e>
        if(callIt(4) == 5 && callIt(54) == 55) {
 8009a3a:	2004      	movs	r0, #4
        uint32_t (*callIt)(uint32_t) = (uint32_t(*)(uint32_t))(incr0bxlr+1); /* +1 for thumb mode */
 8009a3c:	4d16      	ldr	r5, [pc, #88]	; (8009a98 <cmdReboot+0xcc>)
        if(callIt(4) == 5 && callIt(54) == 55) {
 8009a3e:	47a8      	blx	r5
 8009a40:	2805      	cmp	r0, #5
 8009a42:	d105      	bne.n	8009a50 <cmdReboot+0x84>
 8009a44:	2036      	movs	r0, #54	; 0x36
 8009a46:	47a8      	blx	r5
 8009a48:	2837      	cmp	r0, #55	; 0x37
 8009a4a:	d101      	bne.n	8009a50 <cmdReboot+0x84>
            chprintf(chp, "Success!"SHELL_NEWLINE_STR);
 8009a4c:	4913      	ldr	r1, [pc, #76]	; (8009a9c <cmdReboot+0xd0>)
 8009a4e:	e7d5      	b.n	80099fc <cmdReboot+0x30>
            chprintf(chp, "Wrong result!"SHELL_NEWLINE_STR);
 8009a50:	4913      	ldr	r1, [pc, #76]	; (8009aa0 <cmdReboot+0xd4>)
 8009a52:	e7d3      	b.n	80099fc <cmdReboot+0x30>
        rebootCode = 0x424C;
 8009a54:	f244 204c 	movw	r0, #16972	; 0x424c
    RCC->APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8009a58:	4a12      	ldr	r2, [pc, #72]	; (8009aa4 <cmdReboot+0xd8>)
 8009a5a:	69d3      	ldr	r3, [r2, #28]
 8009a5c:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8009a60:	61d3      	str	r3, [r2, #28]
    BKP->DR10 = rebootCode;
 8009a62:	4b11      	ldr	r3, [pc, #68]	; (8009aa8 <cmdReboot+0xdc>)
 8009a64:	6298      	str	r0, [r3, #40]	; 0x28
    NVIC_SystemReset();
 8009a66:	f7fa fbe3 	bl	8004230 <NVIC_SystemReset.lto_priv.0>
        rebootCode = 0x424D;
 8009a6a:	f244 204d 	movw	r0, #16973	; 0x424d
 8009a6e:	e7f3      	b.n	8009a58 <cmdReboot+0x8c>
 8009a70:	0800bc69 	.word	0x0800bc69
 8009a74:	0800c22b 	.word	0x0800c22b
 8009a78:	0800c23b 	.word	0x0800c23b
 8009a7c:	0800c24d 	.word	0x0800c24d
 8009a80:	0800c260 	.word	0x0800c260
 8009a84:	0800c271 	.word	0x0800c271
 8009a88:	0800c284 	.word	0x0800c284
 8009a8c:	0800c28c 	.word	0x0800c28c
 8009a90:	0800c293 	.word	0x0800c293
 8009a94:	0800c299 	.word	0x0800c299
 8009a98:	2000084d 	.word	0x2000084d
 8009a9c:	0800c2a1 	.word	0x0800c2a1
 8009aa0:	0800c2ac 	.word	0x0800c2ac
 8009aa4:	40021000 	.word	0x40021000
 8009aa8:	40006c00 	.word	0x40006c00

08009aac <cmdSyslog>:
{
 8009aac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(argc == 1 && !strcmp(argv[0], "clear")) {
 8009ab0:	2a01      	cmp	r2, #1
{
 8009ab2:	460d      	mov	r5, r1
 8009ab4:	461c      	mov	r4, r3
 8009ab6:	b087      	sub	sp, #28
    if(argc == 1 && !strcmp(argv[0], "clear")) {
 8009ab8:	d117      	bne.n	8009aea <cmdSyslog+0x3e>
 8009aba:	4942      	ldr	r1, [pc, #264]	; (8009bc4 <cmdSyslog+0x118>)
 8009abc:	6818      	ldr	r0, [r3, #0]
 8009abe:	f7fa f87f 	bl	8003bc0 <strcmp>
 8009ac2:	4604      	mov	r4, r0
 8009ac4:	b9f8      	cbnz	r0, 8009b06 <cmdSyslog+0x5a>
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009ac6:	4b40      	ldr	r3, [pc, #256]	; (8009bc8 <cmdSyslog+0x11c>)
 8009ac8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009acc:	681d      	ldr	r5, [r3, #0]
 8009ace:	4628      	mov	r0, r5
 8009ad0:	f7fb fcb2 	bl	8005438 <xQueueSemaphoreTake>
    }
}

void packetQueueInit(PacketQueue_t* queue, void* buffer, uint32_t bufferSize)
{
    memset(queue, 0, sizeof(*queue));
 8009ad4:	221c      	movs	r2, #28
 8009ad6:	4621      	mov	r1, r4
 8009ad8:	483c      	ldr	r0, [pc, #240]	; (8009bcc <cmdSyslog+0x120>)
 8009ada:	f001 fe97 	bl	800b80c <memset>
    xSemaphoreGive(syslogSemaphore);
 8009ade:	4628      	mov	r0, r5
}
 8009ae0:	b007      	add	sp, #28
 8009ae2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            i += readBytes;
        }
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
    }
    packetQueueEndReadTransaction(&syslogQueue, true);
    xSemaphoreGive(syslogSemaphore);
 8009ae6:	f7fe bccd 	b.w	8008484 <xQueueGenericSend.constprop.0>
    } else if(argc == 2 && !strcmp(argv[0], "add")) {
 8009aea:	2a02      	cmp	r2, #2
 8009aec:	d10b      	bne.n	8009b06 <cmdSyslog+0x5a>
 8009aee:	4938      	ldr	r1, [pc, #224]	; (8009bd0 <cmdSyslog+0x124>)
 8009af0:	6818      	ldr	r0, [r3, #0]
 8009af2:	f7fa f865 	bl	8003bc0 <strcmp>
 8009af6:	b930      	cbnz	r0, 8009b06 <cmdSyslog+0x5a>
        syslog("%s", argv[1]);
 8009af8:	6861      	ldr	r1, [r4, #4]
 8009afa:	4836      	ldr	r0, [pc, #216]	; (8009bd4 <cmdSyslog+0x128>)
}
 8009afc:	b007      	add	sp, #28
 8009afe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        syslog("%s", argv[1]);
 8009b02:	f7ff b941 	b.w	8008d88 <syslog>
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009b06:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8009bc8 <cmdSyslog+0x11c>
    if(syslogQueue.numDropped) {
 8009b0a:	4c33      	ldr	r4, [pc, #204]	; (8009bd8 <cmdSyslog+0x12c>)
    xSemaphoreTake(syslogSemaphore, portMAX_DELAY);
 8009b0c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8009b10:	f8d8 0000 	ldr.w	r0, [r8]
 8009b14:	f7fb fc90 	bl	8005438 <xQueueSemaphoreTake>
    if(syslogQueue.numDropped) {
 8009b18:	6a22      	ldr	r2, [r4, #32]
 8009b1a:	b11a      	cbz	r2, 8009b24 <cmdSyslog+0x78>
        chprintf(chp, "... %u dropped ..."SHELL_NEWLINE_STR, syslogQueue.numDropped);
 8009b1c:	4628      	mov	r0, r5
 8009b1e:	492f      	ldr	r1, [pc, #188]	; (8009bdc <cmdSyslog+0x130>)
 8009b20:	f7fe fe15 	bl	800874e <chprintf>
    queue->readPtrStored = queue->readPtr;
 8009b24:	68a3      	ldr	r3, [r4, #8]
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
 8009b26:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 8009be0 <cmdSyslog+0x134>
 8009b2a:	60e3      	str	r3, [r4, #12]
    queue->pktCountStored = queue->pktCount;
 8009b2c:	8aa3      	ldrh	r3, [r4, #20]
 8009b2e:	82e3      	strh	r3, [r4, #22]
    if(!queue->pktCount) {
 8009b30:	8aa3      	ldrh	r3, [r4, #20]
 8009b32:	b943      	cbnz	r3, 8009b46 <cmdSyslog+0x9a>
        queue->readPtr = queue->readPtrStored;
 8009b34:	68e3      	ldr	r3, [r4, #12]
    xSemaphoreGive(syslogSemaphore);
 8009b36:	f8d8 0000 	ldr.w	r0, [r8]
 8009b3a:	60a3      	str	r3, [r4, #8]
        queue->pktCount = queue->pktCountStored;
 8009b3c:	8ae3      	ldrh	r3, [r4, #22]
 8009b3e:	82a3      	strh	r3, [r4, #20]
 8009b40:	e7ce      	b.n	8009ae0 <cmdSyslog+0x34>
        return 0;
 8009b42:	463e      	mov	r6, r7
 8009b44:	e02a      	b.n	8009b9c <cmdSyslog+0xf0>
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009b46:	f7fc fa07 	bl	8005f58 <packetQueueReadByte.constprop.0>
 8009b4a:	4606      	mov	r6, r0
                    (packetQueueReadByte(queue));
 8009b4c:	f7fc fa04 	bl	8005f58 <packetQueueReadByte.constprop.0>
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009b50:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
    return queue->pktLen;
 8009b54:	b283      	uxth	r3, r0
    queue->pktLen = (packetQueueReadByte(queue) << 8) |
 8009b56:	61a0      	str	r0, [r4, #24]
    return queue->pktLen;
 8009b58:	9300      	str	r3, [sp, #0]
    while((len = packetQueueReadPacket(&syslogQueue))) {
 8009b5a:	2800      	cmp	r0, #0
 8009b5c:	d0ea      	beq.n	8009b34 <cmdSyslog+0x88>
        uint16_t i = 0;
 8009b5e:	f04f 0900 	mov.w	r9, #0
    if(!queue->pktLen) {
 8009b62:	69a7      	ldr	r7, [r4, #24]
 8009b64:	2f00      	cmp	r7, #0
 8009b66:	d0ec      	beq.n	8009b42 <cmdSyslog+0x96>
    if(bufLen > queue->pktLen) {
 8009b68:	2f0c      	cmp	r7, #12
 8009b6a:	bf28      	it	cs
 8009b6c:	270c      	movcs	r7, #12
        for(uint16_t i=0; i<bufLen; i++) {
 8009b6e:	f04f 0b00 	mov.w	fp, #0
 8009b72:	b2be      	uxth	r6, r7
 8009b74:	aa03      	add	r2, sp, #12
 8009b76:	9201      	str	r2, [sp, #4]
            buffer[i] = packetQueueReadByte(queue);
 8009b78:	f7fc f9ee 	bl	8005f58 <packetQueueReadByte.constprop.0>
        for(uint16_t i=0; i<bufLen; i++) {
 8009b7c:	f10b 0b01 	add.w	fp, fp, #1
            buffer[i] = packetQueueReadByte(queue);
 8009b80:	9a01      	ldr	r2, [sp, #4]
        for(uint16_t i=0; i<bufLen; i++) {
 8009b82:	fa1f fb8b 	uxth.w	fp, fp
 8009b86:	45b3      	cmp	fp, r6
            buffer[i] = packetQueueReadByte(queue);
 8009b88:	f802 0b01 	strb.w	r0, [r2], #1
        for(uint16_t i=0; i<bufLen; i++) {
 8009b8c:	d3f3      	bcc.n	8009b76 <cmdSyslog+0xca>
    queue->pktLen -= bufLen;
 8009b8e:	69a2      	ldr	r2, [r4, #24]
 8009b90:	1bd7      	subs	r7, r2, r7
 8009b92:	61a7      	str	r7, [r4, #24]
    if(!queue->pktLen) {
 8009b94:	b917      	cbnz	r7, 8009b9c <cmdSyslog+0xf0>
        queue->pktCount--;
 8009b96:	8aa2      	ldrh	r2, [r4, #20]
 8009b98:	3a01      	subs	r2, #1
 8009b9a:	82a2      	strh	r2, [r4, #20]
            chnWrite(chp, tmpBuf, readBytes);
 8009b9c:	682a      	ldr	r2, [r5, #0]
 8009b9e:	4628      	mov	r0, r5
 8009ba0:	6817      	ldr	r7, [r2, #0]
 8009ba2:	a903      	add	r1, sp, #12
 8009ba4:	4632      	mov	r2, r6
 8009ba6:	47b8      	blx	r7
            i += readBytes;
 8009ba8:	444e      	add	r6, r9
        while(i < len) {
 8009baa:	9b00      	ldr	r3, [sp, #0]
            i += readBytes;
 8009bac:	fa1f f986 	uxth.w	r9, r6
        while(i < len) {
 8009bb0:	4599      	cmp	r9, r3
 8009bb2:	d3d6      	bcc.n	8009b62 <cmdSyslog+0xb6>
        chnWrite(chp, (uint8_t*)SHELL_NEWLINE_STR, strlen(SHELL_NEWLINE_STR));
 8009bb4:	682b      	ldr	r3, [r5, #0]
 8009bb6:	2202      	movs	r2, #2
 8009bb8:	4651      	mov	r1, sl
 8009bba:	4628      	mov	r0, r5
 8009bbc:	681b      	ldr	r3, [r3, #0]
 8009bbe:	4798      	blx	r3
 8009bc0:	e7b6      	b.n	8009b30 <cmdSyslog+0x84>
 8009bc2:	bf00      	nop
 8009bc4:	0800c0ab 	.word	0x0800c0ab
 8009bc8:	20001334 	.word	0x20001334
 8009bcc:	20001318 	.word	0x20001318
 8009bd0:	0800c2bc 	.word	0x0800c2bc
 8009bd4:	0800bc80 	.word	0x0800bc80
 8009bd8:	20001310 	.word	0x20001310
 8009bdc:	0800c2c0 	.word	0x0800c2c0
 8009be0:	0800be60 	.word	0x0800be60

08009be4 <shellStartThread>:
{
 8009be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009be8:	4681      	mov	r9, r0
  *(scfg->sc_histbuf) = 0;
 8009bea:	f04f 0b00 	mov.w	fp, #0
			pxTCB = prvGetTCBFromHandle( xTaskToSet );
 8009bee:	4bb6      	ldr	r3, [pc, #728]	; (8009ec8 <shellStartThread+0x2e4>)
 8009bf0:	b0a3      	sub	sp, #140	; 0x8c
 8009bf2:	681b      	ldr	r3, [r3, #0]
    syslog("Shell 0x%08x started (%s).", activeShell, activeShell->taskName);
 8009bf4:	4601      	mov	r1, r0
			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
 8009bf6:	65d8      	str	r0, [r3, #92]	; 0x5c
 8009bf8:	6802      	ldr	r2, [r0, #0]
 8009bfa:	48b4      	ldr	r0, [pc, #720]	; (8009ecc <shellStartThread+0x2e8>)
 8009bfc:	f7ff f8c4 	bl	8008d88 <syslog>
  const ShellCommand *scp = scfg->sc_commands;
 8009c00:	e9d9 7301 	ldrd	r7, r3, [r9, #4]
 8009c04:	9302      	str	r3, [sp, #8]
  *(scfg->sc_histbuf) = 0;
 8009c06:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8009c0a:	f883 b000 	strb.w	fp, [r3]
  ShellHistory hist = {
 8009c0e:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8009c12:	e9cd bb0a 	strd	fp, fp, [sp, #40]	; 0x28
 8009c16:	9307      	str	r3, [sp, #28]
 8009c18:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8009c1c:	e9cd 3b08 	strd	r3, fp, [sp, #32]
  chprintf(chp, SHELL_NEWLINE_STR);
 8009c20:	49ab      	ldr	r1, [pc, #684]	; (8009ed0 <shellStartThread+0x2ec>)
 8009c22:	4638      	mov	r0, r7
 8009c24:	f7fe fd93 	bl	800874e <chprintf>
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
#if SHELL_USE_ESC_SEQ == TRUE
  bool escape = false;
  bool bracket = false;
 8009c28:	f04f 0800 	mov.w	r8, #0
  char *p = line;
 8009c2c:	ad12      	add	r5, sp, #72	; 0x48
  bool escape = false;
 8009c2e:	46c2      	mov	sl, r8
 8009c30:	462e      	mov	r6, r5
    chprintf(chp, SHELL_PROMPT_STR);
 8009c32:	4638      	mov	r0, r7
 8009c34:	49a7      	ldr	r1, [pc, #668]	; (8009ed4 <shellStartThread+0x2f0>)
 8009c36:	f7fe fd8a 	bl	800874e <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8009c3a:	f8d9 4004 	ldr.w	r4, [r9, #4]
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8009c3e:	6823      	ldr	r3, [r4, #0]
 8009c40:	2201      	movs	r2, #1
 8009c42:	4620      	mov	r0, r4
 8009c44:	685b      	ldr	r3, [r3, #4]
 8009c46:	f10d 0117 	add.w	r1, sp, #23
 8009c4a:	4798      	blx	r3
 8009c4c:	2800      	cmp	r0, #0
 8009c4e:	d041      	beq.n	8009cd4 <shellStartThread+0xf0>
      return true;
#if SHELL_USE_ESC_SEQ == TRUE
    if (c == 27) {
 8009c50:	f89d 1017 	ldrb.w	r1, [sp, #23]
 8009c54:	291b      	cmp	r1, #27
 8009c56:	f000 8129 	beq.w	8009eac <shellStartThread+0x2c8>
      escape = true;
      continue;
    }
    if (escape) {
 8009c5a:	f1ba 0f00 	cmp.w	sl, #0
 8009c5e:	d033      	beq.n	8009cc8 <shellStartThread+0xe4>
      escape = false;
      if (c == '[') {
 8009c60:	295b      	cmp	r1, #91	; 0x5b
 8009c62:	f000 8126 	beq.w	8009eb2 <shellStartThread+0x2ce>
        escape = true;
        bracket = true;
        continue;
      }
      if (bracket) {
 8009c66:	f1b8 0f00 	cmp.w	r8, #0
 8009c6a:	d02b      	beq.n	8009cc4 <shellStartThread+0xe0>
        bracket = false;
#if SHELL_USE_HISTORY == TRUE
        if (c == 'A') {
 8009c6c:	2941      	cmp	r1, #65	; 0x41
 8009c6e:	d119      	bne.n	8009ca4 <shellStartThread+0xc0>
          int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 8009c70:	2200      	movs	r2, #0
 8009c72:	4631      	mov	r1, r6
 8009c74:	a807      	add	r0, sp, #28
 8009c76:	f7fd ff88 	bl	8007b8a <get_history>

          if (len > 0) {
 8009c7a:	f1b0 0800 	subs.w	r8, r0, #0
 8009c7e:	dd1f      	ble.n	8009cc0 <shellStartThread+0xdc>

          if (len == 0)
            *line = 0;

          if (len >= 0) {
            _shell_reset_cur(chp);
 8009c80:	2308      	movs	r3, #8
 8009c82:	224a      	movs	r2, #74	; 0x4a
 8009c84:	4994      	ldr	r1, [pc, #592]	; (8009ed8 <shellStartThread+0x2f4>)
 8009c86:	4620      	mov	r0, r4
 8009c88:	f7fe fd61 	bl	800874e <chprintf>
            _shell_clr_line(chp);
 8009c8c:	4993      	ldr	r1, [pc, #588]	; (8009edc <shellStartThread+0x2f8>)
 8009c8e:	4620      	mov	r0, r4
 8009c90:	f7fe fd5d 	bl	800874e <chprintf>
            chprintf(chp, "%s", line);
 8009c94:	4632      	mov	r2, r6
 8009c96:	4620      	mov	r0, r4
 8009c98:	4991      	ldr	r1, [pc, #580]	; (8009ee0 <shellStartThread+0x2fc>)
 8009c9a:	f7fe fd58 	bl	800874e <chprintf>
            p = line + len;
 8009c9e:	eb06 0508 	add.w	r5, r6, r8
 8009ca2:	e00d      	b.n	8009cc0 <shellStartThread+0xdc>
        if (c == 'B') {
 8009ca4:	2942      	cmp	r1, #66	; 0x42
 8009ca6:	d10b      	bne.n	8009cc0 <shellStartThread+0xdc>
          int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 8009ca8:	2201      	movs	r2, #1
 8009caa:	4631      	mov	r1, r6
 8009cac:	a807      	add	r0, sp, #28
 8009cae:	f7fd ff6c 	bl	8007b8a <get_history>
          if (len == 0)
 8009cb2:	f1b0 0800 	subs.w	r8, r0, #0
 8009cb6:	d102      	bne.n	8009cbe <shellStartThread+0xda>
            *line = 0;
 8009cb8:	f88d 8048 	strb.w	r8, [sp, #72]	; 0x48
 8009cbc:	e7e0      	b.n	8009c80 <shellStartThread+0x9c>
          if (len >= 0) {
 8009cbe:	dadf      	bge.n	8009c80 <shellStartThread+0x9c>
        bracket = false;
 8009cc0:	f04f 0800 	mov.w	r8, #0
      escape = false;
 8009cc4:	46c2      	mov	sl, r8
 8009cc6:	e7ba      	b.n	8009c3e <shellStartThread+0x5a>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8009cc8:	2904      	cmp	r1, #4
 8009cca:	d116      	bne.n	8009cfa <shellStartThread+0x116>
      chprintf(chp, "^D");
 8009ccc:	4620      	mov	r0, r4
 8009cce:	4985      	ldr	r1, [pc, #532]	; (8009ee4 <shellStartThread+0x300>)
 8009cd0:	f7fe fd3d 	bl	800874e <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 8009cd4:	4638      	mov	r0, r7
 8009cd6:	497e      	ldr	r1, [pc, #504]	; (8009ed0 <shellStartThread+0x2ec>)
 8009cd8:	f7fe fd39 	bl	800874e <chprintf>
      chprintf(chp, "logout");
 8009cdc:	4982      	ldr	r1, [pc, #520]	; (8009ee8 <shellStartThread+0x304>)
 8009cde:	4638      	mov	r0, r7
 8009ce0:	f7fe fd35 	bl	800874e <chprintf>
  chSysLock();
 8009ce4:	f7fa fe56 	bl	8004994 <vPortEnterCritical>
    osalEventBroadcastFlagsI(event_source, 1);
 8009ce8:	4880      	ldr	r0, [pc, #512]	; (8009eec <shellStartThread+0x308>)
 8009cea:	2101      	movs	r1, #1
 8009cec:	f7fd f8f2 	bl	8006ed4 <osalEventBroadcastFlagsI>
    vTaskDelete(NULL);
 8009cf0:	f7fc f9be 	bl	8006070 <vTaskDelete.constprop.0>
}
 8009cf4:	b023      	add	sp, #140	; 0x8c
 8009cf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8009cfa:	2908      	cmp	r1, #8
 8009cfc:	d001      	beq.n	8009d02 <shellStartThread+0x11e>
 8009cfe:	297f      	cmp	r1, #127	; 0x7f
 8009d00:	d112      	bne.n	8009d28 <shellStartThread+0x144>
      if (p != line) {
 8009d02:	42b5      	cmp	r5, r6
 8009d04:	d09b      	beq.n	8009c3e <shellStartThread+0x5a>
        streamPut(chp, 0x08);
 8009d06:	6823      	ldr	r3, [r4, #0]
 8009d08:	2108      	movs	r1, #8
 8009d0a:	689b      	ldr	r3, [r3, #8]
 8009d0c:	4620      	mov	r0, r4
 8009d0e:	4798      	blx	r3
        streamPut(chp, 0x20);
 8009d10:	6823      	ldr	r3, [r4, #0]
 8009d12:	2120      	movs	r1, #32
 8009d14:	689b      	ldr	r3, [r3, #8]
 8009d16:	4620      	mov	r0, r4
 8009d18:	4798      	blx	r3
        streamPut(chp, 0x08);
 8009d1a:	6823      	ldr	r3, [r4, #0]
 8009d1c:	2108      	movs	r1, #8
 8009d1e:	4620      	mov	r0, r4
 8009d20:	689b      	ldr	r3, [r3, #8]
 8009d22:	4798      	blx	r3
        p--;
 8009d24:	3d01      	subs	r5, #1
 8009d26:	e78a      	b.n	8009c3e <shellStartThread+0x5a>
      }
      continue;
    }
    if (c == '\r') {
 8009d28:	290d      	cmp	r1, #13
 8009d2a:	f040 8081 	bne.w	8009e30 <shellStartThread+0x24c>
      chprintf(chp, SHELL_NEWLINE_STR);
 8009d2e:	4620      	mov	r0, r4
 8009d30:	4967      	ldr	r1, [pc, #412]	; (8009ed0 <shellStartThread+0x2ec>)
 8009d32:	f7fe fd0c 	bl	800874e <chprintf>
  if (length > shp->sh_size - 2)
 8009d36:	9908      	ldr	r1, [sp, #32]
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
 8009d38:	1bac      	subs	r4, r5, r6
  if (length > shp->sh_size - 2)
 8009d3a:	1e4b      	subs	r3, r1, #1
 8009d3c:	429c      	cmp	r4, r3
 8009d3e:	da06      	bge.n	8009d4e <shellStartThread+0x16a>
 8009d40:	462b      	mov	r3, r5
  while ((*(line + length -1) == ' ') && (length > 0))
 8009d42:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8009d46:	2a20      	cmp	r2, #32
 8009d48:	d12d      	bne.n	8009da6 <shellStartThread+0x1c2>
 8009d4a:	2c00      	cmp	r4, #0
 8009d4c:	dc29      	bgt.n	8009da2 <shellStartThread+0x1be>
    lp = parse_arguments(line, &tokp);
 8009d4e:	4630      	mov	r0, r6
#endif
      *p = 0;
 8009d50:	f885 b000 	strb.w	fp, [r5]
    lp = parse_arguments(line, &tokp);
 8009d54:	a906      	add	r1, sp, #24
 8009d56:	f7ff fc3d 	bl	80095d4 <parse_arguments>
 8009d5a:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 8009d5e:	4604      	mov	r4, r0
    n = 0;
 8009d60:	2600      	movs	r6, #0
 8009d62:	4645      	mov	r5, r8
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8009d64:	2000      	movs	r0, #0
 8009d66:	a906      	add	r1, sp, #24
 8009d68:	f7ff fc34 	bl	80095d4 <parse_arguments>
 8009d6c:	2800      	cmp	r0, #0
 8009d6e:	f040 80a2 	bne.w	8009eb6 <shellStartThread+0x2d2>
    args[n] = NULL;
 8009d72:	ab22      	add	r3, sp, #136	; 0x88
 8009d74:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8009d78:	f843 0c58 	str.w	r0, [r3, #-88]
    if (cmd != NULL) {
 8009d7c:	2c00      	cmp	r4, #0
 8009d7e:	f43f af53 	beq.w	8009c28 <shellStartThread+0x44>
      if (strcmp(cmd, "help") == 0) {
 8009d82:	4620      	mov	r0, r4
 8009d84:	495a      	ldr	r1, [pc, #360]	; (8009ef0 <shellStartThread+0x30c>)
 8009d86:	f7f9 ff1b 	bl	8003bc0 <strcmp>
 8009d8a:	2800      	cmp	r0, #0
 8009d8c:	f040 80da 	bne.w	8009f44 <shellStartThread+0x360>
        if (n > 0) {
 8009d90:	2e00      	cmp	r6, #0
 8009d92:	f000 80b7 	beq.w	8009f04 <shellStartThread+0x320>
          shellUsage(chp, "help");
 8009d96:	4638      	mov	r0, r7
 8009d98:	4a55      	ldr	r2, [pc, #340]	; (8009ef0 <shellStartThread+0x30c>)
 8009d9a:	4956      	ldr	r1, [pc, #344]	; (8009ef4 <shellStartThread+0x310>)
 8009d9c:	f7fe fcd7 	bl	800874e <chprintf>
          continue;
 8009da0:	e742      	b.n	8009c28 <shellStartThread+0x44>
    length--;
 8009da2:	3c01      	subs	r4, #1
 8009da4:	e7cd      	b.n	8009d42 <shellStartThread+0x15e>
  if (length <= 0)
 8009da6:	2c00      	cmp	r4, #0
 8009da8:	ddd1      	ble.n	8009d4e <shellStartThread+0x16a>
  if (shp->sh_end >= shp->sh_beg) {
 8009daa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 8009dac:	9807      	ldr	r0, [sp, #28]
  if (shp->sh_end >= shp->sh_beg) {
 8009dae:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8009db2:	4562      	cmp	r2, ip
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8009db4:	bfa5      	ittet	ge
 8009db6:	eba2 030c 	subge.w	r3, r2, ip
 8009dba:	3301      	addge	r3, #1
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8009dbc:	ebac 0302 	sublt.w	r3, ip, r2
    if (length < (shp->sh_size - (shp->sh_end - shp->sh_beg + 1)))
 8009dc0:	1acb      	subge	r3, r1, r3
    if (length < (shp->sh_beg - shp->sh_end - 1))
 8009dc2:	bfb8      	it	lt
 8009dc4:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 8009dc8:	429c      	cmp	r4, r3
 8009dca:	da1e      	bge.n	8009e0a <shellStartThread+0x226>
  if (length < shp->sh_size - shp->sh_end - 1)
 8009dcc:	eba1 0802 	sub.w	r8, r1, r2
 8009dd0:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009dd4:	3201      	adds	r2, #1
  if (length < shp->sh_size - shp->sh_end - 1)
 8009dd6:	4544      	cmp	r4, r8
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009dd8:	4410      	add	r0, r2
  if (length < shp->sh_size - shp->sh_end - 1)
 8009dda:	da1f      	bge.n	8009e1c <shellStartThread+0x238>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, length);
 8009ddc:	4622      	mov	r2, r4
 8009dde:	4631      	mov	r1, r6
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 8009de0:	f7f9 fe78 	bl	8003ad4 <memcpy>
  *(shp->sh_buffer + shp->sh_end) = (char)length;
 8009de4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009de6:	9a07      	ldr	r2, [sp, #28]
 8009de8:	54d4      	strb	r4, [r2, r3]
  shp->sh_end += length + 1;
 8009dea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009dec:	3401      	adds	r4, #1
 8009dee:	441c      	add	r4, r3
  if (shp->sh_end >= shp->sh_size)
 8009df0:	9b08      	ldr	r3, [sp, #32]
  shp->sh_end += length + 1;
 8009df2:	940a      	str	r4, [sp, #40]	; 0x28
  if (shp->sh_end >= shp->sh_size)
 8009df4:	429c      	cmp	r4, r3
    shp->sh_end -= shp->sh_size;
 8009df6:	bfa4      	itt	ge
 8009df8:	1ae4      	subge	r4, r4, r3
 8009dfa:	940a      	strge	r4, [sp, #40]	; 0x28
  *(shp->sh_buffer + shp->sh_end) = 0;
 8009dfc:	9a07      	ldr	r2, [sp, #28]
 8009dfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009e00:	f802 b003 	strb.w	fp, [r2, r3]
  shp->sh_cur = 0;
 8009e04:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8009e08:	e7a1      	b.n	8009d4e <shellStartThread+0x16a>
  int pos = shp->sh_beg + *(shp->sh_buffer + shp->sh_beg) + 1;
 8009e0a:	f810 300c 	ldrb.w	r3, [r0, ip]
 8009e0e:	4463      	add	r3, ip
 8009e10:	3301      	adds	r3, #1
  if (pos >= shp->sh_size)
 8009e12:	4299      	cmp	r1, r3
    pos -= shp->sh_size;
 8009e14:	bfd8      	it	le
 8009e16:	1a5b      	suble	r3, r3, r1
  shp->sh_beg = pos;
 8009e18:	9309      	str	r3, [sp, #36]	; 0x24
}
 8009e1a:	e7c8      	b.n	8009dae <shellStartThread+0x1ca>
    memcpy(shp->sh_buffer + shp->sh_end + 1, line, part_len);
 8009e1c:	4642      	mov	r2, r8
 8009e1e:	4631      	mov	r1, r6
 8009e20:	f7f9 fe58 	bl	8003ad4 <memcpy>
    memcpy(shp->sh_buffer, line + part_len, length - part_len);
 8009e24:	9807      	ldr	r0, [sp, #28]
 8009e26:	eba4 0208 	sub.w	r2, r4, r8
 8009e2a:	eb06 0108 	add.w	r1, r6, r8
 8009e2e:	e7d7      	b.n	8009de0 <shellStartThread+0x1fc>
      }
      continue;
    }
#endif
#if SHELL_USE_HISTORY == TRUE
    if (c == 14) {
 8009e30:	290e      	cmp	r1, #14
 8009e32:	d11e      	bne.n	8009e72 <shellStartThread+0x28e>
      int len = get_history(shp, line, SHELL_HIST_DIR_FW);
 8009e34:	2201      	movs	r2, #1
 8009e36:	4631      	mov	r1, r6
 8009e38:	a807      	add	r0, sp, #28
 8009e3a:	f7fd fea6 	bl	8007b8a <get_history>

      if (len == 0)
 8009e3e:	1e03      	subs	r3, r0, #0
 8009e40:	9303      	str	r3, [sp, #12]
 8009e42:	d113      	bne.n	8009e6c <shellStartThread+0x288>
        *line = 0;
 8009e44:	f88d a048 	strb.w	sl, [sp, #72]	; 0x48
    }
    if (c == 16) {
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);

      if (len > 0) {
        _shell_reset_cur(chp);
 8009e48:	2308      	movs	r3, #8
 8009e4a:	224a      	movs	r2, #74	; 0x4a
 8009e4c:	4922      	ldr	r1, [pc, #136]	; (8009ed8 <shellStartThread+0x2f4>)
 8009e4e:	4620      	mov	r0, r4
 8009e50:	f7fe fc7d 	bl	800874e <chprintf>
        _shell_clr_line(chp);
 8009e54:	4921      	ldr	r1, [pc, #132]	; (8009edc <shellStartThread+0x2f8>)
 8009e56:	4620      	mov	r0, r4
 8009e58:	f7fe fc79 	bl	800874e <chprintf>
        chprintf(chp, "%s", line);
 8009e5c:	4632      	mov	r2, r6
 8009e5e:	4620      	mov	r0, r4
 8009e60:	491f      	ldr	r1, [pc, #124]	; (8009ee0 <shellStartThread+0x2fc>)
 8009e62:	f7fe fc74 	bl	800874e <chprintf>
        p = line + len;
 8009e66:	9d03      	ldr	r5, [sp, #12]
 8009e68:	4435      	add	r5, r6
 8009e6a:	e6e8      	b.n	8009c3e <shellStartThread+0x5a>
      if (len >= 0) {
 8009e6c:	f6ff aee7 	blt.w	8009c3e <shellStartThread+0x5a>
 8009e70:	e7ea      	b.n	8009e48 <shellStartThread+0x264>
    if (c == 16) {
 8009e72:	2910      	cmp	r1, #16
 8009e74:	d109      	bne.n	8009e8a <shellStartThread+0x2a6>
      int len = get_history(shp, line, SHELL_HIST_DIR_BK);
 8009e76:	4652      	mov	r2, sl
 8009e78:	4631      	mov	r1, r6
 8009e7a:	a807      	add	r0, sp, #28
 8009e7c:	f7fd fe85 	bl	8007b8a <get_history>
      if (len > 0) {
 8009e80:	1e03      	subs	r3, r0, #0
 8009e82:	9303      	str	r3, [sp, #12]
 8009e84:	f77f aedb 	ble.w	8009c3e <shellStartThread+0x5a>
 8009e88:	e7de      	b.n	8009e48 <shellStartThread+0x264>
      }
      continue;
    }
#endif
    if (c < 0x20)
 8009e8a:	291f      	cmp	r1, #31
 8009e8c:	f67f aed7 	bls.w	8009c3e <shellStartThread+0x5a>
      continue;
    if (p < line + size - 1) {
 8009e90:	f10d 0387 	add.w	r3, sp, #135	; 0x87
 8009e94:	429d      	cmp	r5, r3
 8009e96:	f4bf aed2 	bcs.w	8009c3e <shellStartThread+0x5a>
      streamPut(chp, c);
 8009e9a:	6823      	ldr	r3, [r4, #0]
 8009e9c:	4620      	mov	r0, r4
 8009e9e:	689b      	ldr	r3, [r3, #8]
 8009ea0:	4798      	blx	r3
      *p++ = (char)c;
 8009ea2:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8009ea6:	f805 3b01 	strb.w	r3, [r5], #1
 8009eaa:	e6c8      	b.n	8009c3e <shellStartThread+0x5a>
      escape = true;
 8009eac:	f04f 0a01 	mov.w	sl, #1
 8009eb0:	e6c5      	b.n	8009c3e <shellStartThread+0x5a>
        bracket = true;
 8009eb2:	46d0      	mov	r8, sl
 8009eb4:	e6c3      	b.n	8009c3e <shellStartThread+0x5a>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8009eb6:	2e05      	cmp	r6, #5
 8009eb8:	d120      	bne.n	8009efc <shellStartThread+0x318>
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
 8009eba:	4638      	mov	r0, r7
 8009ebc:	490e      	ldr	r1, [pc, #56]	; (8009ef8 <shellStartThread+0x314>)
 8009ebe:	f7fe fc46 	bl	800874e <chprintf>
    args[n] = NULL;
 8009ec2:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
    if (cmd != NULL) {
 8009ec6:	e6af      	b.n	8009c28 <shellStartThread+0x44>
 8009ec8:	200011a8 	.word	0x200011a8
 8009ecc:	0800c2d5 	.word	0x0800c2d5
 8009ed0:	0800be60 	.word	0x0800be60
 8009ed4:	0800c2f0 	.word	0x0800c2f0
 8009ed8:	0800c2f9 	.word	0x0800c2f9
 8009edc:	0800c304 	.word	0x0800c304
 8009ee0:	0800bc80 	.word	0x0800bc80
 8009ee4:	0800c308 	.word	0x0800c308
 8009ee8:	0800c30b 	.word	0x0800c30b
 8009eec:	200012b8 	.word	0x200012b8
 8009ef0:	0800c327 	.word	0x0800c327
 8009ef4:	0800baca 	.word	0x0800baca
 8009ef8:	0800c312 	.word	0x0800c312
      args[n++] = lp;
 8009efc:	3601      	adds	r6, #1
 8009efe:	f848 0b04 	str.w	r0, [r8], #4
 8009f02:	e72f      	b.n	8009d64 <shellStartThread+0x180>
        chprintf(chp, "Commands: help ");
 8009f04:	4638      	mov	r0, r7
 8009f06:	491e      	ldr	r1, [pc, #120]	; (8009f80 <shellStartThread+0x39c>)
 8009f08:	f7fe fc21 	bl	800874e <chprintf>
  while (scp->sc_name != NULL) {
 8009f0c:	4c1d      	ldr	r4, [pc, #116]	; (8009f84 <shellStartThread+0x3a0>)
    chprintf(chp, "%s ", scp->sc_name);
 8009f0e:	4d1e      	ldr	r5, [pc, #120]	; (8009f88 <shellStartThread+0x3a4>)
  while (scp->sc_name != NULL) {
 8009f10:	6822      	ldr	r2, [r4, #0]
 8009f12:	b98a      	cbnz	r2, 8009f38 <shellStartThread+0x354>
        if (scp != NULL)
 8009f14:	9b02      	ldr	r3, [sp, #8]
 8009f16:	2b00      	cmp	r3, #0
 8009f18:	f43f ae82 	beq.w	8009c20 <shellStartThread+0x3c>
    chprintf(chp, "%s ", scp->sc_name);
 8009f1c:	4d1a      	ldr	r5, [pc, #104]	; (8009f88 <shellStartThread+0x3a4>)
 8009f1e:	f103 040c 	add.w	r4, r3, #12
  while (scp->sc_name != NULL) {
 8009f22:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 8009f26:	340c      	adds	r4, #12
 8009f28:	2a00      	cmp	r2, #0
 8009f2a:	f43f ae79 	beq.w	8009c20 <shellStartThread+0x3c>
    chprintf(chp, "%s ", scp->sc_name);
 8009f2e:	4629      	mov	r1, r5
 8009f30:	4638      	mov	r0, r7
 8009f32:	f7fe fc0c 	bl	800874e <chprintf>
    scp++;
 8009f36:	e7f4      	b.n	8009f22 <shellStartThread+0x33e>
    chprintf(chp, "%s ", scp->sc_name);
 8009f38:	4629      	mov	r1, r5
 8009f3a:	4638      	mov	r0, r7
 8009f3c:	f7fe fc07 	bl	800874e <chprintf>
    scp++;
 8009f40:	340c      	adds	r4, #12
 8009f42:	e7e5      	b.n	8009f10 <shellStartThread+0x32c>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8009f44:	4633      	mov	r3, r6
 8009f46:	4622      	mov	r2, r4
 8009f48:	4639      	mov	r1, r7
 8009f4a:	480e      	ldr	r0, [pc, #56]	; (8009f84 <shellStartThread+0x3a0>)
 8009f4c:	9500      	str	r5, [sp, #0]
 8009f4e:	f7ff fb67 	bl	8009620 <cmdexec>
 8009f52:	2800      	cmp	r0, #0
 8009f54:	f43f ae68 	beq.w	8009c28 <shellStartThread+0x44>
 8009f58:	9b02      	ldr	r3, [sp, #8]
 8009f5a:	b933      	cbnz	r3, 8009f6a <shellStartThread+0x386>
        chprintf(chp, "%s", cmd);
 8009f5c:	490b      	ldr	r1, [pc, #44]	; (8009f8c <shellStartThread+0x3a8>)
 8009f5e:	4622      	mov	r2, r4
 8009f60:	4638      	mov	r0, r7
 8009f62:	f7fe fbf4 	bl	800874e <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
 8009f66:	490a      	ldr	r1, [pc, #40]	; (8009f90 <shellStartThread+0x3ac>)
 8009f68:	e65b      	b.n	8009c22 <shellStartThread+0x3e>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8009f6a:	4633      	mov	r3, r6
 8009f6c:	4622      	mov	r2, r4
 8009f6e:	4639      	mov	r1, r7
 8009f70:	9802      	ldr	r0, [sp, #8]
 8009f72:	9500      	str	r5, [sp, #0]
 8009f74:	f7ff fb54 	bl	8009620 <cmdexec>
 8009f78:	2800      	cmp	r0, #0
 8009f7a:	d1ef      	bne.n	8009f5c <shellStartThread+0x378>
 8009f7c:	e654      	b.n	8009c28 <shellStartThread+0x44>
 8009f7e:	bf00      	nop
 8009f80:	0800c32c 	.word	0x0800c32c
 8009f84:	0800cb74 	.word	0x0800cb74
 8009f88:	0800c33c 	.word	0x0800c33c
 8009f8c:	0800bc80 	.word	0x0800bc80
 8009f90:	0800c340 	.word	0x0800c340

08009f94 <cmdThreadInfo>:
    else if(state == eDeleted) printfFixed(chp, 9, "Deleted");
    else printfFixed(chp, 9, "Invalid");
}

void cmdThreadInfo(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 8009f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    (void)argc;
    (void)argv;
    (void) user;

    unsigned int numberOfTasks = uxTaskGetNumberOfTasks();
    TaskStatus_t* taskStatusArray = pvPortMalloc(numberOfTasks * sizeof(TaskStatus_t));
 8009f98:	2624      	movs	r6, #36	; 0x24
	return uxCurrentNumberOfTasks;
 8009f9a:	f8df 8260 	ldr.w	r8, [pc, #608]	; 800a1fc <cmdThreadInfo+0x268>
{
 8009f9e:	b085      	sub	sp, #20
 8009fa0:	f8d8 5000 	ldr.w	r5, [r8]
 8009fa4:	460c      	mov	r4, r1
    TaskStatus_t* taskStatusArray = pvPortMalloc(numberOfTasks * sizeof(TaskStatus_t));
 8009fa6:	fb06 f005 	mul.w	r0, r6, r5
 8009faa:	f7fb f92b 	bl	8005204 <pvPortMalloc>
    if(!taskStatusArray) {
 8009fae:	4607      	mov	r7, r0
 8009fb0:	2800      	cmp	r0, #0
 8009fb2:	f000 8096 	beq.w	800a0e2 <cmdThreadInfo+0x14e>
		vTaskSuspendAll();
 8009fb6:	f7fa fb7f 	bl	80046b8 <vTaskSuspendAll>
			if( uxArraySize >= uxCurrentNumberOfTasks )
 8009fba:	f8d8 3000 	ldr.w	r3, [r8]
 8009fbe:	429d      	cmp	r5, r3
 8009fc0:	f0c0 8092 	bcc.w	800a0e8 <cmdThreadInfo+0x154>
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8009fc4:	f04f 0805 	mov.w	r8, #5
 8009fc8:	2500      	movs	r5, #0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8009fca:	f04f 0a14 	mov.w	sl, #20
 8009fce:	f8df 9230 	ldr.w	r9, [pc, #560]	; 800a200 <cmdThreadInfo+0x26c>
					uxQueue--;
 8009fd2:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 8009fd6:	fb06 7005 	mla	r0, r6, r5, r7
 8009fda:	2201      	movs	r2, #1
 8009fdc:	fb0a 9108 	mla	r1, sl, r8, r9
 8009fe0:	f7fb fbb2 	bl	8005748 <prvListTasksWithinSingleList>
 8009fe4:	4405      	add	r5, r0
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009fe6:	f1b8 0f00 	cmp.w	r8, #0
 8009fea:	d1f2      	bne.n	8009fd2 <cmdThreadInfo+0x3e>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8009fec:	4b85      	ldr	r3, [pc, #532]	; (800a204 <cmdThreadInfo+0x270>)
 8009fee:	2202      	movs	r2, #2
 8009ff0:	6819      	ldr	r1, [r3, #0]
 8009ff2:	fb06 7005 	mla	r0, r6, r5, r7
 8009ff6:	f7fb fba7 	bl	8005748 <prvListTasksWithinSingleList>
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009ffa:	4b83      	ldr	r3, [pc, #524]	; (800a208 <cmdThreadInfo+0x274>)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8009ffc:	4405      	add	r5, r0
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 8009ffe:	6819      	ldr	r1, [r3, #0]
 800a000:	2202      	movs	r2, #2
 800a002:	fb06 7005 	mla	r0, r6, r5, r7
 800a006:	f7fb fb9f 	bl	8005748 <prvListTasksWithinSingleList>
 800a00a:	4405      	add	r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 800a00c:	2204      	movs	r2, #4
 800a00e:	fb06 7005 	mla	r0, r6, r5, r7
 800a012:	497e      	ldr	r1, [pc, #504]	; (800a20c <cmdThreadInfo+0x278>)
 800a014:	f7fb fb98 	bl	8005748 <prvListTasksWithinSingleList>
 800a018:	4405      	add	r5, r0
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 800a01a:	fb06 7005 	mla	r0, r6, r5, r7
 800a01e:	2203      	movs	r2, #3
 800a020:	497b      	ldr	r1, [pc, #492]	; (800a210 <cmdThreadInfo+0x27c>)
 800a022:	f7fb fb91 	bl	8005748 <prvListTasksWithinSingleList>
 800a026:	4405      	add	r5, r0
		( void ) xTaskResumeAll();
 800a028:	f7fb f868 	bl	80050fc <xTaskResumeAll>
        return;
    }

    uint32_t totalRunTime;
    unsigned int  result = uxTaskGetSystemState(taskStatusArray, numberOfTasks, &totalRunTime);
    printfFixed(chp, 13, "Task ID");
 800a02c:	210d      	movs	r1, #13
 800a02e:	4a79      	ldr	r2, [pc, #484]	; (800a214 <cmdThreadInfo+0x280>)
 800a030:	4620      	mov	r0, r4
 800a032:	f7fe fd39 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 10, "Task Name");
 800a036:	210a      	movs	r1, #10
 800a038:	4a77      	ldr	r2, [pc, #476]	; (800a218 <cmdThreadInfo+0x284>)
 800a03a:	4620      	mov	r0, r4
 800a03c:	f7fe fd34 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 11, "Stack Base");
 800a040:	210b      	movs	r1, #11
 800a042:	4a76      	ldr	r2, [pc, #472]	; (800a21c <cmdThreadInfo+0x288>)
 800a044:	4620      	mov	r0, r4
 800a046:	f7fe fd2f 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 11, "Free Stack");
 800a04a:	210b      	movs	r1, #11
 800a04c:	4a74      	ldr	r2, [pc, #464]	; (800a220 <cmdThreadInfo+0x28c>)
 800a04e:	4620      	mov	r0, r4
 800a050:	f7fe fd2a 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 6, "PrioB");
 800a054:	2106      	movs	r1, #6
 800a056:	4a73      	ldr	r2, [pc, #460]	; (800a224 <cmdThreadInfo+0x290>)
 800a058:	4620      	mov	r0, r4
 800a05a:	f7fe fd25 	bl	8008aa8 <printfFixed>
#if configUSE_MUTEXES
    printfFixed(chp, 6, "PrioC");
 800a05e:	2106      	movs	r1, #6
 800a060:	4a71      	ldr	r2, [pc, #452]	; (800a228 <cmdThreadInfo+0x294>)
 800a062:	4620      	mov	r0, r4
 800a064:	f7fe fd20 	bl	8008aa8 <printfFixed>
#endif
    printfFixed(chp, 9, "State");
 800a068:	2109      	movs	r1, #9
 800a06a:	4a70      	ldr	r2, [pc, #448]	; (800a22c <cmdThreadInfo+0x298>)
 800a06c:	4620      	mov	r0, r4
 800a06e:	f7fe fd1b 	bl	8008aa8 <printfFixed>
    chprintf(chp,SHELL_NEWLINE_STR);
 800a072:	4620      	mov	r0, r4
 800a074:	496e      	ldr	r1, [pc, #440]	; (800a230 <cmdThreadInfo+0x29c>)
 800a076:	f7fe fb6a 	bl	800874e <chprintf>
    for(unsigned int i = 0; i<result; i++) {
 800a07a:	463e      	mov	r6, r7
 800a07c:	f04f 0800 	mov.w	r8, #0
        printfFixed(chp, 13, "%u=%08x ", taskStatusArray[i].xTaskNumber, taskStatusArray[i].xHandle);
 800a080:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 800a234 <cmdThreadInfo+0x2a0>
        if(!strcmp("IDLE", taskStatusArray[i].pcTaskName)) {
 800a084:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 800a238 <cmdThreadInfo+0x2a4>
            printfFixed(chp, 10, "Idle");
        } else {
            printfFixed(chp, 10, "%s", taskStatusArray[i].pcTaskName);
 800a088:	f8df b1b0 	ldr.w	fp, [pc, #432]	; 800a23c <cmdThreadInfo+0x2a8>
    for(unsigned int i = 0; i<result; i++) {
 800a08c:	45a8      	cmp	r8, r5
 800a08e:	d12d      	bne.n	800a0ec <cmdThreadInfo+0x158>
    printfFixed(chp, 11, "Descriptor");
    printfFixed(chp, 11, "Callback");
    chprintf(chp, "State"SHELL_NEWLINE_STR);

    MonitorEntry* entry = monThreadFirst;
    unsigned int index = 0;
 800a090:	2600      	movs	r6, #0
            cmdThreadPrintState(chp, taskStatusArray[i].eCurrentState);
        }
        chprintf(chp,SHELL_NEWLINE_STR);
    }

    vPortFree(taskStatusArray);
 800a092:	4638      	mov	r0, r7
 800a094:	f7fb f93a 	bl	800530c <vPortFree>
    chprintf(chp,SHELL_NEWLINE_STR);
 800a098:	4965      	ldr	r1, [pc, #404]	; (800a230 <cmdThreadInfo+0x29c>)
 800a09a:	4620      	mov	r0, r4
 800a09c:	f7fe fb57 	bl	800874e <chprintf>
    printfFixed(chp, 13, "Monitor ID");
 800a0a0:	210d      	movs	r1, #13
 800a0a2:	4a67      	ldr	r2, [pc, #412]	; (800a240 <cmdThreadInfo+0x2ac>)
 800a0a4:	4620      	mov	r0, r4
 800a0a6:	f7fe fcff 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 10, "Task Name");
 800a0aa:	210a      	movs	r1, #10
 800a0ac:	4a5a      	ldr	r2, [pc, #360]	; (800a218 <cmdThreadInfo+0x284>)
 800a0ae:	4620      	mov	r0, r4
 800a0b0:	f7fe fcfa 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 11, "Descriptor");
 800a0b4:	210b      	movs	r1, #11
 800a0b6:	4a63      	ldr	r2, [pc, #396]	; (800a244 <cmdThreadInfo+0x2b0>)
 800a0b8:	4620      	mov	r0, r4
 800a0ba:	f7fe fcf5 	bl	8008aa8 <printfFixed>
    printfFixed(chp, 11, "Callback");
 800a0be:	210b      	movs	r1, #11
 800a0c0:	4a61      	ldr	r2, [pc, #388]	; (800a248 <cmdThreadInfo+0x2b4>)
 800a0c2:	4620      	mov	r0, r4
 800a0c4:	f7fe fcf0 	bl	8008aa8 <printfFixed>
    chprintf(chp, "State"SHELL_NEWLINE_STR);
 800a0c8:	4620      	mov	r0, r4
 800a0ca:	4960      	ldr	r1, [pc, #384]	; (800a24c <cmdThreadInfo+0x2b8>)
 800a0cc:	f7fe fb3f 	bl	800874e <chprintf>
    MonitorEntry* entry = monThreadFirst;
 800a0d0:	4b5f      	ldr	r3, [pc, #380]	; (800a250 <cmdThreadInfo+0x2bc>)
    while(entry) {
        printfFixed(chp, 13, "%u", index);
 800a0d2:	4f60      	ldr	r7, [pc, #384]	; (800a254 <cmdThreadInfo+0x2c0>)
    MonitorEntry* entry = monThreadFirst;
 800a0d4:	681d      	ldr	r5, [r3, #0]
        if(entry->name) {
            printfFixed(chp, 10, "%s",entry->name);
        } else {
            printfFixed(chp, 10, "");
 800a0d6:	f8df 8180 	ldr.w	r8, [pc, #384]	; 800a258 <cmdThreadInfo+0x2c4>
            printfFixed(chp, 10, "%s",entry->name);
 800a0da:	f8df 9160 	ldr.w	r9, [pc, #352]	; 800a23c <cmdThreadInfo+0x2a8>
    while(entry) {
 800a0de:	2d00      	cmp	r5, #0
 800a0e0:	d162      	bne.n	800a1a8 <cmdThreadInfo+0x214>
    monitorPrintStatus(chp);
}
 800a0e2:	b005      	add	sp, #20
 800a0e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 800a0e8:	2500      	movs	r5, #0
 800a0ea:	e79d      	b.n	800a028 <cmdThreadInfo+0x94>
        printfFixed(chp, 13, "%u=%08x ", taskStatusArray[i].xTaskNumber, taskStatusArray[i].xHandle);
 800a0ec:	6833      	ldr	r3, [r6, #0]
 800a0ee:	464a      	mov	r2, r9
 800a0f0:	9300      	str	r3, [sp, #0]
 800a0f2:	210d      	movs	r1, #13
 800a0f4:	68b3      	ldr	r3, [r6, #8]
 800a0f6:	4620      	mov	r0, r4
 800a0f8:	f7fe fcd6 	bl	8008aa8 <printfFixed>
        if(!strcmp("IDLE", taskStatusArray[i].pcTaskName)) {
 800a0fc:	6873      	ldr	r3, [r6, #4]
 800a0fe:	4650      	mov	r0, sl
 800a100:	4619      	mov	r1, r3
 800a102:	9303      	str	r3, [sp, #12]
 800a104:	f7f9 fd5c 	bl	8003bc0 <strcmp>
 800a108:	9b03      	ldr	r3, [sp, #12]
 800a10a:	2800      	cmp	r0, #0
 800a10c:	d132      	bne.n	800a174 <cmdThreadInfo+0x1e0>
            printfFixed(chp, 10, "Idle");
 800a10e:	210a      	movs	r1, #10
 800a110:	4620      	mov	r0, r4
 800a112:	4a52      	ldr	r2, [pc, #328]	; (800a25c <cmdThreadInfo+0x2c8>)
 800a114:	f7fe fcc8 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 11, "%08x", taskStatusArray[i].pxStackBase);
 800a118:	210b      	movs	r1, #11
 800a11a:	69f3      	ldr	r3, [r6, #28]
 800a11c:	4a50      	ldr	r2, [pc, #320]	; (800a260 <cmdThreadInfo+0x2cc>)
 800a11e:	4620      	mov	r0, r4
 800a120:	f7fe fcc2 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 11, "%u", (uint32_t)taskStatusArray[i].usStackHighWaterMark);
 800a124:	210b      	movs	r1, #11
 800a126:	8c33      	ldrh	r3, [r6, #32]
 800a128:	4a4a      	ldr	r2, [pc, #296]	; (800a254 <cmdThreadInfo+0x2c0>)
 800a12a:	4620      	mov	r0, r4
 800a12c:	f7fe fcbc 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 6, "%u", taskStatusArray[i].uxBasePriority);
 800a130:	2106      	movs	r1, #6
 800a132:	6973      	ldr	r3, [r6, #20]
 800a134:	4a47      	ldr	r2, [pc, #284]	; (800a254 <cmdThreadInfo+0x2c0>)
 800a136:	4620      	mov	r0, r4
 800a138:	f7fe fcb6 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 6, "%u", taskStatusArray[i].uxCurrentPriority);
 800a13c:	2106      	movs	r1, #6
 800a13e:	6933      	ldr	r3, [r6, #16]
 800a140:	4a44      	ldr	r2, [pc, #272]	; (800a254 <cmdThreadInfo+0x2c0>)
 800a142:	4620      	mov	r0, r4
 800a144:	f7fe fcb0 	bl	8008aa8 <printfFixed>
        if(taskStatusArray[i].xHandle == xGetCurrentTaskHandle()) {
 800a148:	6830      	ldr	r0, [r6, #0]
    portENTER_CRITICAL();
 800a14a:	f7fa fc23 	bl	8004994 <vPortEnterCritical>
    xReturn = ( xTaskHandle ) pxCurrentTCB;
 800a14e:	4b45      	ldr	r3, [pc, #276]	; (800a264 <cmdThreadInfo+0x2d0>)
 800a150:	6819      	ldr	r1, [r3, #0]
    portEXIT_CRITICAL();
 800a152:	f7fa fe37 	bl	8004dc4 <vPortExitCritical>
 800a156:	4288      	cmp	r0, r1
 800a158:	d112      	bne.n	800a180 <cmdThreadInfo+0x1ec>
    if(state == eRunning) printfFixed(chp, 9, "Running");
 800a15a:	4a43      	ldr	r2, [pc, #268]	; (800a268 <cmdThreadInfo+0x2d4>)
    else printfFixed(chp, 9, "Invalid");
 800a15c:	2109      	movs	r1, #9
 800a15e:	4620      	mov	r0, r4
 800a160:	f7fe fca2 	bl	8008aa8 <printfFixed>
        chprintf(chp,SHELL_NEWLINE_STR);
 800a164:	4620      	mov	r0, r4
 800a166:	4932      	ldr	r1, [pc, #200]	; (800a230 <cmdThreadInfo+0x29c>)
 800a168:	f7fe faf1 	bl	800874e <chprintf>
    for(unsigned int i = 0; i<result; i++) {
 800a16c:	f108 0801 	add.w	r8, r8, #1
 800a170:	3624      	adds	r6, #36	; 0x24
 800a172:	e78b      	b.n	800a08c <cmdThreadInfo+0xf8>
            printfFixed(chp, 10, "%s", taskStatusArray[i].pcTaskName);
 800a174:	465a      	mov	r2, fp
 800a176:	210a      	movs	r1, #10
 800a178:	4620      	mov	r0, r4
 800a17a:	f7fe fc95 	bl	8008aa8 <printfFixed>
 800a17e:	e7cb      	b.n	800a118 <cmdThreadInfo+0x184>
            cmdThreadPrintState(chp, taskStatusArray[i].eCurrentState);
 800a180:	7b33      	ldrb	r3, [r6, #12]
    if(state == eRunning) printfFixed(chp, 9, "Running");
 800a182:	2b00      	cmp	r3, #0
 800a184:	d0e9      	beq.n	800a15a <cmdThreadInfo+0x1c6>
    else if(state == eReady) printfFixed(chp, 9, "Ready");
 800a186:	2b01      	cmp	r3, #1
 800a188:	d101      	bne.n	800a18e <cmdThreadInfo+0x1fa>
 800a18a:	4a38      	ldr	r2, [pc, #224]	; (800a26c <cmdThreadInfo+0x2d8>)
 800a18c:	e7e6      	b.n	800a15c <cmdThreadInfo+0x1c8>
    else if(state == eBlocked) printfFixed(chp, 9, "Blocked");
 800a18e:	2b02      	cmp	r3, #2
 800a190:	d101      	bne.n	800a196 <cmdThreadInfo+0x202>
 800a192:	4a37      	ldr	r2, [pc, #220]	; (800a270 <cmdThreadInfo+0x2dc>)
 800a194:	e7e2      	b.n	800a15c <cmdThreadInfo+0x1c8>
    else if(state == eSuspended) printfFixed(chp, 9, "Suspended");
 800a196:	2b03      	cmp	r3, #3
 800a198:	d101      	bne.n	800a19e <cmdThreadInfo+0x20a>
 800a19a:	4a36      	ldr	r2, [pc, #216]	; (800a274 <cmdThreadInfo+0x2e0>)
 800a19c:	e7de      	b.n	800a15c <cmdThreadInfo+0x1c8>
    else if(state == eDeleted) printfFixed(chp, 9, "Deleted");
 800a19e:	2b04      	cmp	r3, #4
 800a1a0:	bf0c      	ite	eq
 800a1a2:	4a35      	ldreq	r2, [pc, #212]	; (800a278 <cmdThreadInfo+0x2e4>)
    else printfFixed(chp, 9, "Invalid");
 800a1a4:	4a35      	ldrne	r2, [pc, #212]	; (800a27c <cmdThreadInfo+0x2e8>)
 800a1a6:	e7d9      	b.n	800a15c <cmdThreadInfo+0x1c8>
        printfFixed(chp, 13, "%u", index);
 800a1a8:	4633      	mov	r3, r6
 800a1aa:	463a      	mov	r2, r7
 800a1ac:	210d      	movs	r1, #13
 800a1ae:	4620      	mov	r0, r4
 800a1b0:	f7fe fc7a 	bl	8008aa8 <printfFixed>
        if(entry->name) {
 800a1b4:	68eb      	ldr	r3, [r5, #12]
 800a1b6:	b1cb      	cbz	r3, 800a1ec <cmdThreadInfo+0x258>
            printfFixed(chp, 10, "%s",entry->name);
 800a1b8:	464a      	mov	r2, r9
 800a1ba:	210a      	movs	r1, #10
 800a1bc:	4620      	mov	r0, r4
 800a1be:	f7fe fc73 	bl	8008aa8 <printfFixed>
        }
        printfFixed(chp, 11, "%08x", entry);
 800a1c2:	462b      	mov	r3, r5
 800a1c4:	210b      	movs	r1, #11
 800a1c6:	4a26      	ldr	r2, [pc, #152]	; (800a260 <cmdThreadInfo+0x2cc>)
 800a1c8:	4620      	mov	r0, r4
 800a1ca:	f7fe fc6d 	bl	8008aa8 <printfFixed>
        printfFixed(chp, 11, "%08x", entry->callback);
 800a1ce:	682b      	ldr	r3, [r5, #0]
 800a1d0:	210b      	movs	r1, #11
 800a1d2:	4620      	mov	r0, r4
 800a1d4:	4a22      	ldr	r2, [pc, #136]	; (800a260 <cmdThreadInfo+0x2cc>)
 800a1d6:	f7fe fc67 	bl	8008aa8 <printfFixed>
        if(entry->active) {
 800a1da:	7c2b      	ldrb	r3, [r5, #16]
 800a1dc:	b163      	cbz	r3, 800a1f8 <cmdThreadInfo+0x264>
            chprintf(chp, "Active"SHELL_NEWLINE_STR);
 800a1de:	4928      	ldr	r1, [pc, #160]	; (800a280 <cmdThreadInfo+0x2ec>)
        } else {
            chprintf(chp, "Idle"SHELL_NEWLINE_STR);
 800a1e0:	4620      	mov	r0, r4
 800a1e2:	f7fe fab4 	bl	800874e <chprintf>
        }
        index++;
 800a1e6:	3601      	adds	r6, #1
        entry = entry->next;
 800a1e8:	68ad      	ldr	r5, [r5, #8]
 800a1ea:	e778      	b.n	800a0de <cmdThreadInfo+0x14a>
            printfFixed(chp, 10, "");
 800a1ec:	4642      	mov	r2, r8
 800a1ee:	210a      	movs	r1, #10
 800a1f0:	4620      	mov	r0, r4
 800a1f2:	f7fe fc59 	bl	8008aa8 <printfFixed>
 800a1f6:	e7e4      	b.n	800a1c2 <cmdThreadInfo+0x22e>
            chprintf(chp, "Idle"SHELL_NEWLINE_STR);
 800a1f8:	4922      	ldr	r1, [pc, #136]	; (800a284 <cmdThreadInfo+0x2f0>)
 800a1fa:	e7f1      	b.n	800a1e0 <cmdThreadInfo+0x24c>
 800a1fc:	2000135c 	.word	0x2000135c
 800a200:	200011b8 	.word	0x200011b8
 800a204:	200011ac 	.word	0x200011ac
 800a208:	200011b4 	.word	0x200011b4
 800a20c:	20001634 	.word	0x20001634
 800a210:	20001620 	.word	0x20001620
 800a214:	0800c345 	.word	0x0800c345
 800a218:	0800c34d 	.word	0x0800c34d
 800a21c:	0800c357 	.word	0x0800c357
 800a220:	0800c362 	.word	0x0800c362
 800a224:	0800c36d 	.word	0x0800c36d
 800a228:	0800c373 	.word	0x0800c373
 800a22c:	0800c379 	.word	0x0800c379
 800a230:	0800be60 	.word	0x0800be60
 800a234:	0800c37f 	.word	0x0800c37f
 800a238:	0800c388 	.word	0x0800c388
 800a23c:	0800bc80 	.word	0x0800bc80
 800a240:	0800c3c7 	.word	0x0800c3c7
 800a244:	0800c3d2 	.word	0x0800c3d2
 800a248:	0800c3dd 	.word	0x0800c3dd
 800a24c:	0800c3e6 	.word	0x0800c3e6
 800a250:	200011a0 	.word	0x200011a0
 800a254:	0800c10d 	.word	0x0800c10d
 800a258:	0800c06e 	.word	0x0800c06e
 800a25c:	0800c38d 	.word	0x0800c38d
 800a260:	0800c392 	.word	0x0800c392
 800a264:	200011a8 	.word	0x200011a8
 800a268:	0800c397 	.word	0x0800c397
 800a26c:	0800c39f 	.word	0x0800c39f
 800a270:	0800c3a5 	.word	0x0800c3a5
 800a274:	0800c3ad 	.word	0x0800c3ad
 800a278:	0800c3b7 	.word	0x0800c3b7
 800a27c:	0800c3bf 	.word	0x0800c3bf
 800a280:	0800c3ee 	.word	0x0800c3ee
 800a284:	0800c3f7 	.word	0x0800c3f7

0800a288 <cmdMax>:
    }
}


void cmdMax(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 800a288:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a28c:	4604      	mov	r4, r0
 800a28e:	460d      	mov	r5, r1
 800a290:	4698      	mov	r8, r3
    MAX2870Driver* pll = (MAX2870Driver*)user;

    if(argc == 0) {
 800a292:	4616      	mov	r6, r2
{
 800a294:	b087      	sub	sp, #28
    if(argc == 0) {
 800a296:	b92a      	cbnz	r2, 800a2a4 <cmdMax+0x1c>
        cmdMaxUsage(chp);
 800a298:	4628      	mov	r0, r5
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
    } else {
        cmdMaxUsage(chp);
        return;
    }
}
 800a29a:	b007      	add	sp, #28
 800a29c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        cmdMaxUsage(chp);
 800a2a0:	f7fe bb72 	b.w	8008988 <cmdMaxUsage>
    if(!strcmp(argv[0], "tune")) {
 800a2a4:	681f      	ldr	r7, [r3, #0]
 800a2a6:	497f      	ldr	r1, [pc, #508]	; (800a4a4 <cmdMax+0x21c>)
 800a2a8:	4638      	mov	r0, r7
 800a2aa:	f7f9 fc89 	bl	8003bc0 <strcmp>
 800a2ae:	4684      	mov	ip, r0
 800a2b0:	2800      	cmp	r0, #0
 800a2b2:	d158      	bne.n	800a366 <cmdMax+0xde>
        cmdMaxTune(pll, chp, argc-1, argv+1);
 800a2b4:	f106 39ff 	add.w	r9, r6, #4294967295	; 0xffffffff
    MAX2870TuneRequest tune = *max2870getCurrentTuning(pll);
 800a2b8:	466e      	mov	r6, sp
 800a2ba:	f104 0708 	add.w	r7, r4, #8
 800a2be:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800a2c0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800a2c2:	e897 0003 	ldmia.w	r7, {r0, r1}
    if(argc >= 1) {
 800a2c6:	f1b9 0f00 	cmp.w	r9, #0
    MAX2870TuneRequest tune = *max2870getCurrentTuning(pll);
 800a2ca:	e886 0003 	stmia.w	r6, {r0, r1}
    tune.fastLockDurationMicroseconds = 0;
 800a2ce:	f8cd c00c 	str.w	ip, [sp, #12]
    tune.useVCOAutotune = false;
 800a2d2:	f88d c010 	strb.w	ip, [sp, #16]
    if(argc >= 1) {
 800a2d6:	dd20      	ble.n	800a31a <cmdMax+0x92>
        tune.frequency = (uint64_t)strToInt(argv[0], 10) * 1000;
 800a2d8:	210a      	movs	r1, #10
 800a2da:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800a2de:	f7f9 ff78 	bl	80041d2 <strToInt>
 800a2e2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a2e6:	fb80 0303 	smull	r0, r3, r0, r3
    if(argc >= 2) {
 800a2ea:	f1b9 0f01 	cmp.w	r9, #1
        tune.frequency = (uint64_t)strToInt(argv[0], 10) * 1000;
 800a2ee:	e9cd 0300 	strd	r0, r3, [sp]
    if(argc >= 2) {
 800a2f2:	d012      	beq.n	800a31a <cmdMax+0x92>
        tune.powerA = strToInt(argv[1], 10);
 800a2f4:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800a2f8:	f7f9 ff6b 	bl	80041d2 <strToInt>
    if(argc >= 3) {
 800a2fc:	f1b9 0f02 	cmp.w	r9, #2
        tune.powerA = strToInt(argv[1], 10);
 800a300:	f88d 0008 	strb.w	r0, [sp, #8]
    if(argc >= 3) {
 800a304:	d009      	beq.n	800a31a <cmdMax+0x92>
        tune.useVCOAutotune = (strToInt(argv[2], 10) > 0);
 800a306:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800a30a:	f7f9 ff62 	bl	80041d2 <strToInt>
 800a30e:	2800      	cmp	r0, #0
 800a310:	bfd4      	ite	le
 800a312:	2000      	movle	r0, #0
 800a314:	2001      	movgt	r0, #1
 800a316:	f88d 0010 	strb.w	r0, [sp, #16]
    MAX2870TuneResult result = max2870Tune(pll, &tune);
 800a31a:	4669      	mov	r1, sp
 800a31c:	4620      	mov	r0, r4
 800a31e:	f7fe ffb9 	bl	8009294 <max2870Tune>
    if(result == TUNE_OK) {
 800a322:	2800      	cmp	r0, #0
 800a324:	f040 80b9 	bne.w	800a49a <cmdMax+0x212>
        max2870StatusPrint(pll, chp);
 800a328:	4629      	mov	r1, r5
 800a32a:	4620      	mov	r0, r4
 800a32c:	f7fe fbe2 	bl	8008af4 <max2870StatusPrint>
        chprintf(chp, SHELL_NEWLINE_STR);
 800a330:	4628      	mov	r0, r5
 800a332:	495d      	ldr	r1, [pc, #372]	; (800a4a8 <cmdMax+0x220>)
 800a334:	f7fe fa0b 	bl	800874e <chprintf>
    return lock == 0xFF;
}

const char* max2870TuneResultToString(MAX2870TuneResult result)
{
    if(result == TUNE_OK) return "OK";
 800a338:	4a5c      	ldr	r2, [pc, #368]	; (800a4ac <cmdMax+0x224>)
    chprintf(chp, "Tuning result: %s"SHELL_NEWLINE_STR, max2870TuneResultToString(result));
 800a33a:	4628      	mov	r0, r5
 800a33c:	495c      	ldr	r1, [pc, #368]	; (800a4b0 <cmdMax+0x228>)
 800a33e:	f7fe fa06 	bl	800874e <chprintf>
}
 800a342:	b007      	add	sp, #28
 800a344:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(result == TUNE_CANT_FASTLOCK) return "Invalid fastlock command";
    if(result == TUNE_NOT_LOCKED) return "Lock failed";
 800a348:	1d06      	adds	r6, r0, #4
 800a34a:	d008      	beq.n	800a35e <cmdMax+0xd6>
    if(result == TUNE_PLL_N_OUT_OF_RANGE) return "N out of range";
 800a34c:	1c84      	adds	r4, r0, #2
 800a34e:	d008      	beq.n	800a362 <cmdMax+0xda>
    if(result == TUNE_FREQUENCY_OUT_OF_RANGE) return "Frequency out of range";
 800a350:	4a58      	ldr	r2, [pc, #352]	; (800a4b4 <cmdMax+0x22c>)
 800a352:	4b59      	ldr	r3, [pc, #356]	; (800a4b8 <cmdMax+0x230>)
 800a354:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800a358:	bf08      	it	eq
 800a35a:	461a      	moveq	r2, r3
 800a35c:	e7ed      	b.n	800a33a <cmdMax+0xb2>
    if(result == TUNE_NOT_LOCKED) return "Lock failed";
 800a35e:	4a57      	ldr	r2, [pc, #348]	; (800a4bc <cmdMax+0x234>)
 800a360:	e7eb      	b.n	800a33a <cmdMax+0xb2>
    if(result == TUNE_PLL_N_OUT_OF_RANGE) return "N out of range";
 800a362:	4a57      	ldr	r2, [pc, #348]	; (800a4c0 <cmdMax+0x238>)
 800a364:	e7e9      	b.n	800a33a <cmdMax+0xb2>
    } else if(!strcmp(argv[0], "status")) {
 800a366:	4638      	mov	r0, r7
 800a368:	4956      	ldr	r1, [pc, #344]	; (800a4c4 <cmdMax+0x23c>)
 800a36a:	f7f9 fc29 	bl	8003bc0 <strcmp>
 800a36e:	b930      	cbnz	r0, 800a37e <cmdMax+0xf6>
        max2870StatusPrint(pll, chp);
 800a370:	4629      	mov	r1, r5
 800a372:	4620      	mov	r0, r4
}
 800a374:	b007      	add	sp, #28
 800a376:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        max2870StatusPrint(pll, chp);
 800a37a:	f7fe bbbb 	b.w	8008af4 <max2870StatusPrint>
    } else if(!strcmp(argv[0], "vcocache")) {
 800a37e:	4638      	mov	r0, r7
 800a380:	4951      	ldr	r1, [pc, #324]	; (800a4c8 <cmdMax+0x240>)
 800a382:	f7f9 fc1d 	bl	8003bc0 <strcmp>
 800a386:	2800      	cmp	r0, #0
 800a388:	d15f      	bne.n	800a44a <cmdMax+0x1c2>
    if(argc == 0) {
 800a38a:	1e77      	subs	r7, r6, #1
 800a38c:	d121      	bne.n	800a3d2 <cmdMax+0x14a>
    uint32_t frequency = MAX2870_VCO_MIN_FREQUENCY/1000000 + MAX2870_VCO_INCREMENT/2000000;
 800a38e:	f640 36c2 	movw	r6, #3010	; 0xbc2
        chprintf(stdout, "Frequency: %u MHz, VCO Band: ", frequency);
 800a392:	4f4e      	ldr	r7, [pc, #312]	; (800a4cc <cmdMax+0x244>)
            chprintf(stdout, "Invalid"SHELL_NEWLINE_STR);
 800a394:	f8df 8138 	ldr.w	r8, [pc, #312]	; 800a4d0 <cmdMax+0x248>
            chprintf(stdout, "%u"SHELL_NEWLINE_STR, vco & 0x3f);
 800a398:	f8df 9138 	ldr.w	r9, [pc, #312]	; 800a4d4 <cmdMax+0x24c>
 800a39c:	3420      	adds	r4, #32
        chprintf(stdout, "Frequency: %u MHz, VCO Band: ", frequency);
 800a39e:	4632      	mov	r2, r6
 800a3a0:	4639      	mov	r1, r7
 800a3a2:	4628      	mov	r0, r5
 800a3a4:	f7fe f9d3 	bl	800874e <chprintf>
        uint8_t vco = driver->vcoCache[i];
 800a3a8:	f814 2b01 	ldrb.w	r2, [r4], #1
        if(vco & 0x80) {
 800a3ac:	0610      	lsls	r0, r2, #24
 800a3ae:	d50b      	bpl.n	800a3c8 <cmdMax+0x140>
            chprintf(stdout, "%u"SHELL_NEWLINE_STR, vco & 0x3f);
 800a3b0:	4649      	mov	r1, r9
 800a3b2:	4628      	mov	r0, r5
 800a3b4:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800a3b8:	f7fe f9c9 	bl	800874e <chprintf>
    for(unsigned int i=0; i<sizeof(driver->vcoCache); i++) {
 800a3bc:	f241 737a 	movw	r3, #6010	; 0x177a
        frequency += MAX2870_VCO_INCREMENT/1000000;
 800a3c0:	3614      	adds	r6, #20
    for(unsigned int i=0; i<sizeof(driver->vcoCache); i++) {
 800a3c2:	429e      	cmp	r6, r3
 800a3c4:	d1eb      	bne.n	800a39e <cmdMax+0x116>
 800a3c6:	e7bc      	b.n	800a342 <cmdMax+0xba>
            chprintf(stdout, "Invalid"SHELL_NEWLINE_STR);
 800a3c8:	4641      	mov	r1, r8
 800a3ca:	4628      	mov	r0, r5
 800a3cc:	f7fe f9bf 	bl	800874e <chprintf>
 800a3d0:	e7f4      	b.n	800a3bc <cmdMax+0x134>
    } else if(!strcmp(argv[0], "calibrate")) {
 800a3d2:	f8d8 6004 	ldr.w	r6, [r8, #4]
 800a3d6:	4940      	ldr	r1, [pc, #256]	; (800a4d8 <cmdMax+0x250>)
 800a3d8:	4630      	mov	r0, r6
 800a3da:	f7f9 fbf1 	bl	8003bc0 <strcmp>
 800a3de:	b948      	cbnz	r0, 800a3f4 <cmdMax+0x16c>
        max2870VcoPrecal(pll);
 800a3e0:	4620      	mov	r0, r4
 800a3e2:	f7fe ff85 	bl	80092f0 <max2870VcoPrecal>
        chprintf(chp, "Done"SHELL_NEWLINE_STR);
 800a3e6:	493d      	ldr	r1, [pc, #244]	; (800a4dc <cmdMax+0x254>)
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a3e8:	4628      	mov	r0, r5
}
 800a3ea:	b007      	add	sp, #28
 800a3ec:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a3f0:	f7fe b9ad 	b.w	800874e <chprintf>
    } else if(argc >= 2 && !strcmp(argv[0], "set")) {
 800a3f4:	2f01      	cmp	r7, #1
 800a3f6:	f77f af4f 	ble.w	800a298 <cmdMax+0x10>
 800a3fa:	4630      	mov	r0, r6
 800a3fc:	4938      	ldr	r1, [pc, #224]	; (800a4e0 <cmdMax+0x258>)
 800a3fe:	f7f9 fbdf 	bl	8003bc0 <strcmp>
 800a402:	4606      	mov	r6, r0
 800a404:	2800      	cmp	r0, #0
 800a406:	f47f af47 	bne.w	800a298 <cmdMax+0x10>
        unsigned int a = strToInt(argv[1], 10);
 800a40a:	210a      	movs	r1, #10
 800a40c:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800a410:	f7f9 fedf 	bl	80041d2 <strToInt>
        if(argc == 3) {
 800a414:	2f03      	cmp	r7, #3
        unsigned int a = strToInt(argv[1], 10);
 800a416:	4681      	mov	r9, r0
        if(argc == 3) {
 800a418:	d10a      	bne.n	800a430 <cmdMax+0x1a8>
            b = strToInt(argv[2], 10) | 0x80;
 800a41a:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800a41e:	f7f9 fed8 	bl	80041d2 <strToInt>
 800a422:	f040 0380 	orr.w	r3, r0, #128	; 0x80
    return &driver->currentTune;
}

bool max2870VcoCacheSet(MAX2870Driver* driver, unsigned int vcoIndex, uint8_t value)
{
    if(vcoIndex > sizeof(driver->vcoCache)) {
 800a426:	f1b9 0f96 	cmp.w	r9, #150	; 0x96
 800a42a:	d903      	bls.n	800a434 <cmdMax+0x1ac>
            chprintf(chp, "The cow says moo!"SHELL_NEWLINE_STR);
 800a42c:	492d      	ldr	r1, [pc, #180]	; (800a4e4 <cmdMax+0x25c>)
 800a42e:	e7db      	b.n	800a3e8 <cmdMax+0x160>
        unsigned int b = 0;
 800a430:	4633      	mov	r3, r6
 800a432:	e7f8      	b.n	800a426 <cmdMax+0x19e>
            chprintf(chp, "%u=0x%02x"SHELL_NEWLINE_STR,a,b);
 800a434:	464a      	mov	r2, r9
 800a436:	4628      	mov	r0, r5
 800a438:	492b      	ldr	r1, [pc, #172]	; (800a4e8 <cmdMax+0x260>)
        return false;
    }

    driver->vcoCache[vcoIndex] = value;
 800a43a:	444c      	add	r4, r9
        if(max2870VcoCacheSet(pll, a , b)) {
 800a43c:	f884 3020 	strb.w	r3, [r4, #32]
}
 800a440:	b007      	add	sp, #28
 800a442:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            chprintf(chp, "%u=0x%02x"SHELL_NEWLINE_STR,a,b);
 800a446:	f7fe b982 	b.w	800874e <chprintf>
    } else if(!strcmp(argv[0], "dld")) {
 800a44a:	4638      	mov	r0, r7
 800a44c:	4927      	ldr	r1, [pc, #156]	; (800a4ec <cmdMax+0x264>)
 800a44e:	f7f9 fbb7 	bl	8003bc0 <strcmp>
 800a452:	2800      	cmp	r0, #0
 800a454:	f47f af20 	bne.w	800a298 <cmdMax+0x10>
    max2870SpiState(driver, true);
 800a458:	4620      	mov	r0, r4
 800a45a:	f7fd fe65 	bl	8008128 <max2870SpiState.constprop.0>
    max2870SetMUXOut(driver, 0x6);
 800a45e:	4620      	mov	r0, r4
 800a460:	2106      	movs	r1, #6
 800a462:	f7fd ff63 	bl	800832c <max2870SetMUXOut>
    spiReceive(driver->config->spiPort, 1, &lock);
 800a466:	6823      	ldr	r3, [r4, #0]
 800a468:	6818      	ldr	r0, [r3, #0]
 800a46a:	b910      	cbnz	r0, 800a472 <cmdMax+0x1ea>
 800a46c:	f7fa faa2 	bl	80049b4 <vTaskEndScheduler>
 800a470:	e7fe      	b.n	800a470 <cmdMax+0x1e8>
 800a472:	466a      	mov	r2, sp
 800a474:	2101      	movs	r1, #1
 800a476:	f7fc f8cb 	bl	8006610 <spiReceive.part.0>
    if(enable) {
 800a47a:	4620      	mov	r0, r4
 800a47c:	f7fe f922 	bl	80086c4 <max2870SpiState.part.0>
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
 800a480:	4628      	mov	r0, r5
    return lock == 0xFF;
 800a482:	f89d 2000 	ldrb.w	r2, [sp]
 800a486:	f1a2 01ff 	sub.w	r1, r2, #255	; 0xff
 800a48a:	424a      	negs	r2, r1
 800a48c:	414a      	adcs	r2, r1
 800a48e:	4918      	ldr	r1, [pc, #96]	; (800a4f0 <cmdMax+0x268>)
}
 800a490:	b007      	add	sp, #28
 800a492:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        chprintf(chp, "Digital Lock Detect: %u"SHELL_NEWLINE_STR, max2870GetDigitalLockDetect(pll));
 800a496:	f7fe b95a 	b.w	800874e <chprintf>
    if(result == TUNE_CANT_FASTLOCK) return "Invalid fastlock command";
 800a49a:	1cc3      	adds	r3, r0, #3
 800a49c:	f47f af54 	bne.w	800a348 <cmdMax+0xc0>
 800a4a0:	4a14      	ldr	r2, [pc, #80]	; (800a4f4 <cmdMax+0x26c>)
 800a4a2:	e74a      	b.n	800a33a <cmdMax+0xb2>
 800a4a4:	0800c457 	.word	0x0800c457
 800a4a8:	0800be60 	.word	0x0800be60
 800a4ac:	0800ba71 	.word	0x0800ba71
 800a4b0:	0800c45c 	.word	0x0800c45c
 800a4b4:	0800c3fe 	.word	0x0800c3fe
 800a4b8:	0800c427 	.word	0x0800c427
 800a4bc:	0800c41b 	.word	0x0800c41b
 800a4c0:	0800c40c 	.word	0x0800c40c
 800a4c4:	0800c06f 	.word	0x0800c06f
 800a4c8:	0800c470 	.word	0x0800c470
 800a4cc:	0800c479 	.word	0x0800c479
 800a4d0:	0800c497 	.word	0x0800c497
 800a4d4:	0800c18d 	.word	0x0800c18d
 800a4d8:	0800c4a1 	.word	0x0800c4a1
 800a4dc:	0800c4ab 	.word	0x0800c4ab
 800a4e0:	0800c0a7 	.word	0x0800c0a7
 800a4e4:	0800c4b2 	.word	0x0800c4b2
 800a4e8:	0800c4c6 	.word	0x0800c4c6
 800a4ec:	0800c4d2 	.word	0x0800c4d2
 800a4f0:	0800c4d6 	.word	0x0800c4d6
 800a4f4:	0800c43e 	.word	0x0800c43e

0800a4f8 <cmdSof>:

void cmdSof(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
    (void) user;

    if(argc > 0) {
 800a4f8:	2a00      	cmp	r2, #0
{
 800a4fa:	b538      	push	{r3, r4, r5, lr}
 800a4fc:	460c      	mov	r4, r1
 800a4fe:	4d16      	ldr	r5, [pc, #88]	; (800a558 <cmdSof+0x60>)
    if(argc > 0) {
 800a500:	dd06      	ble.n	800a510 <cmdSof+0x18>
        if(!strcmp(argv[0],"1")) {
 800a502:	4916      	ldr	r1, [pc, #88]	; (800a55c <cmdSof+0x64>)
 800a504:	6818      	ldr	r0, [r3, #0]
 800a506:	f7f9 fb5b 	bl	8003bc0 <strcmp>
 800a50a:	b9f0      	cbnz	r0, 800a54a <cmdSof+0x52>
    sofNeededCallback
};

void usbDisableSOF(bool doIt)
{
    allowDisableSOF = doIt;
 800a50c:	2301      	movs	r3, #1
 800a50e:	702b      	strb	r3, [r5, #0]
            usbDisableSOF(true);
        } else {
            usbDisableSOF(false);
        }
    }
    printfFixed(chp, 21, "SoF Disable Allowed:");
 800a510:	2115      	movs	r1, #21
 800a512:	4a13      	ldr	r2, [pc, #76]	; (800a560 <cmdSof+0x68>)
 800a514:	4620      	mov	r0, r4
 800a516:	f7fe fac7 	bl	8008aa8 <printfFixed>
    }
}

uint32_t usbGetSofCounter(bool* sofDisableAllowed)
{
    osalSysLock();
 800a51a:	f7fa fa3b 	bl	8004994 <vPortEnterCritical>
    if(sofDisableAllowed) *sofDisableAllowed=allowDisableSOF;

    uint32_t count = sofCounter;
 800a51e:	4b11      	ldr	r3, [pc, #68]	; (800a564 <cmdSof+0x6c>)
    if(sofDisableAllowed) *sofDisableAllowed=allowDisableSOF;
 800a520:	7828      	ldrb	r0, [r5, #0]
    uint32_t count = sofCounter;
 800a522:	681d      	ldr	r5, [r3, #0]
    osalSysUnlock();
 800a524:	f7fa fc5a 	bl	8004ddc <osalSysUnlock.lto_priv.0>
    bool allowDisable;
    uint32_t cnt = usbGetSofCounter(&allowDisable);
    chprintf(chp, "%u"SHELL_NEWLINE_STR, allowDisable);
 800a528:	4602      	mov	r2, r0
 800a52a:	490f      	ldr	r1, [pc, #60]	; (800a568 <cmdSof+0x70>)
 800a52c:	4620      	mov	r0, r4
 800a52e:	f7fe f90e 	bl	800874e <chprintf>
    printfFixed(chp, 21, "SoF Count:");
 800a532:	2115      	movs	r1, #21
 800a534:	4620      	mov	r0, r4
 800a536:	4a0d      	ldr	r2, [pc, #52]	; (800a56c <cmdSof+0x74>)
 800a538:	f7fe fab6 	bl	8008aa8 <printfFixed>
    chprintf(chp, "%u"SHELL_NEWLINE_STR, cnt);
 800a53c:	462a      	mov	r2, r5
 800a53e:	4620      	mov	r0, r4
}
 800a540:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chprintf(chp, "%u"SHELL_NEWLINE_STR, cnt);
 800a544:	4908      	ldr	r1, [pc, #32]	; (800a568 <cmdSof+0x70>)
 800a546:	f7fe b902 	b.w	800874e <chprintf>
    allowDisableSOF = doIt;
 800a54a:	2300      	movs	r3, #0
        sofNeededCallback(&USBD1, true);
 800a54c:	2101      	movs	r1, #1
 800a54e:	4808      	ldr	r0, [pc, #32]	; (800a570 <cmdSof+0x78>)
    allowDisableSOF = doIt;
 800a550:	702b      	strb	r3, [r5, #0]
        sofNeededCallback(&USBD1, true);
 800a552:	f7fb fc4d 	bl	8005df0 <sofNeededCallback>
 800a556:	e7db      	b.n	800a510 <cmdSof+0x18>
 800a558:	20000800 	.word	0x20000800
 800a55c:	0800bbc0 	.word	0x0800bbc0
 800a560:	0800c4f0 	.word	0x0800c4f0
 800a564:	200012c8 	.word	0x200012c8
 800a568:	0800c18d 	.word	0x0800c18d
 800a56c:	0800c505 	.word	0x0800c505
 800a570:	20000f54 	.word	0x20000f54

0800a574 <cmdSanity>:

void cmdSanity(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
    (void)user;

    if(argc == 1) {
 800a574:	2a01      	cmp	r2, #1
{
 800a576:	b570      	push	{r4, r5, r6, lr}
 800a578:	460c      	mov	r4, r1
 800a57a:	4615      	mov	r5, r2
    if(argc == 1) {
 800a57c:	d117      	bne.n	800a5ae <cmdSanity+0x3a>
        if(sanitySettingsLocked){
 800a57e:	4e11      	ldr	r6, [pc, #68]	; (800a5c4 <cmdSanity+0x50>)
 800a580:	7832      	ldrb	r2, [r6, #0]
 800a582:	b12a      	cbz	r2, 800a590 <cmdSanity+0x1c>
            chprintf(chp, "Settings locked!"SHELL_NEWLINE_STR);
 800a584:	4910      	ldr	r1, [pc, #64]	; (800a5c8 <cmdSanity+0x54>)
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a586:	4620      	mov	r0, r4
        }
        return;
    };

    cmdSanityUsage(chp);
}
 800a588:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a58c:	f7fe b8df 	b.w	800874e <chprintf>
        }else if(!strcmp(argv[0], "lock")) {
 800a590:	681c      	ldr	r4, [r3, #0]
 800a592:	490e      	ldr	r1, [pc, #56]	; (800a5cc <cmdSanity+0x58>)
 800a594:	4620      	mov	r0, r4
 800a596:	f7f9 fb13 	bl	8003bc0 <strcmp>
 800a59a:	b908      	cbnz	r0, 800a5a0 <cmdSanity+0x2c>
            sanitySettingsLocked = true;
 800a59c:	7035      	strb	r5, [r6, #0]
}
 800a59e:	bd70      	pop	{r4, r5, r6, pc}
            sanityRebootSeconds = strToInt(argv[0], 10);
 800a5a0:	210a      	movs	r1, #10
 800a5a2:	4620      	mov	r0, r4
 800a5a4:	f7f9 fe15 	bl	80041d2 <strToInt>
 800a5a8:	4b09      	ldr	r3, [pc, #36]	; (800a5d0 <cmdSanity+0x5c>)
 800a5aa:	6018      	str	r0, [r3, #0]
 800a5ac:	e7f7      	b.n	800a59e <cmdSanity+0x2a>
    chprintf(chp, "Usage:"SHELL_NEWLINE_STR);
 800a5ae:	4909      	ldr	r1, [pc, #36]	; (800a5d4 <cmdSanity+0x60>)
 800a5b0:	4620      	mov	r0, r4
 800a5b2:	f7fe f8cc 	bl	800874e <chprintf>
    chprintf(chp, "\tsanity lock"SHELL_NEWLINE_STR);
 800a5b6:	4908      	ldr	r1, [pc, #32]	; (800a5d8 <cmdSanity+0x64>)
 800a5b8:	4620      	mov	r0, r4
 800a5ba:	f7fe f8c8 	bl	800874e <chprintf>
    chprintf(chp, "\tsanity [delaysec]"SHELL_NEWLINE_STR);
 800a5be:	4907      	ldr	r1, [pc, #28]	; (800a5dc <cmdSanity+0x68>)
 800a5c0:	e7e1      	b.n	800a586 <cmdSanity+0x12>
 800a5c2:	bf00      	nop
 800a5c4:	20001230 	.word	0x20001230
 800a5c8:	0800c510 	.word	0x0800c510
 800a5cc:	0800c523 	.word	0x0800c523
 800a5d0:	20000858 	.word	0x20000858
 800a5d4:	0800bc69 	.word	0x0800bc69
 800a5d8:	0800c528 	.word	0x0800c528
 800a5dc:	0800c537 	.word	0x0800c537

0800a5e0 <i2cSafeWriteRegStandard>:
{
 800a5e0:	b530      	push	{r4, r5, lr}
 800a5e2:	460d      	mov	r5, r1
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 800a5e4:	4604      	mov	r4, r0
{
 800a5e6:	b085      	sub	sp, #20
    osalDbgAssert(i2c != NULL, "i2c == NULL");
 800a5e8:	b910      	cbnz	r0, 800a5f0 <i2cSafeWriteRegStandard+0x10>
 800a5ea:	f7fa f9e3 	bl	80049b4 <vTaskEndScheduler>
 800a5ee:	e7fe      	b.n	800a5ee <i2cSafeWriteRegStandard+0xe>
    txBuf[0]=addr;
 800a5f0:	f88d 200c 	strb.w	r2, [sp, #12]
    memcpy(&txBuf[1], values, len);
 800a5f4:	f88d 300d 	strb.w	r3, [sp, #13]
    i2cAcquireBus(i2c);
 800a5f8:	f7fb f89a 	bl	8005730 <i2cAcquireBus>
    i2c_status = i2cSafeMasterTransmitTimeoutWithRetry(i2c, devAddr, txBuf,
 800a5fc:	2300      	movs	r3, #0
 800a5fe:	4629      	mov	r1, r5
 800a600:	e9cd 3300 	strd	r3, r3, [sp]
 800a604:	aa03      	add	r2, sp, #12
 800a606:	2302      	movs	r3, #2
 800a608:	4620      	mov	r0, r4
 800a60a:	f7fe fef5 	bl	80093f8 <i2cSafeMasterTransmitTimeoutWithRetry.constprop.0>
 800a60e:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 800a610:	4620      	mov	r0, r4
 800a612:	f7fe f84d 	bl	80086b0 <i2cReleaseBus>
}
 800a616:	4628      	mov	r0, r5
 800a618:	b005      	add	sp, #20
 800a61a:	bd30      	pop	{r4, r5, pc}

0800a61c <main_>:
{
 800a61c:	b5f0      	push	{r4, r5, r6, r7, lr}
    void* syslogBuffer = pvPortMalloc(bufferSize);
 800a61e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800a622:	b085      	sub	sp, #20
 800a624:	f7fa fdee 	bl	8005204 <pvPortMalloc>
    memset(queue, 0, sizeof(*queue));
 800a628:	4c55      	ldr	r4, [pc, #340]	; (800a780 <main_+0x164>)
 800a62a:	4605      	mov	r5, r0
 800a62c:	221c      	movs	r2, #28
 800a62e:	2100      	movs	r1, #0
 800a630:	f104 0008 	add.w	r0, r4, #8
 800a634:	f001 f8ea 	bl	800b80c <memset>

    queue->buffer = buffer;
    queue->bufferSize = bufferSize;
 800a638:	f44f 6380 	mov.w	r3, #1024	; 0x400
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800a63c:	2050      	movs	r0, #80	; 0x50
    queue->buffer = buffer;
 800a63e:	6025      	str	r5, [r4, #0]
    queue->bufferSize = bufferSize;
 800a640:	6063      	str	r3, [r4, #4]
 800a642:	f7fa fddf 	bl	8005204 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800a646:	4604      	mov	r4, r0
 800a648:	b160      	cbz	r0, 800a664 <main_+0x48>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a64a:	2300      	movs	r3, #0
	pxNewQueue->uxLength = uxQueueLength;
 800a64c:	2501      	movs	r5, #1
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a64e:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 800a652:	e9c0 530f 	strd	r5, r3, [r0, #60]	; 0x3c
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800a656:	6000      	str	r0, [r0, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800a658:	f7fe f84f 	bl	80086fa <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800a65c:	f880 504c 	strb.w	r5, [r0, #76]	; 0x4c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800a660:	f7fe f845 	bl	80086ee <prvInitialiseMutex.part.0>
    syslogSemaphore = xSemaphoreCreateMutex();
 800a664:	4b47      	ldr	r3, [pc, #284]	; (800a784 <main_+0x168>)
    syslog("Syslog started.");
 800a666:	4848      	ldr	r0, [pc, #288]	; (800a788 <main_+0x16c>)
    syslogSemaphore = xSemaphoreCreateMutex();
 800a668:	601c      	str	r4, [r3, #0]
    syslog("Syslog started.");
 800a66a:	f7fe fb8d 	bl	8008d88 <syslog>
    usbDisconnectBus(serusbcfg.usbp);
 800a66e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    event_source->setEvents = 0;
 800a672:	2400      	movs	r4, #0
 800a674:	4d45      	ldr	r5, [pc, #276]	; (800a78c <main_+0x170>)
 800a676:	4846      	ldr	r0, [pc, #280]	; (800a790 <main_+0x174>)
 800a678:	616b      	str	r3, [r5, #20]
    event_source->firstRepeater = NULL;
 800a67a:	e9c0 4400 	strd	r4, r4, [r0]
    event_source->waitThread = NULL;
 800a67e:	6084      	str	r4, [r0, #8]
    osalSysLock();
 800a680:	f7fa f988 	bl	8004994 <vPortEnterCritical>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800a684:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800a688:	b1b3      	cbz	r3, 800a6b8 <main_+0x9c>

void osalEventRegisterCallbackI(event_source_t* source, void (*eventCallback)(event_source_t* source, eventflags_t set)){
    osalDbgCheck(source != NULL);
    osalDbgCheckClassI();

    source->eventCallback = eventCallback;
 800a68a:	4b42      	ldr	r3, [pc, #264]	; (800a794 <main_+0x178>)
    GPIODriverData.numPorts = numPorts;
 800a68c:	4e42      	ldr	r6, [pc, #264]	; (800a798 <main_+0x17c>)
 800a68e:	60c3      	str	r3, [r0, #12]
    osalSysUnlock();
 800a690:	f7fa fba4 	bl	8004ddc <osalSysUnlock.lto_priv.0>
 800a694:	2304      	movs	r3, #4
    GPIODriverData.ports = pvPortMalloc(sizeof(GPIOPort) * numPorts);
 800a696:	2030      	movs	r0, #48	; 0x30
    GPIODriverData.numPorts = numPorts;
 800a698:	7133      	strb	r3, [r6, #4]
    GPIODriverData.ports = pvPortMalloc(sizeof(GPIOPort) * numPorts);
 800a69a:	f7fa fdb3 	bl	8005204 <pvPortMalloc>
 800a69e:	6030      	str	r0, [r6, #0]
    if(!GPIODriverData.ports) {
 800a6a0:	b968      	cbnz	r0, 800a6be <main_+0xa2>
        syslog("GPIO subsystem init failed.");
 800a6a2:	483e      	ldr	r0, [pc, #248]	; (800a79c <main_+0x180>)
    syslog("USB init done.");
 800a6a4:	f7fe fb70 	bl	8008d88 <syslog>
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
 800a6a8:	2200      	movs	r2, #0
 800a6aa:	493d      	ldr	r1, [pc, #244]	; (800a7a0 <main_+0x184>)
 800a6ac:	483d      	ldr	r0, [pc, #244]	; (800a7a4 <main_+0x188>)
}
 800a6ae:	b005      	add	sp, #20
 800a6b0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    shellStart((BaseSequentialStream*)&SD3, 128, "ShellTTL", NULL, NULL);
 800a6b4:	f7fd bb44 	b.w	8007d40 <shellStart.constprop.0>
    osalDbgCheckClassI();
 800a6b8:	f7fa f97c 	bl	80049b4 <vTaskEndScheduler>
 800a6bc:	e7fe      	b.n	800a6bc <main_+0xa0>
        GPIODriverData.ports[i].numPins = 0;
 800a6be:	4623      	mov	r3, r4
        GPIODriverData.ports[i].functions = &gpioDummyFunctions;
 800a6c0:	4a39      	ldr	r2, [pc, #228]	; (800a7a8 <main_+0x18c>)
        GPIODriverData.ports[i].driver = (void*)(unsigned int)i;
 800a6c2:	6004      	str	r4, [r0, #0]
    for(uint8_t i=0; i<numPorts; i++) {
 800a6c4:	3401      	adds	r4, #1
 800a6c6:	2c04      	cmp	r4, #4
        GPIODriverData.ports[i].numPins = 0;
 800a6c8:	e9c0 3201 	strd	r3, r2, [r0, #4]
    for(uint8_t i=0; i<numPorts; i++) {
 800a6cc:	f100 000c 	add.w	r0, r0, #12
 800a6d0:	d1f7      	bne.n	800a6c2 <main_+0xa6>
        syslog("GPIO subsystem init done.");
 800a6d2:	4836      	ldr	r0, [pc, #216]	; (800a7ac <main_+0x190>)
 800a6d4:	f7fe fb58 	bl	8008d88 <syslog>
        gpioCPUInit(GPIO_PORT_GPIOA, GPIOA);
 800a6d8:	492c      	ldr	r1, [pc, #176]	; (800a78c <main_+0x170>)
 800a6da:	2000      	movs	r0, #0
 800a6dc:	f7f9 fedc 	bl	8004498 <gpioCPUInit>
        gpioCPUInit(GPIO_PORT_GPIOB, GPIOB);
 800a6e0:	2001      	movs	r0, #1
 800a6e2:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800a6e6:	f7f9 fed7 	bl	8004498 <gpioCPUInit>
        gpioCPUInit(GPIO_PORT_GPIOC, GPIOC);
 800a6ea:	2002      	movs	r0, #2
 800a6ec:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800a6f0:	f7f9 fed2 	bl	8004498 <gpioCPUInit>
        shellCommandRegister("gpio", cmdGPIO, NULL);
 800a6f4:	2200      	movs	r2, #0
 800a6f6:	492e      	ldr	r1, [pc, #184]	; (800a7b0 <main_+0x194>)
 800a6f8:	482e      	ldr	r0, [pc, #184]	; (800a7b4 <main_+0x198>)
 800a6fa:	f7f9 fdab 	bl	8004254 <shellCommandRegister>
    gpioSetPinMode(gpioPin, PAL_MODE_INPUT_PULLUP);
 800a6fe:	2103      	movs	r1, #3
 800a700:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a704:	f7fc fdfe 	bl	8007304 <gpioSetPinMode.isra.0>
    osalThreadSleepMilliseconds(1);
 800a708:	2001      	movs	r0, #1
 800a70a:	f7fa fe39 	bl	8005380 <vTaskDelay>
    if(gpioGetPin(gpioPin) == 0) {
 800a70e:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a712:	f7f9 fe5f 	bl	80043d4 <gpioGetPin>
 800a716:	b158      	cbz	r0, 800a730 <main_+0x114>
    gpioSetPinMode(gpioPin, PAL_MODE_INPUT_PULLDOWN);
 800a718:	4621      	mov	r1, r4
 800a71a:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a71e:	f7fc fdf1 	bl	8007304 <gpioSetPinMode.isra.0>
    osalThreadSleepMilliseconds(1);
 800a722:	2001      	movs	r0, #1
 800a724:	f7fa fe2c 	bl	8005380 <vTaskDelay>
    if(gpioGetPin(gpioPin) == 1) {
 800a728:	f44f 7084 	mov.w	r0, #264	; 0x108
 800a72c:	f7f9 fe52 	bl	80043d4 <gpioGetPin>
    uint32_t index = 0;

    for(;;) {
        const GPIOPinInit* pin = &pins[index];

        if(pin->gpioPin == 0xffff) {
 800a730:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800a734:	4c20      	ldr	r4, [pc, #128]	; (800a7b8 <main_+0x19c>)
 800a736:	f834 0b04 	ldrh.w	r0, [r4], #4
 800a73a:	42b0      	cmp	r0, r6
 800a73c:	d00a      	beq.n	800a754 <main_+0x138>
            return;
        }

        gpioSetPinMode(pin->gpioPin, pin->gpioMode);
 800a73e:	f814 1c02 	ldrb.w	r1, [r4, #-2]
 800a742:	f7fc fddf 	bl	8007304 <gpioSetPinMode.isra.0>
        gpioSetPin(pin->gpioPin, pin->defaultValue);
 800a746:	f814 1c01 	ldrb.w	r1, [r4, #-1]
 800a74a:	f834 0c04 	ldrh.w	r0, [r4, #-4]
 800a74e:	f7fc feed 	bl	800752c <gpioSetPin.isra.0>
    for(;;) {
 800a752:	e7f0      	b.n	800a736 <main_+0x11a>
    i2c->i2cSafeConfig = (void*)config;
 800a754:	4c19      	ldr	r4, [pc, #100]	; (800a7bc <main_+0x1a0>)
 800a756:	4b1a      	ldr	r3, [pc, #104]	; (800a7c0 <main_+0x1a4>)
    i2cSafeRawHardwareControl(i2c);
 800a758:	4620      	mov	r0, r4
    i2c->i2cSafeConfig = (void*)config;
 800a75a:	67e3      	str	r3, [r4, #124]	; 0x7c
    i2cSafeRawHardwareControl(i2c);
 800a75c:	f7fc fdde 	bl	800731c <i2cSafeRawHardwareControl>
    shellCommandRegister("i2c", cmdI2C, &I2CD1);
 800a760:	4622      	mov	r2, r4
 800a762:	4918      	ldr	r1, [pc, #96]	; (800a7c4 <main_+0x1a8>)
 800a764:	4818      	ldr	r0, [pc, #96]	; (800a7c8 <main_+0x1ac>)
 800a766:	f7f9 fd75 	bl	8004254 <shellCommandRegister>
  osalSysLock();
 800a76a:	f7fa f913 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 800a76e:	490d      	ldr	r1, [pc, #52]	; (800a7a4 <main_+0x188>)
 800a770:	7d0b      	ldrb	r3, [r1, #20]
 800a772:	1e5a      	subs	r2, r3, #1
 800a774:	2a01      	cmp	r2, #1
 800a776:	d929      	bls.n	800a7cc <main_+0x1b0>
 800a778:	f7fa f91c 	bl	80049b4 <vTaskEndScheduler>
 800a77c:	e7fe      	b.n	800a77c <main_+0x160>
 800a77e:	bf00      	nop
 800a780:	20001310 	.word	0x20001310
 800a784:	20001334 	.word	0x20001334
 800a788:	0800c54c 	.word	0x0800c54c
 800a78c:	40010800 	.word	0x40010800
 800a790:	200012b8 	.word	0x200012b8
 800a794:	08008dfd 	.word	0x08008dfd
 800a798:	20000928 	.word	0x20000928
 800a79c:	0800c55c 	.word	0x0800c55c
 800a7a0:	0800c66e 	.word	0x0800c66e
 800a7a4:	200009bc 	.word	0x200009bc
 800a7a8:	0800ca34 	.word	0x0800ca34
 800a7ac:	0800c578 	.word	0x0800c578
 800a7b0:	08009655 	.word	0x08009655
 800a7b4:	0800c592 	.word	0x0800c592
 800a7b8:	0800ca84 	.word	0x0800ca84
 800a7bc:	20000934 	.word	0x20000934
 800a7c0:	0800c840 	.word	0x0800c840
 800a7c4:	0800ab59 	.word	0x0800ab59
 800a7c8:	0800c597 	.word	0x0800c597
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 800a7cc:	2b01      	cmp	r3, #1
 800a7ce:	d10c      	bne.n	800a7ea <main_+0x1ce>
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 800a7d0:	4ab4      	ldr	r2, [pc, #720]	; (800aaa4 <main_+0x488>)
 800a7d2:	69d3      	ldr	r3, [r2, #28]
 800a7d4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800a7d8:	61d3      	str	r3, [r2, #28]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a7da:	22c0      	movs	r2, #192	; 0xc0
 800a7dc:	4bb2      	ldr	r3, [pc, #712]	; (800aaa8 <main_+0x48c>)
 800a7de:	f883 2327 	strb.w	r2, [r3, #807]	; 0x327
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a7e2:	2280      	movs	r2, #128	; 0x80
 800a7e4:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a7e8:	605a      	str	r2, [r3, #4]
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800a7ea:	f44f 729c 	mov.w	r2, #312	; 0x138
  USART_TypeDef *u = sdp->usart;
 800a7ee:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
  u->SR = 0;
 800a7f2:	2600      	movs	r6, #0
    u->BRR = STM32_PCLK2 / config->speed;
 800a7f4:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800a7f6:	2040      	movs	r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800a7f8:	2401      	movs	r4, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800a7fa:	f242 122c 	movw	r2, #8492	; 0x212c
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800a7fe:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800a800:	615c      	str	r4, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800a802:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 800a804:	601e      	str	r6, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 800a806:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800a808:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0xFF;
 800a80a:	23ff      	movs	r3, #255	; 0xff
 800a80c:	f881 3084 	strb.w	r3, [r1, #132]	; 0x84
  sdp->state = SD_READY;
 800a810:	2302      	movs	r3, #2
 800a812:	750b      	strb	r3, [r1, #20]
    osalOsRescheduleS();
 800a814:	f7fa f944 	bl	8004aa0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800a818:	f7fa fad4 	bl	8004dc4 <vPortExitCritical>
    xTaskCreate(mixLedTask, "Led", 64, (void*)&mixLedDelay, 1, &mixLedTaskHandle);
 800a81c:	4ba3      	ldr	r3, [pc, #652]	; (800aaac <main_+0x490>)
 800a81e:	4602      	mov	r2, r0
 800a820:	e9cd 4300 	strd	r4, r3, [sp]
    memset(driver, 0, sizeof(*driver));
 800a824:	4ca2      	ldr	r4, [pc, #648]	; (800aab0 <main_+0x494>)
 800a826:	4ba3      	ldr	r3, [pc, #652]	; (800aab4 <main_+0x498>)
 800a828:	49a3      	ldr	r1, [pc, #652]	; (800aab8 <main_+0x49c>)
 800a82a:	48a4      	ldr	r0, [pc, #656]	; (800aabc <main_+0x4a0>)
 800a82c:	f7fd fa58 	bl	8007ce0 <xTaskCreate.isra.0>
 800a830:	22fc      	movs	r2, #252	; 0xfc
 800a832:	4631      	mov	r1, r6
 800a834:	1d20      	adds	r0, r4, #4
 800a836:	f000 ffe9 	bl	800b80c <memset>
    driver->config = config;
 800a83a:	4ba1      	ldr	r3, [pc, #644]	; (800aac0 <main_+0x4a4>)
    max2870Tune(driver, &driver->currentTune);
 800a83c:	f104 0108 	add.w	r1, r4, #8
    driver->config = config;
 800a840:	6023      	str	r3, [r4, #0]
    driver->currentTune.powerA = -127;
 800a842:	f248 1381 	movw	r3, #33153	; 0x8181
    max2870Tune(driver, &driver->currentTune);
 800a846:	4620      	mov	r0, r4
    driver->currentTune.powerA = -127;
 800a848:	8223      	strh	r3, [r4, #16]
    max2870Tune(driver, &driver->currentTune);
 800a84a:	f7fe fd23 	bl	8009294 <max2870Tune>
    uint16_t pfdDivider = driver->config->referenceToPfdDivider;
 800a84e:	6820      	ldr	r0, [r4, #0]
 800a850:	8a83      	ldrh	r3, [r0, #20]
    uint32_t pfdFrequency = driver->config->inputFrequency;
 800a852:	6902      	ldr	r2, [r0, #16]
    if(!(pfdDivider % 2)) {
 800a854:	07d9      	lsls	r1, r3, #31
        pfdDivider /= 2;
 800a856:	bf57      	itett	pl
 800a858:	085b      	lsrpl	r3, r3, #1
    uint32_t register2 = 0;
 800a85a:	4631      	movmi	r1, r6
        register2 |= _BV(MAX2870_REG2_RDIV2_OFFSET);
 800a85c:	f04f 7180 	movpl.w	r1, #16777216	; 0x1000000
        pfdFrequency /= 2;
 800a860:	0852      	lsrpl	r2, r2, #1
    if(pfdDivider > 1023) {
 800a862:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a866:	4e97      	ldr	r6, [pc, #604]	; (800aac4 <main_+0x4a8>)
 800a868:	f080 8099 	bcs.w	800a99e <main_+0x382>
    pfdFrequency /= pfdDivider;
 800a86c:	fbb2 f2f3 	udiv	r2, r2, r3
    if(pfdFrequency % driver->config->stepFrequency) {
 800a870:	6980      	ldr	r0, [r0, #24]
        pfdDivider = 0;
 800a872:	2b01      	cmp	r3, #1
    if(pfdFrequency % driver->config->stepFrequency) {
 800a874:	fbb2 f7f0 	udiv	r7, r2, r0
 800a878:	fb00 2017 	mls	r0, r0, r7, r2
        pfdDivider = 0;
 800a87c:	bf08      	it	eq
 800a87e:	2300      	moveq	r3, #0
    if(pfdFrequency % driver->config->stepFrequency) {
 800a880:	2800      	cmp	r0, #0
 800a882:	f040 808c 	bne.w	800a99e <main_+0x382>
    if(fracDivider > 4095) {
 800a886:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 800a88a:	f080 8088 	bcs.w	800a99e <main_+0x382>
    register2 |= pfdDivider << MAX2870_REG2_R_OFFSET;
 800a88e:	ea41 3383 	orr.w	r3, r1, r3, lsl #14
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a892:	f24c 3150 	movw	r1, #50000	; 0xc350
    driver->refDividerRegister2 = register2;
 800a896:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a89a:	f502 4343 	add.w	r3, r2, #49920	; 0xc300
 800a89e:	334f      	adds	r3, #79	; 0x4f
 800a8a0:	fbb3 f3f1 	udiv	r3, r3, r1
 800a8a4:	b29b      	uxth	r3, r3
    if(driver->bsValue > 1023) {
 800a8a6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    driver->fracDivider = fracDivider;
 800a8aa:	f8a4 70bc 	strh.w	r7, [r4, #188]	; 0xbc
    driver->bsValue = (pfdFrequency + 49999) / 50000;
 800a8ae:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
    if(driver->bsValue > 1023) {
 800a8b2:	d274      	bcs.n	800a99e <main_+0x382>
    entry->name = name;
 800a8b4:	4b84      	ldr	r3, [pc, #528]	; (800aac8 <main_+0x4ac>)
    driver->pfdFrequency = pfdFrequency;
 800a8b6:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
 800a8ba:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
    entry->callback = callback;
 800a8be:	4b83      	ldr	r3, [pc, #524]	; (800aacc <main_+0x4b0>)
    entry->param = param;
 800a8c0:	e9c4 343a 	strd	r3, r4, [r4, #232]	; 0xe8
    entry->next = monThreadFirst;
 800a8c4:	6833      	ldr	r3, [r6, #0]
 800a8c6:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    monThreadFirst = entry;
 800a8ca:	4c81      	ldr	r4, [pc, #516]	; (800aad0 <main_+0x4b4>)
    if(max2870Init(&loPLL, &max2870Config) && max2870VcoPrecal(&loPLL)) {
 800a8cc:	f1a4 00e8 	sub.w	r0, r4, #232	; 0xe8
 800a8d0:	6034      	str	r4, [r6, #0]
 800a8d2:	f7fe fd0d 	bl	80092f0 <max2870VcoPrecal>
 800a8d6:	2800      	cmp	r0, #0
 800a8d8:	d061      	beq.n	800a99e <main_+0x382>
		shellCommandRegister("max", cmdMax, &loPLL);
 800a8da:	487e      	ldr	r0, [pc, #504]	; (800aad4 <main_+0x4b8>)
 800a8dc:	497e      	ldr	r1, [pc, #504]	; (800aad8 <main_+0x4bc>)
 800a8de:	f1a4 02e8 	sub.w	r2, r4, #232	; 0xe8
 800a8e2:	f7f9 fcb7 	bl	8004254 <shellCommandRegister>
		syslog("MAX2870 init done.");
 800a8e6:	487d      	ldr	r0, [pc, #500]	; (800aadc <main_+0x4c0>)
    	syslog("MAX2870 init failed.");
 800a8e8:	f7fe fa4e 	bl	8008d88 <syslog>

bool MCP9804Init(MCP9804Driver* driver, const MCP9804Driver_config* config)
{
    memset(driver, 0, sizeof(*driver));
 800a8ec:	2300      	movs	r3, #0
 800a8ee:	4c7c      	ldr	r4, [pc, #496]	; (800aae0 <main_+0x4c4>)

    driver->config = config;

    /* Read device id */
    uint8_t devId;
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a8f0:	2207      	movs	r2, #7
    memset(driver, 0, sizeof(*driver));
 800a8f2:	6063      	str	r3, [r4, #4]
    driver->config = config;
 800a8f4:	4b7b      	ldr	r3, [pc, #492]	; (800aae4 <main_+0x4c8>)
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a8f6:	2118      	movs	r1, #24
    driver->config = config;
 800a8f8:	6023      	str	r3, [r4, #0]
    if(i2cSafeReadRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x7, &devId) != MSG_OK) {
 800a8fa:	487b      	ldr	r0, [pc, #492]	; (800aae8 <main_+0x4cc>)
 800a8fc:	f10d 030f 	add.w	r3, sp, #15
 800a900:	f7fe fe2a 	bl	8009558 <i2cSafeReadRegStandard>
 800a904:	b998      	cbnz	r0, 800a92e <main_+0x312>
        return false;
    }

    if(devId != 0x2) {
 800a906:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800a90a:	2b02      	cmp	r3, #2
 800a90c:	d10f      	bne.n	800a92e <main_+0x312>
        return false;
    }

    /* Set resolution to the highest */
    if(i2cSafeWriteRegStandard(driver->config->i2cPort, driver->config->i2cAddr, 0x8, 0x3) != MSG_OK) {
 800a90e:	6820      	ldr	r0, [r4, #0]
 800a910:	2303      	movs	r3, #3
 800a912:	7901      	ldrb	r1, [r0, #4]
 800a914:	2208      	movs	r2, #8
 800a916:	6800      	ldr	r0, [r0, #0]
 800a918:	f7ff fe62 	bl	800a5e0 <i2cSafeWriteRegStandard>
 800a91c:	b938      	cbnz	r0, 800a92e <main_+0x312>
 800a91e:	4620      	mov	r0, r4
 800a920:	f7fe fe28 	bl	8009574 <MCP9804MeasureTemperature.part.0>
    if(!MCP9804Init(&tcxoTempSensor, &mcp9804Config)) {
 800a924:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800a928:	4298      	cmp	r0, r3
        return false;
    }

    driver->temperature = MCP9804MeasureTemperature(driver, true);
 800a92a:	80a0      	strh	r0, [r4, #4]
 800a92c:	d139      	bne.n	800a9a2 <main_+0x386>
        syslog("Temperature sensor init failed.");
 800a92e:	486f      	ldr	r0, [pc, #444]	; (800aaec <main_+0x4d0>)
 800a930:	f7fe fa2a 	bl	8008d88 <syslog>
    converter->activeBand = 0xff;
 800a934:	23ff      	movs	r3, #255	; 0xff
 800a936:	4a6e      	ldr	r2, [pc, #440]	; (800aaf0 <main_+0x4d4>)
        shellCommandRegister("convert", cmdConvert, &converter);
 800a938:	496e      	ldr	r1, [pc, #440]	; (800aaf4 <main_+0x4d8>)
 800a93a:	7613      	strb	r3, [r2, #24]
    converter->bands = bands;
 800a93c:	4b6e      	ldr	r3, [pc, #440]	; (800aaf8 <main_+0x4dc>)
 800a93e:	486f      	ldr	r0, [pc, #444]	; (800aafc <main_+0x4e0>)
 800a940:	6153      	str	r3, [r2, #20]
    converter->setConverterGpio = setGpio;
 800a942:	4b6f      	ldr	r3, [pc, #444]	; (800ab00 <main_+0x4e4>)
 800a944:	6213      	str	r3, [r2, #32]
 800a946:	f7f9 fc85 	bl	8004254 <shellCommandRegister>
        if(!converterTune(&converter, &startupTuneRequest)) {
 800a94a:	4610      	mov	r0, r2
 800a94c:	496d      	ldr	r1, [pc, #436]	; (800ab04 <main_+0x4e8>)
 800a94e:	f7f9 fdc1 	bl	80044d4 <converterTune>
 800a952:	2800      	cmp	r0, #0
 800a954:	d12e      	bne.n	800a9b4 <main_+0x398>
            syslog("Converter startup failed.");
 800a956:	486c      	ldr	r0, [pc, #432]	; (800ab08 <main_+0x4ec>)
    entry->param = param;
 800a958:	2700      	movs	r7, #0
            syslog("Converter startup done.");
 800a95a:	f7fe fa15 	bl	8008d88 <syslog>
    entry->name = name;
 800a95e:	486b      	ldr	r0, [pc, #428]	; (800ab0c <main_+0x4f0>)
 800a960:	4b6b      	ldr	r3, [pc, #428]	; (800ab10 <main_+0x4f4>)
    monitorKick(&sanityReboot, true);
 800a962:	2101      	movs	r1, #1
 800a964:	60c3      	str	r3, [r0, #12]
    entry->callback = callback;
 800a966:	4b6b      	ldr	r3, [pc, #428]	; (800ab14 <main_+0x4f8>)
    entry->param = param;
 800a968:	6047      	str	r7, [r0, #4]
    entry->callback = callback;
 800a96a:	6003      	str	r3, [r0, #0]
    entry->next = monThreadFirst;
 800a96c:	6833      	ldr	r3, [r6, #0]
    monThreadFirst = entry;
 800a96e:	6030      	str	r0, [r6, #0]
    entry->next = monThreadFirst;
 800a970:	6083      	str	r3, [r0, #8]
 800a972:	f7fa fa6b 	bl	8004e4c <monitorKick>
    xTaskCreate(taskPeriodicMon, "Monitor", stackSize, NULL, 1, &monThreadHandle );
 800a976:	4b68      	ldr	r3, [pc, #416]	; (800ab18 <main_+0x4fc>)
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800a978:	4c68      	ldr	r4, [pc, #416]	; (800ab1c <main_+0x500>)
 800a97a:	9301      	str	r3, [sp, #4]
 800a97c:	2301      	movs	r3, #1
 800a97e:	2280      	movs	r2, #128	; 0x80
 800a980:	4967      	ldr	r1, [pc, #412]	; (800ab20 <main_+0x504>)
 800a982:	9300      	str	r3, [sp, #0]
 800a984:	4867      	ldr	r0, [pc, #412]	; (800ab24 <main_+0x508>)
 800a986:	463b      	mov	r3, r7
 800a988:	f7fd f9aa 	bl	8007ce0 <xTaskCreate.isra.0>
  osalSysLock();
 800a98c:	f7fa f802 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800a990:	7826      	ldrb	r6, [r4, #0]
 800a992:	1e73      	subs	r3, r6, #1
 800a994:	2b01      	cmp	r3, #1
 800a996:	d90f      	bls.n	800a9b8 <main_+0x39c>
 800a998:	f7fa f80c 	bl	80049b4 <vTaskEndScheduler>
 800a99c:	e7fe      	b.n	800a99c <main_+0x380>
    	syslog("MAX2870 init failed.");
 800a99e:	4862      	ldr	r0, [pc, #392]	; (800ab28 <main_+0x50c>)
 800a9a0:	e7a2      	b.n	800a8e8 <main_+0x2cc>
        syslog("Temperature sensor init done.");
 800a9a2:	4862      	ldr	r0, [pc, #392]	; (800ab2c <main_+0x510>)
 800a9a4:	f7fe f9f0 	bl	8008d88 <syslog>
        shellCommandRegister("temp", cmdTemp, &tcxoTempSensor);
 800a9a8:	4622      	mov	r2, r4
 800a9aa:	4961      	ldr	r1, [pc, #388]	; (800ab30 <main_+0x514>)
 800a9ac:	4861      	ldr	r0, [pc, #388]	; (800ab34 <main_+0x518>)
 800a9ae:	f7f9 fc51 	bl	8004254 <shellCommandRegister>
 800a9b2:	e7bf      	b.n	800a934 <main_+0x318>
            syslog("Converter startup done.");
 800a9b4:	4860      	ldr	r0, [pc, #384]	; (800ab38 <main_+0x51c>)
 800a9b6:	e7cf      	b.n	800a958 <main_+0x33c>
  usbp->config = config;
 800a9b8:	4b60      	ldr	r3, [pc, #384]	; (800ab3c <main_+0x520>)
    usbp->epc[i] = NULL;
 800a9ba:	2220      	movs	r2, #32
 800a9bc:	4639      	mov	r1, r7
 800a9be:	f104 000c 	add.w	r0, r4, #12
  usbp->config = config;
 800a9c2:	6063      	str	r3, [r4, #4]
    usbp->epc[i] = NULL;
 800a9c4:	f000 ff22 	bl	800b80c <memset>
  if (usbp->state == USB_STOP) {
 800a9c8:	2e01      	cmp	r6, #1
 800a9ca:	d11b      	bne.n	800aa04 <main_+0x3e8>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a9cc:	21d0      	movs	r1, #208	; 0xd0
      rccEnableUSB(FALSE);
 800a9ce:	4b35      	ldr	r3, [pc, #212]	; (800aaa4 <main_+0x488>)
 800a9d0:	69da      	ldr	r2, [r3, #28]
 800a9d2:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800a9d6:	61da      	str	r2, [r3, #28]
 800a9d8:	4a33      	ldr	r2, [pc, #204]	; (800aaa8 <main_+0x48c>)
      STM32_USB->CNTR = CNTR_FRES;
 800a9da:	f5a3 33da 	sub.w	r3, r3, #111616	; 0x1b400
 800a9de:	641e      	str	r6, [r3, #64]	; 0x40
 800a9e0:	f882 1313 	strb.w	r1, [r2, #787]	; 0x313
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a9e4:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 800a9e8:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a9ec:	6011      	str	r1, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a9ee:	21e0      	movs	r1, #224	; 0xe0
 800a9f0:	f882 1314 	strb.w	r1, [r2, #788]	; 0x314
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a9f4:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 800a9f8:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a9fc:	6011      	str	r1, [r2, #0]
      STM32_USB->CNTR = 0;
 800a9fe:	641f      	str	r7, [r3, #64]	; 0x40
    _usb_reset(usbp);
 800aa00:	f7fb fbb2 	bl	8006168 <_usb_reset.constprop.0>
  usbp->state = USB_READY;
 800aa04:	2702      	movs	r7, #2
  sdup->vmt = &vmt;
 800aa06:	484e      	ldr	r0, [pc, #312]	; (800ab40 <main_+0x524>)
 800aa08:	7027      	strb	r7, [r4, #0]
    osalOsRescheduleS();
 800aa0a:	f7fa f849 	bl	8004aa0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800aa0e:	f7fa f9d9 	bl	8004dc4 <vPortExitCritical>
 800aa12:	4b4c      	ldr	r3, [pc, #304]	; (800ab44 <main_+0x528>)
  sdup->state = SDU_STOP;
 800aa14:	2101      	movs	r1, #1
  sdup->vmt = &vmt;
 800aa16:	6003      	str	r3, [r0, #0]
    event_source->setEvents = 0;
 800aa18:	2300      	movs	r3, #0
  ibqp->bsize     = size + sizeof (size_t);
 800aa1a:	f44f 7c82 	mov.w	ip, #260	; 0x104
  ibqp->brdptr    = bp;
 800aa1e:	f100 0688 	add.w	r6, r0, #136	; 0x88
  ibqp->ptr       = NULL;
 800aa22:	e9c0 630f 	strd	r6, r3, [r0, #60]	; 0x3c
  ibqp->bcounter  = 0;
 800aa26:	6243      	str	r3, [r0, #36]	; 0x24
    event_source->firstRepeater = NULL;
 800aa28:	e9c0 3301 	strd	r3, r3, [r0, #4]
    thread_queue->tail = NULL;
 800aa2c:	e9c0 3306 	strd	r3, r3, [r0, #24]
  ibqp->bwrptr    = bp;
 800aa30:	e9c0 660a 	strd	r6, r6, [r0, #40]	; 0x28
 800aa34:	e9c0 3314 	strd	r3, r3, [r0, #80]	; 0x50
  obqp->top       = NULL;
 800aa38:	e9c0 331e 	strd	r3, r3, [r0, #120]	; 0x78
    event_source->waitThread = NULL;
 800aa3c:	60c3      	str	r3, [r0, #12]
  ibqp->top       = NULL;
 800aa3e:	6443      	str	r3, [r0, #68]	; 0x44
  ibqp->notify    = infy;
 800aa40:	4e41      	ldr	r6, [pc, #260]	; (800ab48 <main_+0x52c>)
  obqp->notify    = onfy;
 800aa42:	4b42      	ldr	r3, [pc, #264]	; (800ab4c <main_+0x530>)
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800aa44:	f500 7224 	add.w	r2, r0, #656	; 0x290
  sdup->state = SDU_STOP;
 800aa48:	7501      	strb	r1, [r0, #20]
  ibqp->suspended = suspended;
 800aa4a:	f880 1020 	strb.w	r1, [r0, #32]
  obqp->suspended = suspended;
 800aa4e:	f880 1058 	strb.w	r1, [r0, #88]	; 0x58
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800aa52:	f500 6193 	add.w	r1, r0, #1176	; 0x498
  ibqp->bn        = n;
 800aa56:	e9c0 c70d 	strd	ip, r7, [r0, #52]	; 0x34
  obqp->bwrptr    = bp;
 800aa5a:	e9c0 2218 	strd	r2, r2, [r0, #96]	; 0x60
  obqp->bsize     = size + sizeof (size_t);
 800aa5e:	e9c0 1c1a 	strd	r1, ip, [r0, #104]	; 0x68
  obqp->buffers   = bp;
 800aa62:	e9c0 721c 	strd	r7, r2, [r0, #112]	; 0x70
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800aa66:	6302      	str	r2, [r0, #48]	; 0x30
  ibqp->link      = link;
 800aa68:	e9c0 6012 	strd	r6, r0, [r0, #72]	; 0x48
  obqp->bcounter  = n;
 800aa6c:	65c7      	str	r7, [r0, #92]	; 0x5c
  obqp->link      = link;
 800aa6e:	e9c0 3020 	strd	r3, r0, [r0, #128]	; 0x80
  osalSysLock();
 800aa72:	f7f9 ff8f 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800aa76:	7d03      	ldrb	r3, [r0, #20]
 800aa78:	3b01      	subs	r3, #1
 800aa7a:	2b01      	cmp	r3, #1
 800aa7c:	d902      	bls.n	800aa84 <main_+0x468>
 800aa7e:	f7f9 ff99 	bl	80049b4 <vTaskEndScheduler>
 800aa82:	e7fe      	b.n	800aa82 <main_+0x466>
  sdup->config = config;
 800aa84:	4b32      	ldr	r3, [pc, #200]	; (800ab50 <main_+0x534>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800aa86:	62e0      	str	r0, [r4, #44]	; 0x2c
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800aa88:	64a0      	str	r0, [r4, #72]	; 0x48
    usbp->in_params[config->int_in - 1U]  = sdup;
 800aa8a:	6320      	str	r0, [r4, #48]	; 0x30
  sdup->config = config;
 800aa8c:	f8c0 3498 	str.w	r3, [r0, #1176]	; 0x498
  sdup->state = SDU_READY;
 800aa90:	7507      	strb	r7, [r0, #20]
    osalOsRescheduleS();
 800aa92:	f7fa f805 	bl	8004aa0 <osalOsRescheduleS.lto_priv.1>
    taskEXIT_CRITICAL();
 800aa96:	f7fa f995 	bl	8004dc4 <vPortExitCritical>
{
    usbStart(&USBD1, &usbcfg);
    sduObjectInit(&SDU1);
    sduStart(&SDU1, &serusbcfg);

    usbConnectBus(serusbcfg.usbp);
 800aa9a:	f44f 6380 	mov.w	r3, #1024	; 0x400
    syslog("USB init done.");
 800aa9e:	482d      	ldr	r0, [pc, #180]	; (800ab54 <main_+0x538>)
 800aaa0:	612b      	str	r3, [r5, #16]
 800aaa2:	e5ff      	b.n	800a6a4 <main_+0x88>
 800aaa4:	40021000 	.word	0x40021000
 800aaa8:	e000e100 	.word	0xe000e100
 800aaac:	2000119c 	.word	0x2000119c
 800aab0:	20001098 	.word	0x20001098
 800aab4:	20001198 	.word	0x20001198
 800aab8:	0800c59b 	.word	0x0800c59b
 800aabc:	0800b6cd 	.word	0x0800b6cd
 800aac0:	0800ca5c 	.word	0x0800ca5c
 800aac4:	200011a0 	.word	0x200011a0
 800aac8:	0800c59f 	.word	0x0800c59f
 800aacc:	08009225 	.word	0x08009225
 800aad0:	20001180 	.word	0x20001180
 800aad4:	0800c5a7 	.word	0x0800c5a7
 800aad8:	0800a289 	.word	0x0800a289
 800aadc:	0800c5ab 	.word	0x0800c5ab
 800aae0:	20001338 	.word	0x20001338
 800aae4:	0800ca7c 	.word	0x0800ca7c
 800aae8:	20000934 	.word	0x20000934
 800aaec:	0800c5d3 	.word	0x0800c5d3
 800aaf0:	20001020 	.word	0x20001020
 800aaf4:	080097b1 	.word	0x080097b1
 800aaf8:	0800c920 	.word	0x0800c920
 800aafc:	0800c616 	.word	0x0800c616
 800ab00:	0800754d 	.word	0x0800754d
 800ab04:	20000914 	.word	0x20000914
 800ab08:	0800c61e 	.word	0x0800c61e
 800ab0c:	2000121c 	.word	0x2000121c
 800ab10:	0800c650 	.word	0x0800c650
 800ab14:	08007f41 	.word	0x08007f41
 800ab18:	200011a4 	.word	0x200011a4
 800ab1c:	20000f54 	.word	0x20000f54
 800ab20:	0800c657 	.word	0x0800c657
 800ab24:	08006581 	.word	0x08006581
 800ab28:	0800c5be 	.word	0x0800c5be
 800ab2c:	0800c5f3 	.word	0x0800c5f3
 800ab30:	080095b1 	.word	0x080095b1
 800ab34:	0800c611 	.word	0x0800c611
 800ab38:	0800c638 	.word	0x0800c638
 800ab3c:	0800cbd0 	.word	0x0800cbd0
 800ab40:	20000a44 	.word	0x20000a44
 800ab44:	0800cd1c 	.word	0x0800cd1c
 800ab48:	0800784d 	.word	0x0800784d
 800ab4c:	08004bc1 	.word	0x08004bc1
 800ab50:	0800cb68 	.word	0x0800cb68
 800ab54:	0800c65f 	.word	0x0800c65f

0800ab58 <cmdI2C>:
    }
    chprintf(chp, SHELL_NEWLINE_STR);
}

void cmdI2C(void* user, BaseSequentialStream *chp, int argc, char *argv[])
{
 800ab58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ab5c:	4606      	mov	r6, r0
 800ab5e:	460c      	mov	r4, r1
 800ab60:	4698      	mov	r8, r3
    I2CDriver* i2c = (I2CDriver*)user;

    if(argc == 0) {
 800ab62:	4615      	mov	r5, r2
{
 800ab64:	b087      	sub	sp, #28
    if(argc == 0) {
 800ab66:	b92a      	cbnz	r2, 800ab74 <cmdI2C+0x1c>
        cmdI2CUsage(chp);
 800ab68:	4620      	mov	r0, r4
        cmdI2CScan(i2c, chp);
    } else {
        cmdI2CUsage(chp);
        return;
    }
}
 800ab6a:	b007      	add	sp, #28
 800ab6c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        cmdI2CUsage(chp);
 800ab70:	f7fd bf38 	b.w	80089e4 <cmdI2CUsage>
    if(!strcmp(argv[0], "test")) {
 800ab74:	681f      	ldr	r7, [r3, #0]
 800ab76:	4966      	ldr	r1, [pc, #408]	; (800ad10 <cmdI2C+0x1b8>)
 800ab78:	4638      	mov	r0, r7
 800ab7a:	f7f9 f821 	bl	8003bc0 <strcmp>
 800ab7e:	b9a0      	cbnz	r0, 800abaa <cmdI2C+0x52>
    i2cAcquireBus(i2c);
 800ab80:	4630      	mov	r0, r6
 800ab82:	f7fa fdd5 	bl	8005730 <i2cAcquireBus>
    i2c_result retVal = i2cSafeRawUnclogBus(i2c);
 800ab86:	4630      	mov	r0, r6
 800ab88:	f7fd fa0e 	bl	8007fa8 <i2cSafeRawUnclogBus>
 800ab8c:	4605      	mov	r5, r0
    i2cReleaseBus(i2c);
 800ab8e:	4630      	mov	r0, r6
 800ab90:	f7fd fd8e 	bl	80086b0 <i2cReleaseBus>
        chprintf(chp, "Verdict: %s"SHELL_NEWLINE_STR, i2cSafeResultToString(i2cSafeTestBus(i2c)));
 800ab94:	4628      	mov	r0, r5
 800ab96:	f7f9 fbdb 	bl	8004350 <i2cSafeResultToString>
 800ab9a:	4602      	mov	r2, r0
 800ab9c:	495d      	ldr	r1, [pc, #372]	; (800ad14 <cmdI2C+0x1bc>)
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800ab9e:	4620      	mov	r0, r4
}
 800aba0:	b007      	add	sp, #28
 800aba2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800aba6:	f7fd bdd2 	b.w	800874e <chprintf>
    if(!strcmp(argv[0], "set")) {
 800abaa:	4638      	mov	r0, r7
 800abac:	495a      	ldr	r1, [pc, #360]	; (800ad18 <cmdI2C+0x1c0>)
 800abae:	f7f9 f807 	bl	8003bc0 <strcmp>
 800abb2:	4681      	mov	r9, r0
 800abb4:	2800      	cmp	r0, #0
 800abb6:	d149      	bne.n	800ac4c <cmdI2C+0xf4>
        if(argc<4) return false;
 800abb8:	2d03      	cmp	r5, #3
 800abba:	dd5b      	ble.n	800ac74 <cmdI2C+0x11c>
        if(argc>4) stress = true;
 800abbc:	3d04      	subs	r5, #4
        regValue = strToInt(argv[3], 16);
 800abbe:	f04f 0110 	mov.w	r1, #16
 800abc2:	f8d8 000c 	ldr.w	r0, [r8, #12]
        if(argc>4) stress = true;
 800abc6:	bf18      	it	ne
 800abc8:	2501      	movne	r5, #1
        regValue = strToInt(argv[3], 16);
 800abca:	f7f9 fb02 	bl	80041d2 <strToInt>
        wantToRead = false;
 800abce:	464f      	mov	r7, r9
        regValue = strToInt(argv[3], 16);
 800abd0:	f88d 0017 	strb.w	r0, [sp, #23]
    uint8_t devAddr = strToInt(argv[1], 16);
 800abd4:	2110      	movs	r1, #16
 800abd6:	f8d8 0004 	ldr.w	r0, [r8, #4]
 800abda:	f7f9 fafa 	bl	80041d2 <strToInt>
 800abde:	fa5f f980 	uxtb.w	r9, r0
    uint8_t regAddr = strToInt(argv[2], 16);
 800abe2:	f8d8 0008 	ldr.w	r0, [r8, #8]
 800abe6:	f7f9 faf4 	bl	80041d2 <strToInt>
    uint32_t stressCnt = 0;
 800abea:	f04f 0a00 	mov.w	sl, #0
    uint8_t regAddr = strToInt(argv[2], 16);
 800abee:	9003      	str	r0, [sp, #12]
 800abf0:	f89d b00c 	ldrb.w	fp, [sp, #12]
        if(wantToRead) {
 800abf4:	b3b7      	cbz	r7, 800ac64 <cmdI2C+0x10c>
            result = i2cSafeReadRegStandard(i2c, devAddr, regAddr, &regValue);
 800abf6:	465a      	mov	r2, fp
 800abf8:	4649      	mov	r1, r9
 800abfa:	4630      	mov	r0, r6
 800abfc:	f10d 0317 	add.w	r3, sp, #23
 800ac00:	f7fe fcaa 	bl	8009558 <i2cSafeReadRegStandard>
            result = i2cSafeWriteRegStandard(i2c, devAddr, regAddr, regValue);
 800ac04:	4680      	mov	r8, r0
        if(result != I2C_BUS_OK) {
 800ac06:	b110      	cbz	r0, 800ac0e <cmdI2C+0xb6>
            regValue = 0;
 800ac08:	2300      	movs	r3, #0
 800ac0a:	f88d 3017 	strb.w	r3, [sp, #23]
        if(stress) {
 800ac0e:	b12d      	cbz	r5, 800ac1c <cmdI2C+0xc4>
            printfFixed(chp, 7, "%u", stressCnt);
 800ac10:	4653      	mov	r3, sl
 800ac12:	2107      	movs	r1, #7
 800ac14:	4620      	mov	r0, r4
 800ac16:	4a41      	ldr	r2, [pc, #260]	; (800ad1c <cmdI2C+0x1c4>)
 800ac18:	f7fd ff46 	bl	8008aa8 <printfFixed>
        chprintf(chp, "Status: %s, address: 0x%02x, register: 0x%02x, value: 0x%02x"SHELL_NEWLINE_STR,
 800ac1c:	4640      	mov	r0, r8
 800ac1e:	f7f9 fb97 	bl	8004350 <i2cSafeResultToString>
 800ac22:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800ac26:	4602      	mov	r2, r0
 800ac28:	9301      	str	r3, [sp, #4]
 800ac2a:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800ac2e:	4620      	mov	r0, r4
 800ac30:	9300      	str	r3, [sp, #0]
 800ac32:	493b      	ldr	r1, [pc, #236]	; (800ad20 <cmdI2C+0x1c8>)
 800ac34:	464b      	mov	r3, r9
 800ac36:	f7fd fd8a 	bl	800874e <chprintf>
        stressCnt++;
 800ac3a:	f10a 0a01 	add.w	sl, sl, #1
    } while (stress && stressCnt <= 100000);
 800ac3e:	b115      	cbz	r5, 800ac46 <cmdI2C+0xee>
 800ac40:	4b38      	ldr	r3, [pc, #224]	; (800ad24 <cmdI2C+0x1cc>)
 800ac42:	459a      	cmp	sl, r3
 800ac44:	d1d6      	bne.n	800abf4 <cmdI2C+0x9c>
}
 800ac46:	b007      	add	sp, #28
 800ac48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if(!strcmp(argv[0], "get")) {
 800ac4c:	4638      	mov	r0, r7
 800ac4e:	4936      	ldr	r1, [pc, #216]	; (800ad28 <cmdI2C+0x1d0>)
 800ac50:	f7f8 ffb6 	bl	8003bc0 <strcmp>
 800ac54:	b970      	cbnz	r0, 800ac74 <cmdI2C+0x11c>
        if(argc<3) return false;
 800ac56:	2d02      	cmp	r5, #2
 800ac58:	dd0c      	ble.n	800ac74 <cmdI2C+0x11c>
        if(argc>3) stress = true;
 800ac5a:	3d03      	subs	r5, #3
 800ac5c:	bf18      	it	ne
 800ac5e:	2501      	movne	r5, #1
        wantToRead = true;
 800ac60:	2701      	movs	r7, #1
 800ac62:	e7b7      	b.n	800abd4 <cmdI2C+0x7c>
            result = i2cSafeWriteRegStandard(i2c, devAddr, regAddr, regValue);
 800ac64:	465a      	mov	r2, fp
 800ac66:	4649      	mov	r1, r9
 800ac68:	4630      	mov	r0, r6
 800ac6a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800ac6e:	f7ff fcb7 	bl	800a5e0 <i2cSafeWriteRegStandard>
 800ac72:	e7c7      	b.n	800ac04 <cmdI2C+0xac>
    } else if(!strcmp(argv[0], "errors")) {
 800ac74:	4638      	mov	r0, r7
 800ac76:	492d      	ldr	r1, [pc, #180]	; (800ad2c <cmdI2C+0x1d4>)
 800ac78:	f7f8 ffa2 	bl	8003bc0 <strcmp>
 800ac7c:	b940      	cbnz	r0, 800ac90 <cmdI2C+0x138>

uint32_t i2cSafeGetNumberOfErrors(I2CDriver* i2c)
{
    osalSysLock();
 800ac7e:	f7f9 fe89 	bl	8004994 <vPortEnterCritical>
    uint32_t result = i2c->i2cErrors;
 800ac82:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
    osalSysUnlock();
 800ac86:	f7fa f8a9 	bl	8004ddc <osalSysUnlock.lto_priv.0>
        chprintf(chp, "I2C Errors: %u"SHELL_NEWLINE_STR, i2cSafeGetNumberOfErrors(i2c));
 800ac8a:	4602      	mov	r2, r0
 800ac8c:	4928      	ldr	r1, [pc, #160]	; (800ad30 <cmdI2C+0x1d8>)
 800ac8e:	e786      	b.n	800ab9e <cmdI2C+0x46>
    } else if(!strcmp(argv[0], "scan")) {
 800ac90:	4638      	mov	r0, r7
 800ac92:	4928      	ldr	r1, [pc, #160]	; (800ad34 <cmdI2C+0x1dc>)
 800ac94:	f7f8 ff94 	bl	8003bc0 <strcmp>
 800ac98:	4605      	mov	r5, r0
 800ac9a:	2800      	cmp	r0, #0
 800ac9c:	f47f af64 	bne.w	800ab68 <cmdI2C+0x10>
    chprintf(chp, "   ");
 800aca0:	4620      	mov	r0, r4
 800aca2:	4925      	ldr	r1, [pc, #148]	; (800ad38 <cmdI2C+0x1e0>)
 800aca4:	f7fd fd53 	bl	800874e <chprintf>
    for(int addr = 0; addr <= 0xF; addr++) {
 800aca8:	462f      	mov	r7, r5
        chprintf(chp, "%1x  ", addr);
 800acaa:	f8df 8090 	ldr.w	r8, [pc, #144]	; 800ad3c <cmdI2C+0x1e4>
 800acae:	463a      	mov	r2, r7
 800acb0:	4641      	mov	r1, r8
 800acb2:	4620      	mov	r0, r4
    for(int addr = 0; addr <= 0xF; addr++) {
 800acb4:	3701      	adds	r7, #1
        chprintf(chp, "%1x  ", addr);
 800acb6:	f7fd fd4a 	bl	800874e <chprintf>
    for(int addr = 0; addr <= 0xF; addr++) {
 800acba:	2f10      	cmp	r7, #16
 800acbc:	d1f7      	bne.n	800acae <cmdI2C+0x156>
            chprintf(chp, SHELL_NEWLINE_STR"%1x ", addr/16);
 800acbe:	4f20      	ldr	r7, [pc, #128]	; (800ad40 <cmdI2C+0x1e8>)
            chprintf(chp, "EE ");
 800acc0:	f8df 8080 	ldr.w	r8, [pc, #128]	; 800ad44 <cmdI2C+0x1ec>
            chprintf(chp, "-- ");
 800acc4:	f8df 9080 	ldr.w	r9, [pc, #128]	; 800ad48 <cmdI2C+0x1f0>
        if(addr % 16 == 0) {
 800acc8:	072b      	lsls	r3, r5, #28
 800acca:	d104      	bne.n	800acd6 <cmdI2C+0x17e>
            chprintf(chp, SHELL_NEWLINE_STR"%1x ", addr/16);
 800accc:	4639      	mov	r1, r7
 800acce:	4620      	mov	r0, r4
 800acd0:	112a      	asrs	r2, r5, #4
 800acd2:	f7fd fd3c 	bl	800874e <chprintf>
        i2c_result result = i2cSafeReadRegStandard(i2c, addr, 0, &regValue);
 800acd6:	2200      	movs	r2, #0
 800acd8:	4630      	mov	r0, r6
 800acda:	f10d 0317 	add.w	r3, sp, #23
 800acde:	b2e9      	uxtb	r1, r5
 800ace0:	f7fe fc3a 	bl	8009558 <i2cSafeReadRegStandard>
        if(result == I2C_BUS_OK) {
 800ace4:	b960      	cbnz	r0, 800ad00 <cmdI2C+0x1a8>
            chprintf(chp, "%02x ", addr);
 800ace6:	462a      	mov	r2, r5
 800ace8:	4620      	mov	r0, r4
 800acea:	4918      	ldr	r1, [pc, #96]	; (800ad4c <cmdI2C+0x1f4>)
 800acec:	f7fd fd2f 	bl	800874e <chprintf>
    for(int addr = 0; addr <= 0x7F; addr++) {
 800acf0:	3501      	adds	r5, #1
 800acf2:	2d80      	cmp	r5, #128	; 0x80
 800acf4:	d1e8      	bne.n	800acc8 <cmdI2C+0x170>
    chprintf(chp, SHELL_NEWLINE_STR);
 800acf6:	4620      	mov	r0, r4
 800acf8:	4915      	ldr	r1, [pc, #84]	; (800ad50 <cmdI2C+0x1f8>)
 800acfa:	f7fd fd28 	bl	800874e <chprintf>
}
 800acfe:	e7a2      	b.n	800ac46 <cmdI2C+0xee>
        } else if(result == I2C_BUS_RESET) {
 800ad00:	3002      	adds	r0, #2
            chprintf(chp, "-- ");
 800ad02:	bf0c      	ite	eq
 800ad04:	4649      	moveq	r1, r9
            chprintf(chp, "EE ");
 800ad06:	4641      	movne	r1, r8
 800ad08:	4620      	mov	r0, r4
 800ad0a:	f7fd fd20 	bl	800874e <chprintf>
 800ad0e:	e7ef      	b.n	800acf0 <cmdI2C+0x198>
 800ad10:	0800c677 	.word	0x0800c677
 800ad14:	0800c67c 	.word	0x0800c67c
 800ad18:	0800c0a7 	.word	0x0800c0a7
 800ad1c:	0800c10d 	.word	0x0800c10d
 800ad20:	0800c68e 	.word	0x0800c68e
 800ad24:	000186a1 	.word	0x000186a1
 800ad28:	0800c68a 	.word	0x0800c68a
 800ad2c:	0800c6cd 	.word	0x0800c6cd
 800ad30:	0800c6d4 	.word	0x0800c6d4
 800ad34:	0800c6e5 	.word	0x0800c6e5
 800ad38:	0800bbcd 	.word	0x0800bbcd
 800ad3c:	0800c6ea 	.word	0x0800c6ea
 800ad40:	0800c6f0 	.word	0x0800c6f0
 800ad44:	0800c701 	.word	0x0800c701
 800ad48:	0800c6fd 	.word	0x0800c6fd
 800ad4c:	0800c6f7 	.word	0x0800c6f7
 800ad50:	0800be60 	.word	0x0800be60

0800ad54 <syslogISRUnknownPriority>:

static bool syslogISRHasSomething;
static char syslogISRBuffer[64];

bool syslogISRUnknownPriority(const char *format, ...)
{
 800ad54:	b40f      	push	{r0, r1, r2, r3}
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad56:	f04f 0201 	mov.w	r2, #1
{
 800ad5a:	b530      	push	{r4, r5, lr}
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad5c:	4b11      	ldr	r3, [pc, #68]	; (800ada4 <syslogISRUnknownPriority+0x50>)
{
 800ad5e:	b087      	sub	sp, #28
    if(__atomic_test_and_set(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800ad60:	e8d3 5f4f 	ldrexb	r5, [r3]
 800ad64:	e8c3 2f41 	strexb	r1, r2, [r3]
 800ad68:	2900      	cmp	r1, #0
 800ad6a:	d1f9      	bne.n	800ad60 <syslogISRUnknownPriority+0xc>
 800ad6c:	b2eb      	uxtb	r3, r5
 800ad6e:	f3bf 8f5b 	dmb	ish
 800ad72:	b9ab      	cbnz	r3, 800ada0 <syslogISRUnknownPriority+0x4c>
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800ad74:	490c      	ldr	r1, [pc, #48]	; (800ada8 <syslogISRUnknownPriority+0x54>)
  msp->buffer = buffer;
 800ad76:	4c0d      	ldr	r4, [pc, #52]	; (800adac <syslogISRUnknownPriority+0x58>)
  msp->vmt    = &vmt;
 800ad78:	9101      	str	r1, [sp, #4]
  msp->size   = size;
 800ad7a:	213f      	movs	r1, #63	; 0x3f
        return false;
    }

    va_list args;
    va_start(args, format);
 800ad7c:	aa0b      	add	r2, sp, #44	; 0x2c
  msp->eos    = eos;
 800ad7e:	e9cd 1303 	strd	r1, r3, [sp, #12]

    MemoryStream ms;
    msObjectInit(&ms, (uint8_t *)syslogISRBuffer, sizeof(syslogISRBuffer)-1, 0);
    BaseSequentialStream *chp = (BaseSequentialStream *)(void *)&ms;

    chvprintf(chp, format, args);
 800ad82:	a801      	add	r0, sp, #4
 800ad84:	990a      	ldr	r1, [sp, #40]	; 0x28
  msp->offset = 0;
 800ad86:	9305      	str	r3, [sp, #20]
    va_start(args, format);
 800ad88:	9200      	str	r2, [sp, #0]
  msp->buffer = buffer;
 800ad8a:	9402      	str	r4, [sp, #8]
    chvprintf(chp, format, args);
 800ad8c:	f7fb feae 	bl	8006aec <chvprintf>
    syslogISRBuffer[ms.eos] = 0;

    va_end(args);

    return true;
 800ad90:	2001      	movs	r0, #1
    syslogISRBuffer[ms.eos] = 0;
 800ad92:	9b04      	ldr	r3, [sp, #16]
 800ad94:	54e5      	strb	r5, [r4, r3]
}
 800ad96:	b007      	add	sp, #28
 800ad98:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800ad9c:	b004      	add	sp, #16
 800ad9e:	4770      	bx	lr
        return false;
 800ada0:	2000      	movs	r0, #0
 800ada2:	e7f8      	b.n	800ad96 <syslogISRUnknownPriority+0x42>
 800ada4:	2000130c 	.word	0x2000130c
 800ada8:	0800cd3c 	.word	0x0800cd3c
 800adac:	200012cc 	.word	0x200012cc

0800adb0 <BusFault_Handler>:
#error "the constant CORTEX_NUM_VECTORS must be between 8 and 240 inclusive"
#endif

extern void unhandledException(void);

void _unhandled_exception(void){
 800adb0:	b508      	push	{r3, lr}
}

void unhandledException(void)
{
    /* Check which vector is active */
    unsigned int vectorId = NVIC_ICSR & 0x1ff;
 800adb2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800adb6:	f8d3 1d04 	ldr.w	r1, [r3, #3332]	; 0xd04

    if(vectorId >= 16) {
 800adba:	f411 7ff8 	tst.w	r1, #496	; 0x1f0
 800adbe:	d013      	beq.n	800ade8 <BusFault_Handler+0x38>
    *pendReg = _BV(vectorId%32);
 800adc0:	2301      	movs	r3, #1
    unsigned int vectorId = NVIC_ICSR & 0x1ff;
 800adc2:	f3c1 0108 	ubfx	r1, r1, #0, #9
        /* This can be masked */
        vectorId -= 16;
 800adc6:	3910      	subs	r1, #16
    *pendReg = _BV(vectorId%32);
 800adc8:	f001 001f 	and.w	r0, r1, #31
 800adcc:	4083      	lsls	r3, r0
 800adce:	4808      	ldr	r0, [pc, #32]	; (800adf0 <BusFault_Handler+0x40>)
    volatile uint32_t* pendReg = (&NVIC_CPR) + (vectorId / 32);
 800add0:	094a      	lsrs	r2, r1, #5
    *pendReg = _BV(vectorId%32);
 800add2:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
        volatile uint32_t* ceReg = (&NVIC_CER) + (vectorId / 32);
 800add6:	f5a0 7080 	sub.w	r0, r0, #256	; 0x100
        *ceReg = _BV(vectorId%32);
 800adda:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
        clearInterrupt(vectorId, true);

        /* Report it */
        syslogISRUnknownPriority("Unhandled vector %u.", vectorId);
 800adde:	4805      	ldr	r0, [pc, #20]	; (800adf4 <BusFault_Handler+0x44>)
	unhandledException();
}
 800ade0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800ade4:	f7ff bfb6 	b.w	800ad54 <syslogISRUnknownPriority>
    } else {
        osalSysHalt("Fault");
 800ade8:	f7f9 fde4 	bl	80049b4 <vTaskEndScheduler>
 800adec:	e7fe      	b.n	800adec <BusFault_Handler+0x3c>
 800adee:	bf00      	nop
 800adf0:	e000e280 	.word	0xe000e280
 800adf4:	0800c705 	.word	0x0800c705

0800adf8 <usb_event>:
{
 800adf8:	b538      	push	{r3, r4, r5, lr}
 800adfa:	4604      	mov	r4, r0
    switch (event) {
 800adfc:	2905      	cmp	r1, #5
 800adfe:	d878      	bhi.n	800aef2 <usb_event+0xfa>
 800ae00:	e8df f001 	tbb	[pc, r1]
 800ae04:	4e08034e 	.word	0x4e08034e
 800ae08:	6a4e      	.short	0x6a4e
            syslogISRUnknownPriority("USB address assigned.");
 800ae0a:	483a      	ldr	r0, [pc, #232]	; (800aef4 <usb_event+0xfc>)
}
 800ae0c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            syslogISRUnknownPriority("USB address assigned.");
 800ae10:	f7ff bfa0 	b.w	800ad54 <syslogISRUnknownPriority>
            osalSysLockFromISR();
 800ae14:	f7fa fd0c 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
            usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 800ae18:	2101      	movs	r1, #1
 800ae1a:	4620      	mov	r0, r4
 800ae1c:	4a36      	ldr	r2, [pc, #216]	; (800aef8 <usb_event+0x100>)
 800ae1e:	f7fc fe87 	bl	8007b30 <usbInitEndpointI>
            usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800ae22:	2102      	movs	r1, #2
 800ae24:	4620      	mov	r0, r4
 800ae26:	4a35      	ldr	r2, [pc, #212]	; (800aefc <usb_event+0x104>)
 800ae28:	f7fc fe82 	bl	8007b30 <usbInitEndpointI>
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800ae2c:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800ae30:	b19b      	cbz	r3, 800ae5a <usb_event+0x62>
  ibqp->bcounter  = 0;
 800ae32:	2500      	movs	r5, #0
 800ae34:	4c32      	ldr	r4, [pc, #200]	; (800af00 <usb_event+0x108>)
  ibqp->brdptr    = ibqp->buffers;
 800ae36:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  ibqp->top       = NULL;
 800ae38:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
  ibqp->bwrptr    = ibqp->buffers;
 800ae3c:	e9c4 330a 	strd	r3, r3, [r4, #40]	; 0x28
  ibqp->bcounter  = 0;
 800ae40:	6265      	str	r5, [r4, #36]	; 0x24
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 800ae42:	f104 0018 	add.w	r0, r4, #24
 800ae46:	f7fc f831 	bl	8006eac <osalThreadDequeueAllI.constprop.0>
  bqResumeX(&sdup->ibqueue);
 800ae4a:	f884 5020 	strb.w	r5, [r4, #32]
	__asm volatile( "mrs %0, basepri" : "=r"( ulBasePri ) );
 800ae4e:	f3ef 8311 	mrs	r3, BASEPRI
	return (ulBasePri > 0)? pdTRUE : pdFALSE;
 800ae52:	b92b      	cbnz	r3, 800ae60 <usb_event+0x68>
  osalDbgCheckClassI();
 800ae54:	f7f9 fdae 	bl	80049b4 <vTaskEndScheduler>
 800ae58:	e7fe      	b.n	800ae58 <usb_event+0x60>
  osalDbgCheckClassI();
 800ae5a:	f7f9 fdab 	bl	80049b4 <vTaskEndScheduler>
 800ae5e:	e7fe      	b.n	800ae5e <usb_event+0x66>
  obqp->bcounter  = bqSizeX(obqp);
 800ae60:	6f23      	ldr	r3, [r4, #112]	; 0x70
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800ae62:	f104 0050 	add.w	r0, r4, #80	; 0x50
  obqp->bcounter  = bqSizeX(obqp);
 800ae66:	65e3      	str	r3, [r4, #92]	; 0x5c
  obqp->brdptr    = obqp->buffers;
 800ae68:	6f63      	ldr	r3, [r4, #116]	; 0x74
  obqp->top       = NULL;
 800ae6a:	e9c4 551e 	strd	r5, r5, [r4, #120]	; 0x78
  obqp->bwrptr    = obqp->buffers;
 800ae6e:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800ae72:	f7fc f81b 	bl	8006eac <osalThreadDequeueAllI.constprop.0>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800ae76:	1d20      	adds	r0, r4, #4
 800ae78:	2101      	movs	r1, #1
  bqResumeX(&sdup->obqueue);
 800ae7a:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800ae7e:	f7fc f829 	bl	8006ed4 <osalEventBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 800ae82:	4620      	mov	r0, r4
        if(!usbConnectState) {
 800ae84:	4c1f      	ldr	r4, [pc, #124]	; (800af04 <usb_event+0x10c>)
 800ae86:	f7fc fcbb 	bl	8007800 <sdu_start_receive.isra.0>
 800ae8a:	7823      	ldrb	r3, [r4, #0]
 800ae8c:	b913      	cbnz	r3, 800ae94 <usb_event+0x9c>
            syslogISRUnknownPriority("USB up.");
 800ae8e:	481e      	ldr	r0, [pc, #120]	; (800af08 <usb_event+0x110>)
 800ae90:	f7ff ff60 	bl	800ad54 <syslogISRUnknownPriority>
    usbConnectState = up;
 800ae94:	2301      	movs	r3, #1
 800ae96:	7023      	strb	r3, [r4, #0]
}
 800ae98:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            osalSysUnlockFromISR();
 800ae9c:	f7fa bcdc 	b.w	8005858 <osalSysUnlockFromISR.lto_priv.0>
  bqSuspendI(&sdup->ibqueue);
 800aea0:	2501      	movs	r5, #1
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 800aea2:	4c17      	ldr	r4, [pc, #92]	; (800af00 <usb_event+0x108>)
            osalSysLockFromISR();
 800aea4:	f7fa fcc4 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 800aea8:	2102      	movs	r1, #2
 800aeaa:	1d20      	adds	r0, r4, #4
 800aeac:	f7fc f812 	bl	8006ed4 <osalEventBroadcastFlagsI>
  bqSuspendI(&sdup->ibqueue);
 800aeb0:	f104 0018 	add.w	r0, r4, #24
 800aeb4:	f884 5020 	strb.w	r5, [r4, #32]
 800aeb8:	f7fb fff8 	bl	8006eac <osalThreadDequeueAllI.constprop.0>
  bqSuspendI(&sdup->obqueue);
 800aebc:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 800aec0:	f104 0050 	add.w	r0, r4, #80	; 0x50
        if(usbConnectState) {
 800aec4:	4c0f      	ldr	r4, [pc, #60]	; (800af04 <usb_event+0x10c>)
 800aec6:	f7fb fff1 	bl	8006eac <osalThreadDequeueAllI.constprop.0>
 800aeca:	7823      	ldrb	r3, [r4, #0]
 800aecc:	b113      	cbz	r3, 800aed4 <usb_event+0xdc>
            syslogISRUnknownPriority("USB down.");
 800aece:	480f      	ldr	r0, [pc, #60]	; (800af0c <usb_event+0x114>)
 800aed0:	f7ff ff40 	bl	800ad54 <syslogISRUnknownPriority>
    usbConnectState = up;
 800aed4:	2300      	movs	r3, #0
 800aed6:	e7de      	b.n	800ae96 <usb_event+0x9e>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800aed8:	4c09      	ldr	r4, [pc, #36]	; (800af00 <usb_event+0x108>)
            osalSysLockFromISR();
 800aeda:	f7fa fca9 	bl	8005830 <osalSysLockFromISR.lto_priv.0>
 800aede:	2101      	movs	r1, #1
 800aee0:	1d20      	adds	r0, r4, #4
 800aee2:	f7fb fff7 	bl	8006ed4 <osalEventBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 800aee6:	2300      	movs	r3, #0
 800aee8:	f884 3020 	strb.w	r3, [r4, #32]
  bqResumeX(&sdup->obqueue);
 800aeec:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
 800aef0:	e7d2      	b.n	800ae98 <usb_event+0xa0>
}
 800aef2:	bd38      	pop	{r3, r4, r5, pc}
 800aef4:	0800c71a 	.word	0x0800c71a
 800aef8:	0800c9d4 	.word	0x0800c9d4
 800aefc:	0800c9f8 	.word	0x0800c9f8
 800af00:	20000a44 	.word	0x20000a44
 800af04:	20001354 	.word	0x20001354
 800af08:	0800c730 	.word	0x0800c730
 800af0c:	0800c738 	.word	0x0800c738

0800af10 <prvIdleTask>:
{
 800af10:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800af12:	4c97      	ldr	r4, [pc, #604]	; (800b170 <prvIdleTask+0x260>)
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800af14:	4d97      	ldr	r5, [pc, #604]	; (800b174 <prvIdleTask+0x264>)
				--uxCurrentNumberOfTasks;
 800af16:	4e98      	ldr	r6, [pc, #608]	; (800b178 <prvIdleTask+0x268>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800af18:	6823      	ldr	r3, [r4, #0]
 800af1a:	2b00      	cmp	r3, #0
 800af1c:	d178      	bne.n	800b010 <prvIdleTask+0x100>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800af1e:	4b97      	ldr	r3, [pc, #604]	; (800b17c <prvIdleTask+0x26c>)
 800af20:	681b      	ldr	r3, [r3, #0]
 800af22:	2b01      	cmp	r3, #1
 800af24:	d91c      	bls.n	800af60 <prvIdleTask+0x50>
				taskYIELD();
 800af26:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800af2a:	4a95      	ldr	r2, [pc, #596]	; (800b180 <prvIdleTask+0x270>)
 800af2c:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800af30:	6011      	str	r1, [r2, #0]
 800af32:	4a94      	ldr	r2, [pc, #592]	; (800b184 <prvIdleTask+0x274>)
 800af34:	6812      	ldr	r2, [r2, #0]
 800af36:	b14a      	cbz	r2, 800af4c <prvIdleTask+0x3c>
 800af38:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800af3c:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800af40:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800af44:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800af48:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800af4c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800af50:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800af54:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800af58:	f3bf 8f4f 	dsb	sy
 800af5c:	f3bf 8f6f 	isb	sy
    /*
     * Some events may happen from IRQs with unknown priority (possibly above kernel),
     * so they are written to a buffer (one entry only) and added to the syslog in
     * the IDLE thread.
     */
    if(__atomic_load_n(&syslogISRHasSomething, __ATOMIC_ACQUIRE)) {
 800af60:	f8df 8224 	ldr.w	r8, [pc, #548]	; 800b188 <prvIdleTask+0x278>
 800af64:	f898 3000 	ldrb.w	r3, [r8]
 800af68:	f3bf 8f5b 	dmb	ish
 800af6c:	b373      	cbz	r3, 800afcc <prvIdleTask+0xbc>
        if(xSemaphoreTake(syslogSemaphore, 0)) {
 800af6e:	f8df 921c 	ldr.w	r9, [pc, #540]	; 800b18c <prvIdleTask+0x27c>
 800af72:	2100      	movs	r1, #0
 800af74:	f8d9 0000 	ldr.w	r0, [r9]
 800af78:	f7fa fa5e 	bl	8005438 <xQueueSemaphoreTake>
 800af7c:	b330      	cbz	r0, 800afcc <prvIdleTask+0xbc>
    queue->pktLen = 0;
 800af7e:	2600      	movs	r6, #0
    queue->lenHeaderStart = queue->writePtr;
 800af80:	4f83      	ldr	r7, [pc, #524]	; (800b190 <prvIdleTask+0x280>)
    packetQueueWriteByte(queue, 0x00);
 800af82:	2000      	movs	r0, #0
    queue->lenHeaderStart = queue->writePtr;
 800af84:	693b      	ldr	r3, [r7, #16]
 800af86:	61fb      	str	r3, [r7, #28]
    packetQueueWriteByte(queue, 0x00);
 800af88:	f7fa fff4 	bl	8005f74 <packetQueueWriteByte.constprop.0>
    packetQueueWriteByte(queue, 0x00);
 800af8c:	2000      	movs	r0, #0
 800af8e:	f7fa fff1 	bl	8005f74 <packetQueueWriteByte.constprop.0>
    queue->pktLen = 0;
 800af92:	61be      	str	r6, [r7, #24]
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800af94:	f7fa ffba 	bl	8005f0c <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800af98:	4b7e      	ldr	r3, [pc, #504]	; (800b194 <prvIdleTask+0x284>)
            packetQueueStartWritePacket(&syslogQueue);
            chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] {ISR} ", osalOsGetSystemTimeX());
            syslogISRBuffer[sizeof(syslogISRBuffer)-1] = 0;
 800af9a:	4f7f      	ldr	r7, [pc, #508]	; (800b198 <prvIdleTask+0x288>)
 800af9c:	681a      	ldr	r2, [r3, #0]
            chprintf((BaseSequentialStream*)&syslogStream, "[%-11u] {ISR} ", osalOsGetSystemTimeX());
 800af9e:	497f      	ldr	r1, [pc, #508]	; (800b19c <prvIdleTask+0x28c>)
 800afa0:	487f      	ldr	r0, [pc, #508]	; (800b1a0 <prvIdleTask+0x290>)
 800afa2:	f7fd fbd4 	bl	800874e <chprintf>
            packetQueuePutBytes(&syslogQueue, (uint8_t*)syslogISRBuffer, strlen(syslogISRBuffer));
 800afa6:	4638      	mov	r0, r7
            syslogISRBuffer[sizeof(syslogISRBuffer)-1] = 0;
 800afa8:	f887 603f 	strb.w	r6, [r7, #63]	; 0x3f
            packetQueuePutBytes(&syslogQueue, (uint8_t*)syslogISRBuffer, strlen(syslogISRBuffer));
 800afac:	f000 fce6 	bl	800b97c <strlen>
 800afb0:	b281      	uxth	r1, r0
 800afb2:	4638      	mov	r0, r7
 800afb4:	f7fb f80c 	bl	8005fd0 <packetQueuePutBytes.constprop.0>
            packetQueueEndWritePacket(&syslogQueue);
 800afb8:	f7fb f830 	bl	800601c <packetQueueEndWritePacket.constprop.0>
            xSemaphoreGive(syslogSemaphore);
 800afbc:	f8d9 0000 	ldr.w	r0, [r9]
 800afc0:	f7fd fa60 	bl	8008484 <xQueueGenericSend.constprop.0>

            __atomic_clear(&syslogISRHasSomething, __ATOMIC_RELEASE);
 800afc4:	f3bf 8f5b 	dmb	ish
 800afc8:	f888 6000 	strb.w	r6, [r8]

void vApplicationIdleHook(void)
{
    syslogIdleHook();

    if(usbConnectState && !usbShellIsUp) {
 800afcc:	4b75      	ldr	r3, [pc, #468]	; (800b1a4 <prvIdleTask+0x294>)
 800afce:	781b      	ldrb	r3, [r3, #0]
 800afd0:	b18b      	cbz	r3, 800aff6 <prvIdleTask+0xe6>
 800afd2:	4e75      	ldr	r6, [pc, #468]	; (800b1a8 <prvIdleTask+0x298>)
 800afd4:	7833      	ldrb	r3, [r6, #0]
 800afd6:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 800afda:	b963      	cbnz	r3, 800aff6 <prvIdleTask+0xe6>
        usbShellIsUp = true;
 800afdc:	2301      	movs	r3, #1
        /*
         * Setting the pin from the idle hook requires a non-blocking
         * GPIO driver. In practice this means almost always a native
         * CPU pin.
         */
        gpioSetPin(GPIO_LED_USB, false);
 800afde:	f240 1003 	movw	r0, #259	; 0x103
        usbShellIsUp = true;
 800afe2:	7033      	strb	r3, [r6, #0]
        gpioSetPin(GPIO_LED_USB, false);
 800afe4:	f7fc faa2 	bl	800752c <gpioSetPin.isra.0>

        /* Try to start the shell */
        if(!shellStart((BaseSequentialStream*)&SDU1, 128, "ShellUSB", usbShellTerminated, NULL)) {
 800afe8:	4a70      	ldr	r2, [pc, #448]	; (800b1ac <prvIdleTask+0x29c>)
 800afea:	4971      	ldr	r1, [pc, #452]	; (800b1b0 <prvIdleTask+0x2a0>)
 800afec:	4871      	ldr	r0, [pc, #452]	; (800b1b4 <prvIdleTask+0x2a4>)
 800afee:	f7fc fea7 	bl	8007d40 <shellStart.constprop.0>
 800aff2:	b900      	cbnz	r0, 800aff6 <prvIdleTask+0xe6>
            /* We are very low on memory. This will keep trying, but priority is IDLE */
            usbShellIsUp = false;
 800aff4:	7030      	strb	r0, [r6, #0]
			xExpectedIdleTime = prvGetExpectedIdleTime();
 800aff6:	f7f9 fb67 	bl	80046c8 <prvGetExpectedIdleTime>
			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 800affa:	2801      	cmp	r0, #1
 800affc:	d98b      	bls.n	800af16 <prvIdleTask+0x6>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 800affe:	4e6e      	ldr	r6, [pc, #440]	; (800b1b8 <prvIdleTask+0x2a8>)
 800b000:	4964      	ldr	r1, [pc, #400]	; (800b194 <prvIdleTask+0x284>)
				vTaskSuspendAll();
 800b002:	f7f9 fb59 	bl	80046b8 <vTaskSuspendAll>
					configASSERT( xNextTaskUnblockTime >= xTickCount );
 800b006:	6832      	ldr	r2, [r6, #0]
 800b008:	680b      	ldr	r3, [r1, #0]
 800b00a:	429a      	cmp	r2, r3
 800b00c:	d213      	bcs.n	800b036 <prvIdleTask+0x126>
 800b00e:	e7fe      	b.n	800b00e <prvIdleTask+0xfe>
			taskENTER_CRITICAL();
 800b010:	f7f9 fcc0 	bl	8004994 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800b014:	68eb      	ldr	r3, [r5, #12]
 800b016:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b018:	1d38      	adds	r0, r7, #4
 800b01a:	f7f9 fb3c 	bl	8004696 <uxListRemove>
				--uxCurrentNumberOfTasks;
 800b01e:	6833      	ldr	r3, [r6, #0]
			prvDeleteTCB( pxTCB );
 800b020:	4638      	mov	r0, r7
				--uxCurrentNumberOfTasks;
 800b022:	3b01      	subs	r3, #1
 800b024:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 800b026:	6823      	ldr	r3, [r4, #0]
 800b028:	3b01      	subs	r3, #1
 800b02a:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 800b02c:	f7f9 feca 	bl	8004dc4 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 800b030:	f7fa f992 	bl	8005358 <prvDeleteTCB>
 800b034:	e770      	b.n	800af18 <prvIdleTask+0x8>
					xExpectedIdleTime = prvGetExpectedIdleTime();
 800b036:	f7f9 fb47 	bl	80046c8 <prvGetExpectedIdleTime>
					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
 800b03a:	2801      	cmp	r0, #1
 800b03c:	d97a      	bls.n	800b134 <prvIdleTask+0x224>
		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 800b03e:	4b5f      	ldr	r3, [pc, #380]	; (800b1bc <prvIdleTask+0x2ac>)
		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
 800b040:	4f5f      	ldr	r7, [pc, #380]	; (800b1c0 <prvIdleTask+0x2b0>)
 800b042:	681b      	ldr	r3, [r3, #0]
		if( ulReloadValue > ulStoppedTimerCompensation )
 800b044:	f8df 817c 	ldr.w	r8, [pc, #380]	; 800b1c4 <prvIdleTask+0x2b4>
 800b048:	4298      	cmp	r0, r3
 800b04a:	bf28      	it	cs
 800b04c:	4618      	movcs	r0, r3
		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
 800b04e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b052:	691a      	ldr	r2, [r3, #16]
 800b054:	f022 0201 	bic.w	r2, r2, #1
 800b058:	611a      	str	r2, [r3, #16]
		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
 800b05a:	699b      	ldr	r3, [r3, #24]
 800b05c:	f8d7 c000 	ldr.w	ip, [r7]
 800b060:	1e42      	subs	r2, r0, #1
 800b062:	fb0c 3902 	mla	r9, ip, r2, r3
		if( ulReloadValue > ulStoppedTimerCompensation )
 800b066:	f8d8 3000 	ldr.w	r3, [r8]
 800b06a:	4599      	cmp	r9, r3
			ulReloadValue -= ulStoppedTimerCompensation;
 800b06c:	bf88      	it	hi
 800b06e:	eba9 0903 	subhi.w	r9, r9, r3
		__asm volatile( "cpsid i" ::: "memory" );
 800b072:	b672      	cpsid	i
		__asm volatile( "dsb" );
 800b074:	f3bf 8f4f 	dsb	sy
		__asm volatile( "isb" );
 800b078:	f3bf 8f6f 	isb	sy
		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
 800b07c:	4b52      	ldr	r3, [pc, #328]	; (800b1c8 <prvIdleTask+0x2b8>)
 800b07e:	681b      	ldr	r3, [r3, #0]
 800b080:	2b00      	cmp	r3, #0
 800b082:	d14b      	bne.n	800b11c <prvIdleTask+0x20c>
		else if( xYieldPending != pdFALSE )
 800b084:	4b51      	ldr	r3, [pc, #324]	; (800b1cc <prvIdleTask+0x2bc>)
 800b086:	681b      	ldr	r3, [r3, #0]
 800b088:	2b00      	cmp	r3, #0
 800b08a:	d147      	bne.n	800b11c <prvIdleTask+0x20c>
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
 800b08c:	f8df c140 	ldr.w	ip, [pc, #320]	; 800b1d0 <prvIdleTask+0x2c0>
 800b090:	f8dc c000 	ldr.w	ip, [ip]
 800b094:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 800b178 <prvIdleTask+0x268>
 800b098:	f8dc c000 	ldr.w	ip, [ip]
			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 800b09c:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
 800b0a0:	f8cc 9014 	str.w	r9, [ip, #20]
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800b0a4:	f8cc 3018 	str.w	r3, [ip, #24]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b0a8:	f8dc 3010 	ldr.w	r3, [ip, #16]
 800b0ac:	f043 0301 	orr.w	r3, r3, #1
 800b0b0:	f8cc 3010 	str.w	r3, [ip, #16]
			if( xModifiableIdleTime > 0 )
 800b0b4:	2800      	cmp	r0, #0
 800b0b6:	d140      	bne.n	800b13a <prvIdleTask+0x22a>
			__asm volatile( "cpsie i" ::: "memory" );
 800b0b8:	b662      	cpsie	i
			__asm volatile( "dsb" );
 800b0ba:	f3bf 8f4f 	dsb	sy
			__asm volatile( "isb" );
 800b0be:	f3bf 8f6f 	isb	sy
			__asm volatile( "cpsid i" ::: "memory" );
 800b0c2:	b672      	cpsid	i
			__asm volatile( "dsb" );
 800b0c4:	f3bf 8f4f 	dsb	sy
			__asm volatile( "isb" );
 800b0c8:	f3bf 8f6f 	isb	sy
			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
 800b0cc:	f04f 2ee0 	mov.w	lr, #3758153728	; 0xe000e000
 800b0d0:	2302      	movs	r3, #2
 800b0d2:	f8ce 3010 	str.w	r3, [lr, #16]
			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 800b0d6:	f8de 3010 	ldr.w	r3, [lr, #16]
 800b0da:	03db      	lsls	r3, r3, #15
 800b0dc:	d533      	bpl.n	800b146 <prvIdleTask+0x236>
				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
 800b0de:	6838      	ldr	r0, [r7, #0]
 800b0e0:	f8de 3018 	ldr.w	r3, [lr, #24]
				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
 800b0e4:	f8d8 c000 	ldr.w	ip, [r8]
				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
 800b0e8:	4403      	add	r3, r0
 800b0ea:	3b01      	subs	r3, #1
 800b0ec:	eba3 0309 	sub.w	r3, r3, r9
				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
 800b0f0:	4563      	cmp	r3, ip
 800b0f2:	d301      	bcc.n	800b0f8 <prvIdleTask+0x1e8>
 800b0f4:	4298      	cmp	r0, r3
 800b0f6:	d200      	bcs.n	800b0fa <prvIdleTask+0x1ea>
					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
 800b0f8:	1e43      	subs	r3, r0, #1
				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
 800b0fa:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
 800b0fe:	6143      	str	r3, [r0, #20]
			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800b100:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b104:	2000      	movs	r0, #0
 800b106:	6198      	str	r0, [r3, #24]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b108:	6918      	ldr	r0, [r3, #16]
 800b10a:	f040 0001 	orr.w	r0, r0, #1
 800b10e:	6118      	str	r0, [r3, #16]
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
 800b110:	6808      	ldr	r0, [r1, #0]
 800b112:	6836      	ldr	r6, [r6, #0]
 800b114:	4410      	add	r0, r2
 800b116:	42b0      	cmp	r0, r6
 800b118:	d925      	bls.n	800b166 <prvIdleTask+0x256>
 800b11a:	e7fe      	b.n	800b11a <prvIdleTask+0x20a>
			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 800b11c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b120:	699a      	ldr	r2, [r3, #24]
 800b122:	615a      	str	r2, [r3, #20]
			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 800b124:	691a      	ldr	r2, [r3, #16]
 800b126:	f042 0201 	orr.w	r2, r2, #1
 800b12a:	611a      	str	r2, [r3, #16]
			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 800b12c:	683a      	ldr	r2, [r7, #0]
 800b12e:	3a01      	subs	r2, #1
 800b130:	615a      	str	r2, [r3, #20]
			__asm volatile( "cpsie i" ::: "memory" );
 800b132:	b662      	cpsie	i
				( void ) xTaskResumeAll();
 800b134:	f7f9 ffe2 	bl	80050fc <xTaskResumeAll>
 800b138:	e6ed      	b.n	800af16 <prvIdleTask+0x6>
				__asm volatile( "dsb" ::: "memory" );
 800b13a:	f3bf 8f4f 	dsb	sy
				__asm volatile( "wfi" );
 800b13e:	bf30      	wfi
				__asm volatile( "isb" );
 800b140:	f3bf 8f6f 	isb	sy
 800b144:	e7b8      	b.n	800b0b8 <prvIdleTask+0x1a8>
				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
 800b146:	683b      	ldr	r3, [r7, #0]
 800b148:	f8de c018 	ldr.w	ip, [lr, #24]
 800b14c:	4358      	muls	r0, r3
 800b14e:	eba0 020c 	sub.w	r2, r0, ip
				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
 800b152:	fbb2 f2f3 	udiv	r2, r2, r3
				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
 800b156:	fb02 3303 	mla	r3, r2, r3, r3
 800b15a:	ebac 0000 	sub.w	r0, ip, r0
 800b15e:	4403      	add	r3, r0
 800b160:	f8ce 3014 	str.w	r3, [lr, #20]
 800b164:	e7cc      	b.n	800b100 <prvIdleTask+0x1f0>
		xTickCount += xTicksToJump;
 800b166:	6808      	ldr	r0, [r1, #0]
 800b168:	4402      	add	r2, r0
 800b16a:	600a      	str	r2, [r1, #0]
 800b16c:	e7de      	b.n	800b12c <prvIdleTask+0x21c>
 800b16e:	bf00      	nop
 800b170:	20001360 	.word	0x20001360
 800b174:	20001634 	.word	0x20001634
 800b178:	2000135c 	.word	0x2000135c
 800b17c:	200011b8 	.word	0x200011b8
 800b180:	2000134c 	.word	0x2000134c
 800b184:	20001358 	.word	0x20001358
 800b188:	2000130c 	.word	0x2000130c
 800b18c:	20001334 	.word	0x20001334
 800b190:	20001310 	.word	0x20001310
 800b194:	20001648 	.word	0x20001648
 800b198:	200012cc 	.word	0x200012cc
 800b19c:	0800c742 	.word	0x0800c742
 800b1a0:	0800cbbc 	.word	0x0800cbbc
 800b1a4:	20001354 	.word	0x20001354
 800b1a8:	20001355 	.word	0x20001355
 800b1ac:	08007721 	.word	0x08007721
 800b1b0:	0800c751 	.word	0x0800c751
 800b1b4:	20000a44 	.word	0x20000a44
 800b1b8:	200015f8 	.word	0x200015f8
 800b1bc:	200015f0 	.word	0x200015f0
 800b1c0:	20001350 	.word	0x20001350
 800b1c4:	20001348 	.word	0x20001348
 800b1c8:	20001600 	.word	0x20001600
 800b1cc:	2000164c 	.word	0x2000164c
 800b1d0:	20001620 	.word	0x20001620

0800b1d4 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800b1d4:	4770      	bx	lr

0800b1d6 <__late_init>:
 800b1d6:	4770      	bx	lr

0800b1d8 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 800b1d8:	e7fe      	b.n	800b1d8 <__default_exit>
	...

0800b1dc <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800b1dc:	b570      	push	{r4, r5, r6, lr}
 800b1de:	2508      	movs	r5, #8
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800b1e0:	4c13      	ldr	r4, [pc, #76]	; (800b230 <__init_ram_areas+0x54>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800b1e2:	e9d4 0201 	ldrd	r0, r2, [r4, #4]
    uint32_t *p = rap->init_area;
 800b1e6:	4601      	mov	r1, r0
 800b1e8:	6823      	ldr	r3, [r4, #0]
 800b1ea:	3b04      	subs	r3, #4
    while (p < rap->clear_area) {
 800b1ec:	428a      	cmp	r2, r1
 800b1ee:	d819      	bhi.n	800b224 <__init_ram_areas+0x48>
 800b1f0:	1cd3      	adds	r3, r2, #3
 800b1f2:	1a1b      	subs	r3, r3, r0
 800b1f4:	1ec1      	subs	r1, r0, #3
 800b1f6:	f023 0303 	bic.w	r3, r3, #3
 800b1fa:	428a      	cmp	r2, r1
 800b1fc:	bf38      	it	cc
 800b1fe:	2300      	movcc	r3, #0
 800b200:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800b202:	68e3      	ldr	r3, [r4, #12]
 800b204:	1ec1      	subs	r1, r0, #3
 800b206:	1cda      	adds	r2, r3, #3
 800b208:	1a12      	subs	r2, r2, r0
 800b20a:	f022 0203 	bic.w	r2, r2, #3
 800b20e:	4299      	cmp	r1, r3
 800b210:	bf88      	it	hi
 800b212:	2200      	movhi	r2, #0
 800b214:	2100      	movs	r1, #0
 800b216:	f000 faf9 	bl	800b80c <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b21a:	3d01      	subs	r5, #1
    rap++;
 800b21c:	f104 0410 	add.w	r4, r4, #16
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b220:	d1df      	bne.n	800b1e2 <__init_ram_areas+0x6>
#endif
}
 800b222:	bd70      	pop	{r4, r5, r6, pc}
      *p = *tp;
 800b224:	f853 6f04 	ldr.w	r6, [r3, #4]!
 800b228:	f841 6b04 	str.w	r6, [r1], #4
      tp++;
 800b22c:	e7de      	b.n	800b1ec <__init_ram_areas+0x10>
 800b22e:	bf00      	nop
 800b230:	0800cae8 	.word	0x0800cae8

0800b234 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800b234:	4b1c      	ldr	r3, [pc, #112]	; (800b2a8 <__early_init+0x74>)
 800b236:	681a      	ldr	r2, [r3, #0]
 800b238:	f042 0201 	orr.w	r2, r2, #1
 800b23c:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800b23e:	681a      	ldr	r2, [r3, #0]
 800b240:	0792      	lsls	r2, r2, #30
 800b242:	d5fc      	bpl.n	800b23e <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800b244:	681a      	ldr	r2, [r3, #0]
 800b246:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800b24a:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800b24c:	2200      	movs	r2, #0
 800b24e:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800b250:	685a      	ldr	r2, [r3, #4]
 800b252:	f012 0f0c 	tst.w	r2, #12
 800b256:	d1fb      	bne.n	800b250 <__early_init+0x1c>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 800b258:	681a      	ldr	r2, [r3, #0]
 800b25a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b25e:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 800b260:	681a      	ldr	r2, [r3, #0]
 800b262:	0390      	lsls	r0, r2, #14
 800b264:	d5fc      	bpl.n	800b260 <__early_init+0x2c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800b266:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b268:	f042 0201 	orr.w	r2, r2, #1
 800b26c:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800b26e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b270:	0791      	lsls	r1, r2, #30
 800b272:	d5fc      	bpl.n	800b26e <__early_init+0x3a>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 800b274:	685a      	ldr	r2, [r3, #4]
 800b276:	f442 12f8 	orr.w	r2, r2, #2031616	; 0x1f0000
 800b27a:	605a      	str	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
 800b27c:	681a      	ldr	r2, [r3, #0]
 800b27e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b282:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800b284:	681a      	ldr	r2, [r3, #0]
 800b286:	0192      	lsls	r2, r2, #6
 800b288:	d5fc      	bpl.n	800b284 <__early_init+0x50>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800b28a:	2112      	movs	r1, #18
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800b28c:	4a07      	ldr	r2, [pc, #28]	; (800b2ac <__early_init+0x78>)
 800b28e:	605a      	str	r2, [r3, #4]
  FLASH->ACR = STM32_FLASHBITS;
 800b290:	4a07      	ldr	r2, [pc, #28]	; (800b2b0 <__early_init+0x7c>)
 800b292:	6011      	str	r1, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800b294:	685a      	ldr	r2, [r3, #4]
 800b296:	f042 0202 	orr.w	r2, r2, #2
 800b29a:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800b29c:	685a      	ldr	r2, [r3, #4]
 800b29e:	f002 020c 	and.w	r2, r2, #12
 800b2a2:	2a08      	cmp	r2, #8
 800b2a4:	d1fa      	bne.n	800b29c <__early_init+0x68>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 800b2a6:	4770      	bx	lr
 800b2a8:	40021000 	.word	0x40021000
 800b2ac:	001f6400 	.word	0x001f6400
 800b2b0:	40022000 	.word	0x40022000

0800b2b4 <main>:
  rccResetAPB1(0xFFFFFFFF);
 800b2b4:	4bb5      	ldr	r3, [pc, #724]	; (800b58c <main+0x2d8>)
 800b2b6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b2ba:	691a      	ldr	r2, [r3, #16]
 800b2bc:	2200      	movs	r2, #0
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b2be:	4614      	mov	r4, r2
/*
 * This main function starts FreeRTOS, we also create one thread that
 * will eventually run main_.
 */
int main(void)
{
 800b2c0:	b580      	push	{r7, lr}
 800b2c2:	6119      	str	r1, [r3, #16]
 800b2c4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800b2c6:	68d8      	ldr	r0, [r3, #12]
 800b2c8:	60d9      	str	r1, [r3, #12]
 800b2ca:	60da      	str	r2, [r3, #12]
  rccEnablePWRInterface(FALSE);
 800b2cc:	69d9      	ldr	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 800b2ce:	48b0      	ldr	r0, [pc, #704]	; (800b590 <main+0x2dc>)
  rccEnablePWRInterface(FALSE);
 800b2d0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800b2d4:	61d9      	str	r1, [r3, #28]
  rccEnableBKPInterface(FALSE);
 800b2d6:	69d9      	ldr	r1, [r3, #28]
 800b2d8:	b08a      	sub	sp, #40	; 0x28
 800b2da:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 800b2de:	61d9      	str	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 800b2e0:	6801      	ldr	r1, [r0, #0]
 800b2e2:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800b2e6:	6001      	str	r1, [r0, #0]
  dma_streams_mask = 0U;
 800b2e8:	49aa      	ldr	r1, [pc, #680]	; (800b594 <main+0x2e0>)
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800b2ea:	48ab      	ldr	r0, [pc, #684]	; (800b598 <main+0x2e4>)
  dma_streams_mask = 0U;
 800b2ec:	600a      	str	r2, [r1, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b2ee:	49ab      	ldr	r1, [pc, #684]	; (800b59c <main+0x2e8>)
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b2f0:	684d      	ldr	r5, [r1, #4]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b2f2:	3114      	adds	r1, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 800b2f4:	602c      	str	r4, [r5, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 800b2f6:	f840 4032 	str.w	r4, [r0, r2, lsl #3]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800b2fa:	3201      	adds	r2, #1
 800b2fc:	2a07      	cmp	r2, #7
 800b2fe:	d1f7      	bne.n	800b2f0 <main+0x3c>
  DMA1->IFCR = 0xFFFFFFFFU;
 800b300:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800b304:	49a6      	ldr	r1, [pc, #664]	; (800b5a0 <main+0x2ec>)
  i2cp->state  = I2C_STOP;
 800b306:	2601      	movs	r6, #1
 800b308:	604a      	str	r2, [r1, #4]
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800b30a:	6999      	ldr	r1, [r3, #24]
 800b30c:	4da5      	ldr	r5, [pc, #660]	; (800b5a4 <main+0x2f0>)
 800b30e:	f041 017d 	orr.w	r1, r1, #125	; 0x7d
 800b312:	6199      	str	r1, [r3, #24]
  GPIOA->ODR = config->PAData.odr;
 800b314:	f46f 1340 	mvn.w	r3, #3145728	; 0x300000
 800b318:	49a3      	ldr	r1, [pc, #652]	; (800b5a8 <main+0x2f4>)
 800b31a:	60cb      	str	r3, [r1, #12]
  GPIOA->CRH = config->PAData.crh;
 800b31c:	4ba3      	ldr	r3, [pc, #652]	; (800b5ac <main+0x2f8>)
 800b31e:	604b      	str	r3, [r1, #4]
  GPIOA->CRL = config->PAData.crl;
 800b320:	f04f 3388 	mov.w	r3, #2290649224	; 0x88888888
 800b324:	600b      	str	r3, [r1, #0]
  GPIOB->ODR = config->PBData.odr;
 800b326:	f8c1 240c 	str.w	r2, [r1, #1036]	; 0x40c
  GPIOB->CRH = config->PBData.crh;
 800b32a:	f8c1 3404 	str.w	r3, [r1, #1028]	; 0x404
  GPIOB->CRL = config->PBData.crl;
 800b32e:	f8c1 3400 	str.w	r3, [r1, #1024]	; 0x400
  GPIOC->ODR = config->PCData.odr;
 800b332:	f8c1 280c 	str.w	r2, [r1, #2060]	; 0x80c
  GPIOC->CRH = config->PCData.crh;
 800b336:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
  GPIOC->CRL = config->PCData.crl;
 800b33a:	f8c1 3800 	str.w	r3, [r1, #2048]	; 0x800
  GPIOD->ODR = config->PDData.odr;
 800b33e:	f8c1 2c0c 	str.w	r2, [r1, #3084]	; 0xc0c
  GPIOD->CRH = config->PDData.crh;
 800b342:	f8c1 3c04 	str.w	r3, [r1, #3076]	; 0xc04
  GPIOD->CRL = config->PDData.crl;
 800b346:	f8c1 3c00 	str.w	r3, [r1, #3072]	; 0xc00
  GPIOB->ODR = config->PBData.odr;
 800b34a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
  GPIOE->ODR = config->PEData.odr;
 800b34e:	f8c1 2c0c 	str.w	r2, [r1, #3084]	; 0xc0c
  GPIOE->CRH = config->PEData.crh;
 800b352:	f8c1 3c04 	str.w	r3, [r1, #3076]	; 0xc04
  GPIOE->CRL = config->PEData.crl;
 800b356:	f8c1 3c00 	str.w	r3, [r1, #3072]	; 0xc00
			volatile size_t xSize = sizeof( StaticQueue_t );
 800b35a:	2350      	movs	r3, #80	; 0x50
 800b35c:	9306      	str	r3, [sp, #24]
			configASSERT( xSize == sizeof( Queue_t ) );
 800b35e:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800b362:	702e      	strb	r6, [r5, #0]
 800b364:	4598      	cmp	r8, r3
  i2cp->config = NULL;
 800b366:	606c      	str	r4, [r5, #4]
 800b368:	d000      	beq.n	800b36c <main+0xb8>
 800b36a:	e7fe      	b.n	800b36a <main+0xb6>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b36c:	f105 0710 	add.w	r7, r5, #16
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b370:	4638      	mov	r0, r7
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b372:	612f      	str	r7, [r5, #16]
	pxNewQueue->uxItemSize = uxItemSize;
 800b374:	e9c5 6413 	strd	r6, r4, [r5, #76]	; 0x4c
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800b378:	f885 6056 	strb.w	r6, [r5, #86]	; 0x56
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b37c:	f7fd f9bd 	bl	80086fa <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800b380:	f885 605c 	strb.w	r6, [r5, #92]	; 0x5c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800b384:	f7fd f9b3 	bl	80086ee <prvInitialiseMutex.part.0>
  oqp->q_counter = size;
 800b388:	2110      	movs	r1, #16
    mutex->handle = xSemaphoreCreateMutexStatic(&mutex->staticData);
 800b38a:	60ef      	str	r7, [r5, #12]
  I2CD1.i2c    = I2C1;
 800b38c:	4b88      	ldr	r3, [pc, #544]	; (800b5b0 <main+0x2fc>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800b38e:	4f89      	ldr	r7, [pc, #548]	; (800b5b4 <main+0x300>)
  I2CD1.i2c    = I2C1;
 800b390:	67ab      	str	r3, [r5, #120]	; 0x78
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800b392:	f1a7 0314 	sub.w	r3, r7, #20
 800b396:	676b      	str	r3, [r5, #116]	; 0x74
  sdp->vmt = &vmt;
 800b398:	4a87      	ldr	r2, [pc, #540]	; (800b5b8 <main+0x304>)
 800b39a:	4b88      	ldr	r3, [pc, #544]	; (800b5bc <main+0x308>)
  I2CD1.thread = NULL;
 800b39c:	662c      	str	r4, [r5, #96]	; 0x60
 800b39e:	601a      	str	r2, [r3, #0]
  iqp->q_buffer  = bp;
 800b3a0:	f103 0260 	add.w	r2, r3, #96	; 0x60
  iqp->q_wrptr   = bp;
 800b3a4:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  iqp->q_buffer  = bp;
 800b3a8:	625a      	str	r2, [r3, #36]	; 0x24
  iqp->q_top     = bp + size;
 800b3aa:	f103 0270 	add.w	r2, r3, #112	; 0x70
  oqp->q_wrptr   = bp;
 800b3ae:	e9c3 2214 	strd	r2, r2, [r3, #80]	; 0x50
  iqp->q_top     = bp + size;
 800b3b2:	629a      	str	r2, [r3, #40]	; 0x28
  oqp->q_buffer  = bp;
 800b3b4:	649a      	str	r2, [r3, #72]	; 0x48
  oqp->q_top     = bp + size;
 800b3b6:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800b3ba:	64da      	str	r2, [r3, #76]	; 0x4c
  oqp->q_notify  = onfy;
 800b3bc:	4a80      	ldr	r2, [pc, #512]	; (800b5c0 <main+0x30c>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 800b3be:	672f      	str	r7, [r5, #112]	; 0x70
  oqp->q_link    = link;
 800b3c0:	e9c3 2316 	strd	r2, r3, [r3, #88]	; 0x58
  spip->state = SPI_STOP;
 800b3c4:	4d7f      	ldr	r5, [pc, #508]	; (800b5c4 <main+0x310>)
  SD3.usart = USART3;
 800b3c6:	4a80      	ldr	r2, [pc, #512]	; (800b5c8 <main+0x314>)
  iqp->q_counter = 0;
 800b3c8:	621c      	str	r4, [r3, #32]
    event_source->firstRepeater = NULL;
 800b3ca:	e9c3 4401 	strd	r4, r4, [r3, #4]
    thread_queue->tail = NULL;
 800b3ce:	e9c3 4406 	strd	r4, r4, [r3, #24]
  iqp->q_link    = link;
 800b3d2:	e9c3 430d 	strd	r4, r3, [r3, #52]	; 0x34
 800b3d6:	e9c3 440f 	strd	r4, r4, [r3, #60]	; 0x3c
    event_source->waitThread = NULL;
 800b3da:	60dc      	str	r4, [r3, #12]
  sdp->state = SD_STOP;
 800b3dc:	751e      	strb	r6, [r3, #20]
  oqp->q_counter = size;
 800b3de:	6459      	str	r1, [r3, #68]	; 0x44
 800b3e0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  spip->thread = NULL;
 800b3e4:	e9c5 4401 	strd	r4, r4, [r5, #4]
  spip->state = SPI_STOP;
 800b3e8:	702e      	strb	r6, [r5, #0]
			volatile size_t xSize = sizeof( StaticQueue_t );
 800b3ea:	f8cd 801c 	str.w	r8, [sp, #28]
			configASSERT( xSize == sizeof( Queue_t ) );
 800b3ee:	9b07      	ldr	r3, [sp, #28]
 800b3f0:	2b50      	cmp	r3, #80	; 0x50
 800b3f2:	d000      	beq.n	800b3f6 <main+0x142>
 800b3f4:	e7fe      	b.n	800b3f4 <main+0x140>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b3f6:	f105 0810 	add.w	r8, r5, #16
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b3fa:	4640      	mov	r0, r8
	pxNewQueue->uxItemSize = uxItemSize;
 800b3fc:	e9c5 6413 	strd	r6, r4, [r5, #76]	; 0x4c
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800b400:	f885 6056 	strb.w	r6, [r5, #86]	; 0x56
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b404:	f8c5 8010 	str.w	r8, [r5, #16]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b408:	f7fd f977 	bl	80086fa <xQueueGenericReset.constprop.0.isra.0>
		pxNewQueue->ucQueueType = ucQueueType;
 800b40c:	f885 605c 	strb.w	r6, [r5, #92]	; 0x5c
	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 800b410:	f7fd f96d 	bl	80086ee <prvInitialiseMutex.part.0>
  SPID1.spi       = SPI1;
 800b414:	4b6d      	ldr	r3, [pc, #436]	; (800b5cc <main+0x318>)
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b416:	f241 000a 	movw	r0, #4106	; 0x100a
  SPID1.spi       = SPI1;
 800b41a:	662b      	str	r3, [r5, #96]	; 0x60
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 800b41c:	f1a7 0364 	sub.w	r3, r7, #100	; 0x64
 800b420:	666b      	str	r3, [r5, #100]	; 0x64
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b422:	f241 0318 	movw	r3, #4120	; 0x1018
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800b426:	3f50      	subs	r7, #80	; 0x50
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800b428:	e9c5 031b 	strd	r0, r3, [r5, #108]	; 0x6c
    mutex->handle = xSemaphoreCreateMutexStatic(&mutex->staticData);
 800b42c:	f8c5 800c 	str.w	r8, [r5, #12]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800b430:	66af      	str	r7, [r5, #104]	; 0x68
  usbp->state        = USB_STOP;
 800b432:	4d67      	ldr	r5, [pc, #412]	; (800b5d0 <main+0x31c>)
    usbp->in_params[i]  = NULL;
 800b434:	2238      	movs	r2, #56	; 0x38
  usbp->state        = USB_STOP;
 800b436:	4628      	mov	r0, r5
    usbp->in_params[i]  = NULL;
 800b438:	2100      	movs	r1, #0
  usbp->state        = USB_STOP;
 800b43a:	f800 6b2c 	strb.w	r6, [r0], #44
    usbp->in_params[i]  = NULL;
 800b43e:	f000 f9e5 	bl	800b80c <memset>
/*
 * Board-specific initialization code.
 */
void boardInit(void) {
    /* Use SWD only */
    AFIO->MAPR = AFIO_MAPR_SWJ_CFG_JTAGDISABLE;
 800b442:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  WDGD1.state = WDG_STOP;
 800b446:	4863      	ldr	r0, [pc, #396]	; (800b5d4 <main+0x320>)
  WDGD1.wdg   = IWDG;
 800b448:	4b63      	ldr	r3, [pc, #396]	; (800b5d8 <main+0x324>)
  usbp->transmitting = 0;
 800b44a:	e9c5 4401 	strd	r4, r4, [r5, #4]
 800b44e:	6083      	str	r3, [r0, #8]
 800b450:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
  WDGD1.state = WDG_STOP;
 800b454:	7006      	strb	r6, [r0, #0]
 800b456:	605a      	str	r2, [r3, #4]
  osalSysLock();
 800b458:	f7f9 fa9c 	bl	8004994 <vPortEnterCritical>
  osalDbgAssert((wdgp->state == WDG_STOP) || (wdgp->state == WDG_READY),
 800b45c:	7803      	ldrb	r3, [r0, #0]
 800b45e:	3b01      	subs	r3, #1
 800b460:	2b01      	cmp	r3, #1
 800b462:	d902      	bls.n	800b46a <main+0x1b6>
 800b464:	f7f9 faa6 	bl	80049b4 <vTaskEndScheduler>
 800b468:	e7fe      	b.n	800b468 <main+0x1b4>
  wdgp->wdg->KR   = KR_KEY_WRITE;
 800b46a:	f245 5255 	movw	r2, #21845	; 0x5555
  wdgp->config = config;
 800b46e:	4b5b      	ldr	r3, [pc, #364]	; (800b5dc <main+0x328>)
 800b470:	6043      	str	r3, [r0, #4]
 800b472:	6883      	ldr	r3, [r0, #8]
 800b474:	601a      	str	r2, [r3, #0]
  while (wdgp->wdg->SR != 0)
 800b476:	68dc      	ldr	r4, [r3, #12]
 800b478:	2c00      	cmp	r4, #0
 800b47a:	d1fc      	bne.n	800b476 <main+0x1c2>
  wdgp->wdg->PR   = wdgp->config->pr;
 800b47c:	2206      	movs	r2, #6
 800b47e:	605a      	str	r2, [r3, #4]
  wdgp->wdg->RLR  = wdgp->config->rlr;
 800b480:	f640 72ff 	movw	r2, #4095	; 0xfff
 800b484:	609a      	str	r2, [r3, #8]
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 800b486:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800b48a:	601a      	str	r2, [r3, #0]
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 800b48c:	f64c 42cc 	movw	r2, #52428	; 0xcccc
  wdgp->state = WDG_READY;
 800b490:	2702      	movs	r7, #2

    /* Before anything else, start watchdog (~25 seconds timeout) */
    wdgStart(&WDGD1, &watchdogConfig);

    TaskHandle_t handle;
    xTaskCreate(runInThreadBody, "Init", 256, main_, 1, &handle);
 800b492:	2601      	movs	r6, #1
 800b494:	601a      	str	r2, [r3, #0]
 800b496:	7007      	strb	r7, [r0, #0]
  osalSysUnlock();
 800b498:	f7f9 fca0 	bl	8004ddc <osalSysUnlock.lto_priv.0>
 800b49c:	ab05      	add	r3, sp, #20
 800b49e:	9301      	str	r3, [sp, #4]
 800b4a0:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b4a4:	4b4e      	ldr	r3, [pc, #312]	; (800b5e0 <main+0x32c>)
 800b4a6:	494f      	ldr	r1, [pc, #316]	; (800b5e4 <main+0x330>)
 800b4a8:	484f      	ldr	r0, [pc, #316]	; (800b5e8 <main+0x334>)
 800b4aa:	9600      	str	r6, [sp, #0]
 800b4ac:	f7fc fc18 	bl	8007ce0 <xTaskCreate.isra.0>
			volatile size_t xSize = sizeof( StaticTask_t );
 800b4b0:	2368      	movs	r3, #104	; 0x68
 800b4b2:	9308      	str	r3, [sp, #32]
			configASSERT( xSize == sizeof( TCB_t ) );
 800b4b4:	9b08      	ldr	r3, [sp, #32]
 800b4b6:	2b68      	cmp	r3, #104	; 0x68
 800b4b8:	d000      	beq.n	800b4bc <main+0x208>
 800b4ba:	e7fe      	b.n	800b4ba <main+0x206>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b4bc:	4d4b      	ldr	r5, [pc, #300]	; (800b5ec <main+0x338>)
 800b4be:	4b4c      	ldr	r3, [pc, #304]	; (800b5f0 <main+0x33c>)
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b4c0:	f885 7065 	strb.w	r7, [r5, #101]	; 0x65
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b4c4:	632b      	str	r3, [r5, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800b4c6:	ab09      	add	r3, sp, #36	; 0x24
 800b4c8:	2278      	movs	r2, #120	; 0x78
 800b4ca:	e9cd 4300 	strd	r4, r3, [sp]
 800b4ce:	4949      	ldr	r1, [pc, #292]	; (800b5f4 <main+0x340>)
 800b4d0:	4623      	mov	r3, r4
 800b4d2:	4849      	ldr	r0, [pc, #292]	; (800b5f8 <main+0x344>)
 800b4d4:	9502      	str	r5, [sp, #8]
 800b4d6:	f7fc fbb5 	bl	8007c44 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800b4da:	4628      	mov	r0, r5
 800b4dc:	f7f9 fd5a 	bl	8004f94 <prvAddNewTaskToReadyList>
		return xReturn;
 800b4e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
		if( xIdleTaskHandle != NULL )
 800b4e2:	2b00      	cmp	r3, #0
 800b4e4:	f000 80a7 	beq.w	800b636 <main+0x382>
		portDISABLE_INTERRUPTS();
 800b4e8:	f7f9 fa54 	bl	8004994 <vPortEnterCritical>
		xNextTaskUnblockTime = portMAX_DELAY;
 800b4ec:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800b4f0:	4b42      	ldr	r3, [pc, #264]	; (800b5fc <main+0x348>)
 800b4f2:	6019      	str	r1, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800b4f4:	4b42      	ldr	r3, [pc, #264]	; (800b600 <main+0x34c>)
 800b4f6:	601e      	str	r6, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 800b4f8:	4b42      	ldr	r3, [pc, #264]	; (800b604 <main+0x350>)
 800b4fa:	601c      	str	r4, [r3, #0]
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800b4fc:	4b42      	ldr	r3, [pc, #264]	; (800b608 <main+0x354>)
 800b4fe:	781a      	ldrb	r2, [r3, #0]
 800b500:	b2d2      	uxtb	r2, r2
 800b502:	9209      	str	r2, [sp, #36]	; 0x24
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800b504:	7019      	strb	r1, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800b506:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800b508:	4a40      	ldr	r2, [pc, #256]	; (800b60c <main+0x358>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800b50a:	b2db      	uxtb	r3, r3
 800b50c:	f88d 3013 	strb.w	r3, [sp, #19]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800b510:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800b514:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
 800b518:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800b51a:	2307      	movs	r3, #7
 800b51c:	4a3c      	ldr	r2, [pc, #240]	; (800b610 <main+0x35c>)
 800b51e:	6013      	str	r3, [r2, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800b520:	f89d 1013 	ldrb.w	r1, [sp, #19]
 800b524:	1e58      	subs	r0, r3, #1
 800b526:	0609      	lsls	r1, r1, #24
 800b528:	d47c      	bmi.n	800b624 <main+0x370>
 800b52a:	b104      	cbz	r4, 800b52e <main+0x27a>
 800b52c:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800b52e:	6813      	ldr	r3, [r2, #0]
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 800b530:	f242 3128 	movw	r1, #9000	; 0x2328
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800b534:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800b536:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800b53a:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800b53c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b53e:	4a32      	ldr	r2, [pc, #200]	; (800b608 <main+0x354>)
 800b540:	b2db      	uxtb	r3, r3
 800b542:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800b544:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b548:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b54c:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 800b550:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800b554:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b558:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 800b55c:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
		ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 800b560:	4a2c      	ldr	r2, [pc, #176]	; (800b614 <main+0x360>)
 800b562:	6011      	str	r1, [r2, #0]
		xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 800b564:	f44f 61e9 	mov.w	r1, #1864	; 0x748
 800b568:	4a2b      	ldr	r2, [pc, #172]	; (800b618 <main+0x364>)
 800b56a:	6011      	str	r1, [r2, #0]
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 800b56c:	2105      	movs	r1, #5
 800b56e:	4a2b      	ldr	r2, [pc, #172]	; (800b61c <main+0x368>)
 800b570:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800b572:	f242 3227 	movw	r2, #8999	; 0x2327
 800b576:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800b578:	2203      	movs	r2, #3
 800b57a:	611a      	str	r2, [r3, #16]
	uxCriticalNesting = 0;
 800b57c:	2200      	movs	r2, #0
 800b57e:	4b28      	ldr	r3, [pc, #160]	; (800b620 <main+0x36c>)
 800b580:	601a      	str	r2, [r3, #0]
	prvPortStartFirstTask();
 800b582:	f7f9 f9f7 	bl	8004974 <prvPortStartFirstTask>
	prvTaskExitError();
 800b586:	f7f9 fc11 	bl	8004dac <prvTaskExitError>
 800b58a:	bf00      	nop
 800b58c:	40021000 	.word	0x40021000
 800b590:	40007000 	.word	0x40007000
 800b594:	20001044 	.word	0x20001044
 800b598:	20000fe8 	.word	0x20000fe8
 800b59c:	0800c854 	.word	0x0800c854
 800b5a0:	40020000 	.word	0x40020000
 800b5a4:	20000934 	.word	0x20000934
 800b5a8:	40010800 	.word	0x40010800
 800b5ac:	88888288 	.word	0x88888288
 800b5b0:	40005400 	.word	0x40005400
 800b5b4:	0800c8cc 	.word	0x0800c8cc
 800b5b8:	0800ccfc 	.word	0x0800ccfc
 800b5bc:	200009bc 	.word	0x200009bc
 800b5c0:	08004151 	.word	0x08004151
 800b5c4:	20000ee0 	.word	0x20000ee0
 800b5c8:	40004800 	.word	0x40004800
 800b5cc:	40013000 	.word	0x40013000
 800b5d0:	20000f54 	.word	0x20000f54
 800b5d4:	20000fdc 	.word	0x20000fdc
 800b5d8:	40003000 	.word	0x40003000
 800b5dc:	0800cd4c 	.word	0x0800cd4c
 800b5e0:	0800a61d 	.word	0x0800a61d
 800b5e4:	0800c75a 	.word	0x0800c75a
 800b5e8:	0800615d 	.word	0x0800615d
 800b5ec:	20001588 	.word	0x20001588
 800b5f0:	200013a8 	.word	0x200013a8
 800b5f4:	0800c388 	.word	0x0800c388
 800b5f8:	0800af11 	.word	0x0800af11
 800b5fc:	200015f8 	.word	0x200015f8
 800b600:	20001614 	.word	0x20001614
 800b604:	20001648 	.word	0x20001648
 800b608:	e000e400 	.word	0xe000e400
 800b60c:	20001340 	.word	0x20001340
 800b610:	20001344 	.word	0x20001344
 800b614:	20001350 	.word	0x20001350
 800b618:	200015f0 	.word	0x200015f0
 800b61c:	20001348 	.word	0x20001348
 800b620:	20001358 	.word	0x20001358
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800b624:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800b628:	2401      	movs	r4, #1
 800b62a:	005b      	lsls	r3, r3, #1
 800b62c:	b2db      	uxtb	r3, r3
 800b62e:	f88d 3013 	strb.w	r3, [sp, #19]
 800b632:	4603      	mov	r3, r0
 800b634:	e774      	b.n	800b520 <main+0x26c>

    osalSysEnable();

    /* Does not happen */
    osalSysHalt("Return in main?");
 800b636:	f7f9 f9bd 	bl	80049b4 <vTaskEndScheduler>
 800b63a:	e7fe      	b.n	800b63a <main+0x386>

0800b63c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800b63c:	4b1e      	ldr	r3, [pc, #120]	; (800b6b8 <vTaskSwitchContext+0x7c>)
{
 800b63e:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800b640:	681a      	ldr	r2, [r3, #0]
 800b642:	4b1e      	ldr	r3, [pc, #120]	; (800b6bc <vTaskSwitchContext+0x80>)
 800b644:	b112      	cbz	r2, 800b64c <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800b646:	2201      	movs	r2, #1
 800b648:	601a      	str	r2, [r3, #0]
}
 800b64a:	bd30      	pop	{r4, r5, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
 800b64c:	481c      	ldr	r0, [pc, #112]	; (800b6c0 <vTaskSwitchContext+0x84>)
		xYieldPending = pdFALSE;
 800b64e:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
 800b650:	6803      	ldr	r3, [r0, #0]
 800b652:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b654:	681a      	ldr	r2, [r3, #0]
 800b656:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b65a:	d10b      	bne.n	800b674 <vTaskSwitchContext+0x38>
 800b65c:	685a      	ldr	r2, [r3, #4]
 800b65e:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b662:	d107      	bne.n	800b674 <vTaskSwitchContext+0x38>
 800b664:	689a      	ldr	r2, [r3, #8]
 800b666:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 800b66a:	d103      	bne.n	800b674 <vTaskSwitchContext+0x38>
 800b66c:	68db      	ldr	r3, [r3, #12]
 800b66e:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 800b672:	d002      	beq.n	800b67a <vTaskSwitchContext+0x3e>
 800b674:	6803      	ldr	r3, [r0, #0]
 800b676:	6803      	ldr	r3, [r0, #0]
 800b678:	e7fe      	b.n	800b678 <vTaskSwitchContext+0x3c>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800b67a:	4b12      	ldr	r3, [pc, #72]	; (800b6c4 <vTaskSwitchContext+0x88>)
 800b67c:	681a      	ldr	r2, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 800b67e:	fab2 f282 	clz	r2, r2
 800b682:	2314      	movs	r3, #20
 800b684:	b2d2      	uxtb	r2, r2
 800b686:	f1c2 021f 	rsb	r2, r2, #31
 800b68a:	4353      	muls	r3, r2
 800b68c:	490e      	ldr	r1, [pc, #56]	; (800b6c8 <vTaskSwitchContext+0x8c>)
 800b68e:	58cd      	ldr	r5, [r1, r3]
 800b690:	18cc      	adds	r4, r1, r3
 800b692:	b905      	cbnz	r5, 800b696 <vTaskSwitchContext+0x5a>
 800b694:	e7fe      	b.n	800b694 <vTaskSwitchContext+0x58>
 800b696:	6865      	ldr	r5, [r4, #4]
 800b698:	3308      	adds	r3, #8
 800b69a:	686d      	ldr	r5, [r5, #4]
 800b69c:	440b      	add	r3, r1
 800b69e:	429d      	cmp	r5, r3
 800b6a0:	bf08      	it	eq
 800b6a2:	686b      	ldreq	r3, [r5, #4]
 800b6a4:	6065      	str	r5, [r4, #4]
 800b6a6:	bf08      	it	eq
 800b6a8:	6063      	streq	r3, [r4, #4]
 800b6aa:	2314      	movs	r3, #20
 800b6ac:	fb03 1202 	mla	r2, r3, r2, r1
 800b6b0:	6853      	ldr	r3, [r2, #4]
 800b6b2:	68db      	ldr	r3, [r3, #12]
 800b6b4:	6003      	str	r3, [r0, #0]
}
 800b6b6:	e7c8      	b.n	800b64a <vTaskSwitchContext+0xe>
 800b6b8:	2000136c 	.word	0x2000136c
 800b6bc:	2000164c 	.word	0x2000164c
 800b6c0:	200011a8 	.word	0x200011a8
 800b6c4:	20001374 	.word	0x20001374
 800b6c8:	200011b8 	.word	0x200011b8

0800b6cc <mixLedTask>:
{
 800b6cc:	4605      	mov	r5, r0
 800b6ce:	b580      	push	{r7, lr}
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800b6d0:	4e45      	ldr	r6, [pc, #276]	; (800b7e8 <mixLedTask+0x11c>)
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 800b6d2:	4f46      	ldr	r7, [pc, #280]	; (800b7ec <mixLedTask+0x120>)
        gpioSetPin(GPIO_LED_MIX, true);
 800b6d4:	2101      	movs	r1, #1
 800b6d6:	f240 1005 	movw	r0, #261	; 0x105
 800b6da:	f7fb ff27 	bl	800752c <gpioSetPin.isra.0>
        if(!*delay) {
 800b6de:	682b      	ldr	r3, [r5, #0]
 800b6e0:	2b00      	cmp	r3, #0
 800b6e2:	d165      	bne.n	800b7b0 <mixLedTask+0xe4>
		taskENTER_CRITICAL();
 800b6e4:	f7f9 f956 	bl	8004994 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800b6e8:	6834      	ldr	r4, [r6, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b6ea:	f104 0804 	add.w	r8, r4, #4
 800b6ee:	4640      	mov	r0, r8
 800b6f0:	f7f8 ffd1 	bl	8004696 <uxListRemove>
 800b6f4:	b978      	cbnz	r0, 800b716 <mixLedTask+0x4a>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800b6f6:	2014      	movs	r0, #20
 800b6f8:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
 800b6fc:	4b3c      	ldr	r3, [pc, #240]	; (800b7f0 <mixLedTask+0x124>)
 800b6fe:	fb00 f00c 	mul.w	r0, r0, ip
 800b702:	581b      	ldr	r3, [r3, r0]
 800b704:	b93b      	cbnz	r3, 800b716 <mixLedTask+0x4a>
 800b706:	2201      	movs	r2, #1
 800b708:	493a      	ldr	r1, [pc, #232]	; (800b7f4 <mixLedTask+0x128>)
 800b70a:	fa02 f20c 	lsl.w	r2, r2, ip
 800b70e:	680b      	ldr	r3, [r1, #0]
 800b710:	ea23 0302 	bic.w	r3, r3, r2
 800b714:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800b716:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b718:	b11b      	cbz	r3, 800b722 <mixLedTask+0x56>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b71a:	f104 0018 	add.w	r0, r4, #24
 800b71e:	f7f8 ffba 	bl	8004696 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 800b722:	4638      	mov	r0, r7
 800b724:	4641      	mov	r1, r8
 800b726:	f7f8 ff93 	bl	8004650 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 800b72a:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		if( xSchedulerRunning != pdFALSE )
 800b72e:	4832      	ldr	r0, [pc, #200]	; (800b7f8 <mixLedTask+0x12c>)
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 800b730:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800b732:	bf04      	itt	eq
 800b734:	2300      	moveq	r3, #0
 800b736:	f884 3064 	strbeq.w	r3, [r4, #100]	; 0x64
		taskEXIT_CRITICAL();
 800b73a:	f7f9 fb43 	bl	8004dc4 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800b73e:	6803      	ldr	r3, [r0, #0]
 800b740:	b12b      	cbz	r3, 800b74e <mixLedTask+0x82>
			taskENTER_CRITICAL();
 800b742:	f7f9 f927 	bl	8004994 <vPortEnterCritical>
				prvResetNextTaskUnblockTime();
 800b746:	f7f8 ffdd 	bl	8004704 <prvResetNextTaskUnblockTime>
			taskEXIT_CRITICAL();
 800b74a:	f7f9 fb3b 	bl	8004dc4 <vPortExitCritical>
		if( pxTCB == pxCurrentTCB )
 800b74e:	6833      	ldr	r3, [r6, #0]
 800b750:	429c      	cmp	r4, r3
 800b752:	d1bf      	bne.n	800b6d4 <mixLedTask+0x8>
			if( xSchedulerRunning != pdFALSE )
 800b754:	6803      	ldr	r3, [r0, #0]
 800b756:	b30b      	cbz	r3, 800b79c <mixLedTask+0xd0>
				configASSERT( uxSchedulerSuspended == 0 );
 800b758:	4b28      	ldr	r3, [pc, #160]	; (800b7fc <mixLedTask+0x130>)
 800b75a:	681b      	ldr	r3, [r3, #0]
 800b75c:	b103      	cbz	r3, 800b760 <mixLedTask+0x94>
 800b75e:	e7fe      	b.n	800b75e <mixLedTask+0x92>
				portYIELD_WITHIN_API();
 800b760:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b764:	4a26      	ldr	r2, [pc, #152]	; (800b800 <mixLedTask+0x134>)
 800b766:	f8d3 1d20 	ldr.w	r1, [r3, #3360]	; 0xd20
 800b76a:	6011      	str	r1, [r2, #0]
 800b76c:	4a25      	ldr	r2, [pc, #148]	; (800b804 <mixLedTask+0x138>)
 800b76e:	6812      	ldr	r2, [r2, #0]
 800b770:	b14a      	cbz	r2, 800b786 <mixLedTask+0xba>
 800b772:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b776:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 800b77a:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800b77e:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	; 0xd20
 800b782:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800b786:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b78a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b78e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800b792:	f3bf 8f4f 	dsb	sy
 800b796:	f3bf 8f6f 	isb	sy
 800b79a:	e79b      	b.n	800b6d4 <mixLedTask+0x8>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800b79c:	4a1a      	ldr	r2, [pc, #104]	; (800b808 <mixLedTask+0x13c>)
 800b79e:	6839      	ldr	r1, [r7, #0]
 800b7a0:	6812      	ldr	r2, [r2, #0]
 800b7a2:	4291      	cmp	r1, r2
 800b7a4:	d101      	bne.n	800b7aa <mixLedTask+0xde>
					pxCurrentTCB = NULL;
 800b7a6:	6033      	str	r3, [r6, #0]
 800b7a8:	e794      	b.n	800b6d4 <mixLedTask+0x8>
					vTaskSwitchContext();
 800b7aa:	f7ff ff47 	bl	800b63c <vTaskSwitchContext>
 800b7ae:	e791      	b.n	800b6d4 <mixLedTask+0x8>
        osalThreadSleepMilliseconds(*delay);
 800b7b0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800b7b4:	6828      	ldr	r0, [r5, #0]
 800b7b6:	4360      	muls	r0, r4
 800b7b8:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 800b7bc:	fbb0 f0f4 	udiv	r0, r0, r4
 800b7c0:	f7f9 fdde 	bl	8005380 <vTaskDelay>
        gpioSetPin(GPIO_LED_MIX, false);
 800b7c4:	2100      	movs	r1, #0
 800b7c6:	f240 1005 	movw	r0, #261	; 0x105
 800b7ca:	f7fb feaf 	bl	800752c <gpioSetPin.isra.0>
        if(*delay) {
 800b7ce:	682b      	ldr	r3, [r5, #0]
 800b7d0:	2b00      	cmp	r3, #0
 800b7d2:	f43f af7f 	beq.w	800b6d4 <mixLedTask+0x8>
            osalThreadSleepMilliseconds(*delay);
 800b7d6:	6828      	ldr	r0, [r5, #0]
 800b7d8:	4360      	muls	r0, r4
 800b7da:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 800b7de:	fbb0 f0f4 	udiv	r0, r0, r4
 800b7e2:	f7f9 fdcd 	bl	8005380 <vTaskDelay>
 800b7e6:	e775      	b.n	800b6d4 <mixLedTask+0x8>
 800b7e8:	200011a8 	.word	0x200011a8
 800b7ec:	20001620 	.word	0x20001620
 800b7f0:	200011b8 	.word	0x200011b8
 800b7f4:	20001374 	.word	0x20001374
 800b7f8:	20001614 	.word	0x20001614
 800b7fc:	2000136c 	.word	0x2000136c
 800b800:	2000134c 	.word	0x2000134c
 800b804:	20001358 	.word	0x20001358
 800b808:	2000135c 	.word	0x2000135c

0800b80c <memset>:
 800b80c:	0783      	lsls	r3, r0, #30
 800b80e:	b530      	push	{r4, r5, lr}
 800b810:	d048      	beq.n	800b8a4 <memset+0x98>
 800b812:	1e54      	subs	r4, r2, #1
 800b814:	2a00      	cmp	r2, #0
 800b816:	d03f      	beq.n	800b898 <memset+0x8c>
 800b818:	4603      	mov	r3, r0
 800b81a:	b2ca      	uxtb	r2, r1
 800b81c:	e001      	b.n	800b822 <memset+0x16>
 800b81e:	3c01      	subs	r4, #1
 800b820:	d33a      	bcc.n	800b898 <memset+0x8c>
 800b822:	f803 2b01 	strb.w	r2, [r3], #1
 800b826:	079d      	lsls	r5, r3, #30
 800b828:	d1f9      	bne.n	800b81e <memset+0x12>
 800b82a:	2c03      	cmp	r4, #3
 800b82c:	d92d      	bls.n	800b88a <memset+0x7e>
 800b82e:	b2cd      	uxtb	r5, r1
 800b830:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800b834:	2c0f      	cmp	r4, #15
 800b836:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800b83a:	d936      	bls.n	800b8aa <memset+0x9e>
 800b83c:	f1a4 0210 	sub.w	r2, r4, #16
 800b840:	f022 0c0f 	bic.w	ip, r2, #15
 800b844:	f103 0e20 	add.w	lr, r3, #32
 800b848:	44e6      	add	lr, ip
 800b84a:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 800b84e:	f103 0210 	add.w	r2, r3, #16
 800b852:	e942 5504 	strd	r5, r5, [r2, #-16]
 800b856:	e942 5502 	strd	r5, r5, [r2, #-8]
 800b85a:	3210      	adds	r2, #16
 800b85c:	4572      	cmp	r2, lr
 800b85e:	d1f8      	bne.n	800b852 <memset+0x46>
 800b860:	f10c 0201 	add.w	r2, ip, #1
 800b864:	f014 0f0c 	tst.w	r4, #12
 800b868:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800b86c:	f004 0c0f 	and.w	ip, r4, #15
 800b870:	d013      	beq.n	800b89a <memset+0x8e>
 800b872:	f1ac 0304 	sub.w	r3, ip, #4
 800b876:	f023 0303 	bic.w	r3, r3, #3
 800b87a:	3304      	adds	r3, #4
 800b87c:	4413      	add	r3, r2
 800b87e:	f842 5b04 	str.w	r5, [r2], #4
 800b882:	4293      	cmp	r3, r2
 800b884:	d1fb      	bne.n	800b87e <memset+0x72>
 800b886:	f00c 0403 	and.w	r4, ip, #3
 800b88a:	b12c      	cbz	r4, 800b898 <memset+0x8c>
 800b88c:	b2ca      	uxtb	r2, r1
 800b88e:	441c      	add	r4, r3
 800b890:	f803 2b01 	strb.w	r2, [r3], #1
 800b894:	429c      	cmp	r4, r3
 800b896:	d1fb      	bne.n	800b890 <memset+0x84>
 800b898:	bd30      	pop	{r4, r5, pc}
 800b89a:	4664      	mov	r4, ip
 800b89c:	4613      	mov	r3, r2
 800b89e:	2c00      	cmp	r4, #0
 800b8a0:	d1f4      	bne.n	800b88c <memset+0x80>
 800b8a2:	e7f9      	b.n	800b898 <memset+0x8c>
 800b8a4:	4603      	mov	r3, r0
 800b8a6:	4614      	mov	r4, r2
 800b8a8:	e7bf      	b.n	800b82a <memset+0x1e>
 800b8aa:	461a      	mov	r2, r3
 800b8ac:	46a4      	mov	ip, r4
 800b8ae:	e7e0      	b.n	800b872 <memset+0x66>

0800b8b0 <strchr>:
 800b8b0:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 800b8b4:	4603      	mov	r3, r0
 800b8b6:	d044      	beq.n	800b942 <strchr+0x92>
 800b8b8:	0782      	lsls	r2, r0, #30
 800b8ba:	d132      	bne.n	800b922 <strchr+0x72>
 800b8bc:	b510      	push	{r4, lr}
 800b8be:	6804      	ldr	r4, [r0, #0]
 800b8c0:	ea41 2e01 	orr.w	lr, r1, r1, lsl #8
 800b8c4:	ea4e 4e0e 	orr.w	lr, lr, lr, lsl #16
 800b8c8:	ea8e 0204 	eor.w	r2, lr, r4
 800b8cc:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b8d0:	ea23 0302 	bic.w	r3, r3, r2
 800b8d4:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 800b8d8:	ea22 0204 	bic.w	r2, r2, r4
 800b8dc:	4313      	orrs	r3, r2
 800b8de:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b8e2:	d10f      	bne.n	800b904 <strchr+0x54>
 800b8e4:	f850 4f04 	ldr.w	r4, [r0, #4]!
 800b8e8:	ea84 0c0e 	eor.w	ip, r4, lr
 800b8ec:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 800b8f0:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 800b8f4:	ea23 0304 	bic.w	r3, r3, r4
 800b8f8:	ea22 020c 	bic.w	r2, r2, ip
 800b8fc:	4313      	orrs	r3, r2
 800b8fe:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b902:	d0ef      	beq.n	800b8e4 <strchr+0x34>
 800b904:	7803      	ldrb	r3, [r0, #0]
 800b906:	b923      	cbnz	r3, 800b912 <strchr+0x62>
 800b908:	e036      	b.n	800b978 <strchr+0xc8>
 800b90a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b90e:	2b00      	cmp	r3, #0
 800b910:	d032      	beq.n	800b978 <strchr+0xc8>
 800b912:	4299      	cmp	r1, r3
 800b914:	d1f9      	bne.n	800b90a <strchr+0x5a>
 800b916:	bd10      	pop	{r4, pc}
 800b918:	428a      	cmp	r2, r1
 800b91a:	d011      	beq.n	800b940 <strchr+0x90>
 800b91c:	079a      	lsls	r2, r3, #30
 800b91e:	4618      	mov	r0, r3
 800b920:	d0cc      	beq.n	800b8bc <strchr+0xc>
 800b922:	4618      	mov	r0, r3
 800b924:	f813 2b01 	ldrb.w	r2, [r3], #1
 800b928:	2a00      	cmp	r2, #0
 800b92a:	d1f5      	bne.n	800b918 <strchr+0x68>
 800b92c:	4610      	mov	r0, r2
 800b92e:	4770      	bx	lr
 800b930:	0799      	lsls	r1, r3, #30
 800b932:	4618      	mov	r0, r3
 800b934:	d007      	beq.n	800b946 <strchr+0x96>
 800b936:	4618      	mov	r0, r3
 800b938:	7802      	ldrb	r2, [r0, #0]
 800b93a:	3301      	adds	r3, #1
 800b93c:	2a00      	cmp	r2, #0
 800b93e:	d1f7      	bne.n	800b930 <strchr+0x80>
 800b940:	4770      	bx	lr
 800b942:	0782      	lsls	r2, r0, #30
 800b944:	d1f7      	bne.n	800b936 <strchr+0x86>
 800b946:	6802      	ldr	r2, [r0, #0]
 800b948:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b94c:	ea23 0302 	bic.w	r3, r3, r2
 800b950:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b954:	d108      	bne.n	800b968 <strchr+0xb8>
 800b956:	f850 2f04 	ldr.w	r2, [r0, #4]!
 800b95a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800b95e:	ea23 0302 	bic.w	r3, r3, r2
 800b962:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b966:	d0f6      	beq.n	800b956 <strchr+0xa6>
 800b968:	7803      	ldrb	r3, [r0, #0]
 800b96a:	2b00      	cmp	r3, #0
 800b96c:	d0e8      	beq.n	800b940 <strchr+0x90>
 800b96e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800b972:	2b00      	cmp	r3, #0
 800b974:	d1fb      	bne.n	800b96e <strchr+0xbe>
 800b976:	4770      	bx	lr
 800b978:	4618      	mov	r0, r3
 800b97a:	bd10      	pop	{r4, pc}

0800b97c <strlen>:
 800b97c:	f020 0103 	bic.w	r1, r0, #3
 800b980:	f010 0003 	ands.w	r0, r0, #3
 800b984:	f1c0 0000 	rsb	r0, r0, #0
 800b988:	f851 3b04 	ldr.w	r3, [r1], #4
 800b98c:	f100 0c04 	add.w	ip, r0, #4
 800b990:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800b994:	f06f 0200 	mvn.w	r2, #0
 800b998:	bf1c      	itt	ne
 800b99a:	fa22 f20c 	lsrne.w	r2, r2, ip
 800b99e:	4313      	orrne	r3, r2
 800b9a0:	f04f 0c01 	mov.w	ip, #1
 800b9a4:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800b9a8:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800b9ac:	eba3 020c 	sub.w	r2, r3, ip
 800b9b0:	ea22 0203 	bic.w	r2, r2, r3
 800b9b4:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800b9b8:	bf04      	itt	eq
 800b9ba:	f851 3b04 	ldreq.w	r3, [r1], #4
 800b9be:	3004      	addeq	r0, #4
 800b9c0:	d0f4      	beq.n	800b9ac <strlen+0x30>
 800b9c2:	f1c2 0100 	rsb	r1, r2, #0
 800b9c6:	ea02 0201 	and.w	r2, r2, r1
 800b9ca:	fab2 f282 	clz	r2, r2
 800b9ce:	f1c2 021f 	rsb	r2, r2, #31
 800b9d2:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800b9d6:	4770      	bx	lr

0800b9d8 <strpbrk>:
 800b9d8:	4684      	mov	ip, r0
 800b9da:	7800      	ldrb	r0, [r0, #0]
 800b9dc:	b1b8      	cbz	r0, 800ba0e <strpbrk+0x36>
 800b9de:	b500      	push	{lr}
 800b9e0:	468e      	mov	lr, r1
 800b9e2:	7809      	ldrb	r1, [r1, #0]
 800b9e4:	4672      	mov	r2, lr
 800b9e6:	460b      	mov	r3, r1
 800b9e8:	b919      	cbnz	r1, 800b9f2 <strpbrk+0x1a>
 800b9ea:	e00b      	b.n	800ba04 <strpbrk+0x2c>
 800b9ec:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800b9f0:	b143      	cbz	r3, 800ba04 <strpbrk+0x2c>
 800b9f2:	4298      	cmp	r0, r3
 800b9f4:	d1fa      	bne.n	800b9ec <strpbrk+0x14>
 800b9f6:	7813      	ldrb	r3, [r2, #0]
 800b9f8:	2b00      	cmp	r3, #0
 800b9fa:	bf14      	ite	ne
 800b9fc:	4660      	movne	r0, ip
 800b9fe:	2000      	moveq	r0, #0
 800ba00:	f85d fb04 	ldr.w	pc, [sp], #4
 800ba04:	f81c 0f01 	ldrb.w	r0, [ip, #1]!
 800ba08:	2800      	cmp	r0, #0
 800ba0a:	d1eb      	bne.n	800b9e4 <strpbrk+0xc>
 800ba0c:	e7f3      	b.n	800b9f6 <strpbrk+0x1e>
 800ba0e:	4770      	bx	lr

0800ba10 <strspn>:
 800ba10:	b510      	push	{r4, lr}
 800ba12:	468e      	mov	lr, r1
 800ba14:	7801      	ldrb	r1, [r0, #0]
 800ba16:	b199      	cbz	r1, 800ba40 <strspn+0x30>
 800ba18:	4604      	mov	r4, r0
 800ba1a:	4684      	mov	ip, r0
 800ba1c:	f89e 0000 	ldrb.w	r0, [lr]
 800ba20:	b158      	cbz	r0, 800ba3a <strspn+0x2a>
 800ba22:	4672      	mov	r2, lr
 800ba24:	4603      	mov	r3, r0
 800ba26:	e002      	b.n	800ba2e <strspn+0x1e>
 800ba28:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800ba2c:	b12b      	cbz	r3, 800ba3a <strspn+0x2a>
 800ba2e:	428b      	cmp	r3, r1
 800ba30:	d1fa      	bne.n	800ba28 <strspn+0x18>
 800ba32:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 800ba36:	2900      	cmp	r1, #0
 800ba38:	d1f2      	bne.n	800ba20 <strspn+0x10>
 800ba3a:	ebac 0004 	sub.w	r0, ip, r4
 800ba3e:	bd10      	pop	{r4, pc}
 800ba40:	4608      	mov	r0, r1
 800ba42:	bd10      	pop	{r4, pc}
